<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mineseeker: 逆转版扫雷</title>
    <style>
        :root {
            --bg-color: #050505;
            --grid-bg: #000000;
            --cell-unrevealed: #1a1a1a;
            --cell-revealed: #050505;
            --cell-border-light: #333;
            --cell-border-dark: #111;

            --neon-blue: #00f3ff;
            --neon-red: #ff003c;
            --neon-green: #00ff66;
            --neon-yellow: #fcee0a;
            --text-main: #e0e0e0;
        }

        @font-face {
            font-family: 'Cyber';
            src: local('Courier New');
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #game-container {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .shake {
            animation: shake-anim 0.2s ease-in-out;
        }

        @keyframes shake-anim {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-3px, 3px);
            }

            50% {
                transform: translate(3px, -3px);
            }

            75% {
                transform: translate(-3px, -3px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* 顶部 HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            width: 100%;
            padding: 15px 20px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0));
            text-shadow: 0 0 5px var(--neon-blue);
            z-index: 20;
            pointer-events: none;
            /* 让下面的点击穿透，除了按钮 */
        }

        /* === 修改 .hud-info === */
        .hud-info {
            display: flex;
            gap: 20px;
            font-size: 1rem;
            font-weight: bold;
            flex-grow: 1;
            overflow: hidden;
            /* 防止溢出 */
        }

        /* === 新增：针对内部每一个小项的样式 === */
        .hud-info div {
            /* 核心修复：强制不换行，让 "状态：就绪" 永远连在一起 */
            white-space: nowrap;
        }

        /* === 新增：手机竖屏下的适配 === */
        @media (max-width: 480px) {
            .hud-info {
                /* 手机屏幕窄，减小间距 */
                gap: 8px;
                /* 稍微减小字体，确保三个数据能排成一行 */
                font-size: 0.85rem;
            }

            /* 如果屏幕特别小（如 iPhone SE），稍微压缩一下顶部按钮的边距 */
            #hud {
                padding: 10px 10px;
            }
        }

        /* 顶部常驻按钮组 */
        .top-controls {
            display: flex;
            gap: 10px;
            pointer-events: auto;
            /* 恢复按钮交互 */
        }

        .icon-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        #grid-wrapper {
            position: relative;
            padding: 4px;
            border: 1px solid var(--cell-border-light);
            background: var(--grid-bg);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: margin 0.3s;
            /* 这里的 position: relative 不再限制 canvas，因为 canvas 已经是 fixed 了 */
        }

        #grid {
            display: grid;
            border: 1px solid var(--cell-border-light);
            position: relative;
            z-index: 2;
        }

        #ray-canvas {
            position: fixed;
            /* 改为 fixed 全屏 */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            /* 关键：让鼠标点击能穿透它点到底下的游戏 */
            z-index: 50;
            /* 确保它在网格之上，但在弹窗(z-index:100)之下 */
            mix-blend-mode: screen;
            /* 保持原有的混合模式 */

            will-change: transform, opacity;
            transform: translateZ(0);
        }

        .cell {
            background-color: var(--cell-unrevealed);
            border: 1px solid #333;
            box-shadow: inset 1px 1px 0 rgba(255, 255, 255, 0.05), inset -1px -1px 0 rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s;
            position: relative;
            font-size: 1.1rem;
            color: transparent;
            transition: background-color 0.2s ease-out, color 0.2s ease-out;
        }

        .cell.active {
            background-color: #333;
            box-shadow: inset 0 0 10px var(--neon-blue);
        }

        .cell.revealed {
            background-color: var(--cell-revealed);
            border: 1px solid #111;
            box-shadow: none;
            color: inherit;
            cursor: default;
            transition: background-color 0.3s ease-out;
        }

        .cell.marked::after {
            content: '';
            /* 清空文字内容 */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* 绝对定位居中 */

            width: 60%;
            /* 控制盾牌大小，相对于格子 */
            height: 60%;

            /* 核心技术：使用 CSS 变量作为背景色 */
            background-color: var(--neon-green);

            /* 核心技术：使用 SVG 作为遮罩来塑造形状 */
            /* 这里使用的是选项 B (棱角盾牌) 的 URL 编码数据 */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            /* 使用 box-shadow 代替 text-shadow 来制造发光效果 */
            box-shadow: 0 0 10px var(--neon-green);

            opacity: 0.9;
            pointer-events: none;
            /* 确保鼠标事件穿透图标打到格子上 */
            z-index: 5;
        }

        .cell[data-num="0"] {
            color: #222;
        }

        .cell[data-num="1"] {
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
        }

        .cell[data-num="2"] {
            color: var(--neon-green);
            text-shadow: 0 0 8px var(--neon-green);
        }

        .cell[data-num="3"] {
            color: var(--neon-yellow);
            text-shadow: 0 0 8px var(--neon-yellow);
        }

        .cell[data-num="4"] {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }

        .cell[data-num="5"] {
            color: var(--neon-red);
            text-shadow: 0 0 8px var(--neon-red);
        }

        .cell[data-num="6"] {
            color: cyan;
        }

        .cell[data-num="7"] {
            color: white;
        }

        .cell[data-num="8"] {
            color: grey;
        }

        .cell.mine-flash {
            background-color: #fff !important;
            transition: background-color 0.05s;
            box-shadow: 0 0 20px #fff;
            z-index: 10;
        }

        .cell.mine {
            background-color: rgba(255, 0, 60, 0.2);
            border: 1px solid var(--neon-red);
            box-shadow: inset 0 0 10px rgba(255, 0, 60, 0.3);
            animation: pulse-border 1.5s infinite;
            color: var(--neon-red) !important;
            text-shadow: 0 0 8px var(--neon-red);
        }

        @keyframes pulse-border {
            0% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }

            50% {
                box-shadow: inset 0 0 15px rgba(255, 0, 60, 0.6);
            }

            100% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }
        }

        /* 响应式工具栏 */
        #toolbar {
            position: absolute;
            z-index: 30;
            display: flex;
            gap: 15px;
            padding: 10px;
            pointer-events: auto;
        }

        /* 竖屏模式 (Portrait): 工具栏在底部 */
        @media (orientation: portrait) {
            #toolbar {
                bottom: 60px;
                /* 给底部文字留点空间 */
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
            }

            #grid-wrapper {
                margin: 0;
                margin-bottom: 100px;
                /* 给下方工具栏留空 */
            }
        }

        /* 横屏模式 (Landscape): 工具栏在右侧 */
        @media (orientation: landscape) {
            #toolbar {
                right: 20px;
                top: 50%;
                transform: translateY(-50%);
                flex-direction: column;
            }

            #grid-wrapper {
                margin-right: 80px;
                /* 给右侧工具栏留空 */
                margin-bottom: 0;
            }
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #666;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: -2px 2px 10px rgba(0, 0, 0, 0.5);
            touch-action: manipulation;
        }

        .tool-btn span {
            pointer-events: none;
        }

        .tool-btn.active {
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: scale(1.1);
        }

        .tool-btn#btn-mode-mark.active {
            background: rgba(0, 255, 102, 0.15);
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 15px rgba(0, 255, 102, 0.3);
        }

        #btn-mode-mark span {
            display: inline-block;
            width: 28px;
            /* 设置图标宽度 */
            height: 28px;
            /* 设置图标高度 */

            /* 核心：让背景色继承父级按钮的颜色 (灰色或霓虹绿) */
            background-color: currentColor;

            /* 使用与格子标记相同的 SVG 遮罩 */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            pointer-events: none;
            /* 保持穿透 */
        }

        #guide-text {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            text-shadow: 0 0 3px black;
            z-index: 20;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0));
            padding-bottom: 5px;
        }

        #menu-overlay,
        #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        h1 {
            color: var(--neon-blue);
            text-shadow: 0 0 15px var(--neon-blue);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-align: center;
        }

        .control-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 300px;
        }

        label {
            color: var(--neon-green);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: #333;
            height: 6px;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--neon-blue);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-blue);
            border: 2px solid #fff;
        }

        .menu-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            font-size: 1.1rem;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .menu-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue);
        }

        .hidden {
            display: none !important;
        }

        #end-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .win {
            color: var(--neon-green);
            text-shadow: 0 0 20px var(--neon-green);
        }

        .lose {
            color: var(--neon-red);
            text-shadow: 0 0 20px var(--neon-red);
        }

        /* === 计时器样式 === */
        #timer-display {
            font-family: 'Cyber', monospace;
            color: var(--neon-blue);
            min-width: 60px;
            display: inline-block;
        }

        /* === 全新的结算卡片样式 === */
        .result-card {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 0, 0, 0.8);
            padding: 2px;
            /* 给内边框留空 */
            width: 90%;
            max-width: 400px;
            position: relative;
            backdrop-filter: blur(10px);
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 动画激活状态 */
        #game-over-overlay:not(.hidden) .result-card {
            transform: scale(1);
            opacity: 1;
        }

        .card-header {
            background: rgba(0, 243, 255, 0.1);
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid #333;
            position: relative;
            overflow: hidden;
        }

        .card-header h2 {
            margin: 0;
            font-size: 1.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* 扫描线动画 */
        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--neon-blue);
            opacity: 0.5;
            animation: scan-down 2s linear infinite;
        }

        @keyframes scan-down {
            0% {
                top: 0%;
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                top: 100%;
                opacity: 0;
            }
        }

        .card-body {
            padding: 20px 30px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            border-bottom: 1px dashed #333;
            padding-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        .stat-value {
            color: var(--text-main);
            font-weight: bold;
            font-family: 'Cyber', monospace;
            font-size: 1.1rem;
        }

        .flavor-text {
            text-align: center;
            margin-top: 20px;
            color: #888;
            font-style: italic;
            font-size: 0.9rem;
        }

        .card-actions {
            padding: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        /* 次级按钮样式 */
        .menu-btn.secondary {
            background: transparent;
            border-color: #444;
            color: #888;
            box-shadow: none;
            font-size: 0.9rem;
        }

        .menu-btn.secondary:hover {
            border-color: #fff;
            color: #fff;
        }

        /* 胜利时的卡片配色变种 */
        .result-card.win-theme {
            border-color: var(--neon-green);
            box-shadow: 0 0 30px rgba(0, 255, 102, 0.15);
        }

        .result-card.win-theme .card-header {
            background: rgba(0, 255, 102, 0.1);
        }

        .result-card.win-theme .scan-line {
            background: var(--neon-green);
        }

        /* 失败时的卡片配色变种 */
        .result-card.lose-theme {
            border-color: var(--neon-red);
            box-shadow: 0 0 30px rgba(255, 0, 60, 0.15);
        }

        .result-card.lose-theme .card-header {
            background: rgba(255, 0, 60, 0.1);
        }

        .result-card.lose-theme .scan-line {
            background: var(--neon-red);
        }


        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 110;
            /* 比 menu/gameover 更高也没问题 */
        }

        /* === 修改 .tutorial-card：增加弹性布局和最大高度 === */
        .tutorial-card {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 0, 0, 0.8);
            padding: 2px;
            /* 保持原有的 padding */
            width: 92%;
            max-width: 560px;
            backdrop-filter: blur(10px);

            /* --- 新增修复代码 --- */
            display: flex;
            /* 开启 Flex 布局 */
            flex-direction: column;
            /* 垂直排列 */
            max-height: 85vh;
            /* 限制最大高度为视口高度的 85% */
            overflow: hidden;
            /* 防止卡片自身溢出 */
        }

        /* === 修改 .card-body：允许内部滚动 === */
        .tutorial-card .card-body {
            /* 继承原有的 padding: 20px 30px; 但建议在手机上缩小一点 */
            padding: 20px;

            /* --- 新增修复代码 --- */
            overflow-y: auto;
            /* 允许垂直滚动 */
            flex: 1;
            /* 占据剩余空间 */
            min-height: 0;
            /* Firefox Flex 滚动修复 */
            -webkit-overflow-scrolling: touch;
            /* iOS 平滑滚动 */
        }

        /* === 新增：防止标题和底部按钮被压缩 === */
        .tutorial-card .card-header,
        .tutorial-card .card-actions {
            flex-shrink: 0;
            /* 禁止压缩头部和底部 */
            background: rgba(10, 10, 15, 0.95);
            /* 加深背景防止文字透视重叠 */
            z-index: 2;
        }

        /* 针对手机横屏的额外优化 */
        @media (max-height: 500px) {
            .tutorial-card {
                max-height: 95vh;
                /* 横屏时利用更多高度 */
            }

            .tutorial-card .card-body {
                padding: 10px 20px;
            }
        }

        .tutorial-section-title {
            color: var(--neon-green);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }

        .tutorial-grid {
            display: grid;
            grid-template-columns: 92px 1fr 1fr;
            gap: 8px 12px;
            align-items: start;
        }

        .tutorial-col-head {
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
            font-weight: bold;
            font-size: 0.9rem;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }

        .tutorial-col-head:nth-child(1) {
            grid-column: 2 / 3;
        }

        .tutorial-col-head:nth-child(2) {
            grid-column: 3 / 4;
        }

        .tutorial-label {
            color: #666;
            font-size: 0.85rem;
            padding-top: 4px;
            border-bottom: 1px dashed #222;
        }

        .tutorial-item {
            color: var(--text-main);
            font-size: 0.9rem;
            line-height: 1.35;
            border-bottom: 1px dashed #222;
            padding-bottom: 6px;
        }

        @media (max-width: 420px) {
            .tutorial-grid {
                grid-template-columns: 78px 1fr 1fr;
                gap: 6px 10px;
            }

            .tutorial-item {
                font-size: 0.85rem;
            }
        }

        /* --- 左上角头像挂件 (窗口内) --- */
        #profile-link {
            position: absolute;
            /* 调整到窗口内部左上角的合适位置 */
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            /* 稍微缩进一点间距 */
            text-decoration: none;
            /* 确保在启动屏幕(z-index:100)之上 */
            z-index: 101;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        #profile-link:hover {
            filter: brightness(1.2);
        }

        #profile-link:hover img {
            box-shadow: 0 0 20px #00f3ff;
            transform: scale(1.05) rotate(5deg);
            /* 增加一点点旋转动感 */
        }

        #profile-link img {
            width: 45px;
            /* 稍微缩小一点点以适应内部空间 */
            height: 45px;
            /* 核心修改：圆形蒙版 */
            border-radius: 50%;
            border: 2px solid #00f3ff;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            background: #000;
            object-fit: cover;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .profile-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .profile-name {
            color: #e0fbfc;
            font-size: 0.9rem;
            /* 字体稍微减小适配 */
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
            font-family: 'Courier New', monospace;
        }

        .profile-role {
            color: #005f73;
            font-size: 0.6rem;
            letter-spacing: 2px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="scanlines"></div>

    <div id="game-container">
        <div id="hud">
            <div class="hud-info">
                <div>目标: <span id="mines-left">0</span></div>
                <div>时间: <span id="timer-display">00:00</span></div>
                <div>状态: <span id="status-text" style="color:var(--neon-green)">就绪</span></div>
            </div>
            <div class="top-controls">
                <div class="icon-btn" id="btn-ingame-tutorial" title="教程">?</div>
                <div class="icon-btn" id="btn-ingame-restart" title="重开">↻</div>
                <div class="icon-btn" id="btn-ingame-menu" title="菜单">☰</div>
            </div>
        </div>

        <div id="game-over-overlay" class="hidden">
            <div class="result-card">
                <div class="card-header">
                    <h2 id="end-title">MISSION COMPLETE</h2>
                    <div class="scan-line"></div>
                </div>

                <div class="card-body">
                    <div class="stat-row">
                        <span class="stat-label">耗时 / TIME</span>
                        <span class="stat-value" id="end-time">00:00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">难度 / DIFFICULTY</span>
                        <span class="stat-value" id="end-difficulty">NORMAL</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">完成度 / COMPLETION</span>
                        <span class="stat-value" id="end-percentage">100%</span>
                    </div>

                    <p id="end-reason" class="flavor-text">所有威胁已消除</p>
                </div>

                <div class="card-actions">
                    <button class="menu-btn" id="btn-restart">重启系统</button>
                    <button class="menu-btn secondary" id="btn-menu">返回菜单</button>
                </div>
            </div>
        </div>

        <div id="grid-wrapper">
            <div id="grid"></div>
        </div>

        <canvas id="ray-canvas"></canvas>

        <div id="toolbar">
            <div class="tool-btn active" id="btn-mode-detonate" onclick="setMode('detonate')" title="引爆模式">
                <span>⚡</span>
            </div>
            <div class="tool-btn" id="btn-mode-mark" onclick="setMode('mark')" title="标记模式">
                <span></span>
            </div>
        </div>

        <div id="guide-text">长按雷区并滑动 > 必须命中雷才能存活</div>
    </div>

    <div id="menu-overlay">
        <a id="profile-link" href="/">
            <img src="/avatar.jpg" alt="Avatar">
            <div class="profile-info">
                <span class="profile-name">回到主页</span>
                <span class="profile-role">状态：已连接</span>
            </div>
        </a>
        <h1>MINESEEKER</h1>
        <div class="control-group">
            <label>网格宽度: <span id="val-w">10</span></label>
            <input type="range" id="inp-w" min="8" max="32" value="10">
        </div>
        <div class="control-group">
            <label>网格高度: <span id="val-h">15</span></label>
            <input type="range" id="inp-h" min="8" max="32" value="15">
        </div>
        <div class="control-group">
            <label>地雷密度: <span id="val-d">30%</span></label>
            <input type="range" id="inp-d" min="25" max="75" value="30" step="5">
        </div>
        <button class="menu-btn" id="btn-start">启动协议</button>
        <button class="menu-btn secondary" id="btn-tutorial">查看教程</button>

    </div>

    <div id="tutorial-overlay" class="hidden">
        <div class="tutorial-card">
            <div class="card-header">
                <h2>HOW TO PLAY</h2>
                <div class="scan-line"></div>
            </div>

            <div class="card-body">
                <div class="tutorial-section-title">Minesweeper vs. Mineseeker</div>

                <div class="tutorial-grid">
                    <div class="tutorial-col-head">扫雷 / MINESWEEPER</div>
                    <div class="tutorial-col-head">找雷 / MINESEEKER</div>

                    <div class="tutorial-label">目标</div>
                    <div class="tutorial-item">找出地雷 / 开完安全格</div>
                    <div class="tutorial-item"><b>揭示所有地雷的位置</b></div>

                    <div class="tutorial-label">失败</div>
                    <div class="tutorial-item">点到雷 = 失败</div>
                    <div class="tutorial-item"><b>起爆点选到非雷 = 失败</b></div>

                    <div class="tutorial-label">开局</div>
                    <div class="tutorial-item">第一下必安全</div>
                    <div class="tutorial-item"><b>第一下必是雷</b>（直接从任意点拖动开始）</div>

                    <div class="tutorial-label">操作</div>
                    <div class="tutorial-item">点击揭开 / 插旗</div>
                    <div class="tutorial-item"><b>按住并朝八方向拖动</b>发射射线；右键/标记模式可标记</div>

                    <div class="tutorial-label">爆炸规则</div>
                    <div class="tutorial-item">爆炸后游戏结束</div>
                    <div class="tutorial-item">
                        <b>爆炸→冲击波→射线</b><br>
                        ① 揭示周围8格<br>
                        ② 射线沿拖动方向穿透<b>4格未揭示格</b>（加上①则路径至少5格）<br>
                        ③ 射线命中未揭示地雷会引爆并<b>同方向连锁</b><br>
                    </div>

                    <div class="tutorial-label">数字</div>
                    <div class="tutorial-item">周围8格雷数</div>
                    <div class="tutorial-item">周围8格雷数</div>
                </div>

                <p class="flavor-text" style="margin-top:14px;">
                    省流：<b>拖动发射射线；起爆必须命中雷；把所有雷都揭示就赢。</b>
                </p>
            </div>

            <div class="card-actions">
                <button class="menu-btn" id="btn-tutorial-back">返回</button>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            gridW: 10,
            gridH: 15,
            density: 0.3,
            cellSize: 35,
            rayLength: 5,
            penetrationLimit: 4, // 最大穿透未揭开格子的数量
            colors: {
                blue: '#00f3ff',
                green: '#00ff66',
                red: '#ff003c',
                yellow: '#fcee0a',
                white: '#ffffff',
                purple: '#bc13fe'
            }
        };

        const AUDIO_CTX = new (window.AudioContext || window.webkitAudioContext)();

        let gridData = [];
        let totalMines = 0;
        let revealedMines = 0;
        let isFirstMove = true;
        let isGameOver = false;
        let currentMode = 'detonate';

        let gameStartTime = 0;
        let timerInterval = null;
        let elapsedTime = 0;

        const rayCanvas = document.getElementById('ray-canvas');
        const rayCtx = rayCanvas.getContext('2d');
        let animationFrameId;
        let activeEffects = [];
        let comboCounter = 0;

        const gridEl = document.getElementById('grid');
        const hudMines = document.getElementById('mines-left');
        const hudStatus = document.getElementById('status-text');
        const guideText = document.getElementById('guide-text');

        let startCell = null;
        let isDragging = false;
        let dragLine = { x: 0, y: 0 };

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btn-mode-detonate').classList.toggle('active', mode === 'detonate');
            document.getElementById('btn-mode-mark').classList.toggle('active', mode === 'mark');

            if (mode === 'detonate') {
                guideText.textContent = "左键或手指朝八个方向拖动引爆 / 电脑端右键标记安全区";
                guideText.style.color = "#888";
            } else {
                guideText.textContent = "点击未知区域 > 标记或取消安全区";
                guideText.style.color = "var(--neon-green)";
            }

            playSound('hover');
        }

        function playSound(type) {
            if (AUDIO_CTX.state === 'suspended') AUDIO_CTX.resume();
            const osc = AUDIO_CTX.createOscillator();
            const gainNode = AUDIO_CTX.createGain();
            osc.connect(gainNode);
            gainNode.connect(AUDIO_CTX.destination);

            const t = AUDIO_CTX.currentTime;

            if (type === 'hover') {
                osc.frequency.setValueAtTime(800, t);
                gainNode.gain.setValueAtTime(0.01, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.05);
            } else if (type === 'mark') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, t);
                gainNode.gain.setValueAtTime(0.05, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
            } else if (type === 'ray') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                gainNode.gain.setValueAtTime(0.15, t);
                gainNode.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t);
                osc.stop(t + 0.2);
            } else if (type === 'explode') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t);
                osc.stop(t + 0.4);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.start(t);
                osc.stop(t + 0.5);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.04 + 0.02;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.gravity = 0.2;
            }

            update(dt) {
                const f = dt * 60;

                this.x += this.vx * f;
                this.y += this.vy * f;
                this.vy += this.gravity * f;

                this.life -= this.decay * f;
                this.size *= Math.pow(0.95, f);
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class FloatingText {
            constructor(x, y, count) {
                const cs = CONFIG.cellSize;
                this.baseX = (x + 0.5) * cs;
                this.baseY = (y + 0.5) * cs;

                // —— 2~10 每个都不同：文字、色相、描边、抖动、旋转、光晕强度 ——
                const PRESET = {
                    2: { text: 'DOUBLE', color: '#00f3ff', glow: 18, stroke: 7, size: 34, jitter: 0.8, rot: -0.10 },
                    3: { text: 'TRIPLE', color: '#00ff66', glow: 20, stroke: 7, size: 36, jitter: 1.0, rot: 0.10 },
                    4: { text: 'QUAD', color: '#bc13fe', glow: 22, stroke: 8, size: 40, jitter: 1.2, rot: -0.08 },
                    5: { text: 'PENTA', color: '#fcee0a', glow: 26, stroke: 9, size: 44, jitter: 1.5, rot: 0.06 },
                    6: { text: 'HEX', color: '#ff7a00', glow: 28, stroke: 10, size: 48, jitter: 1.8, rot: -0.05 },
                    7: { text: 'SEPT', color: '#ff003c', glow: 30, stroke: 11, size: 52, jitter: 2.2, rot: 0.04 },
                    8: { text: 'OCTA', color: '#ffffff', glow: 34, stroke: 12, size: 58, jitter: 2.6, rot: -0.03 },
                    9: { text: 'NOVA', color: '#00ffff', glow: 38, stroke: 12, size: 64, jitter: 3.0, rot: 0.02 },
                    10: { text: 'DECA+', color: '#ff00ff', glow: 44, stroke: 14, size: 72, jitter: 3.4, rot: 0.00 },
                };

                this.count = count;
                this.p = PRESET[count] || PRESET[10];

                // 让文字更“有力”：初速度更集中（上冲 + 轻微左右散射）
                this.vx = (Math.random() - 0.5) * 2.2;
                this.vy = -5.2 - Math.random() * 1.4;
                this.gravity = 0.16;

                // 用“时间进度”驱动动画（更稳定）
                this.t = 0;          // 0 -> 1
                this.duration = 0.75; // 秒
                this.life = 1.0;     // 兼容你现有的销毁逻辑

                // 旋转 & 抖动
                this.rot = this.p.rot + (Math.random() - 0.5) * 0.06;
                this.rotVel = (Math.random() - 0.5) * 0.012;

                // 每个连击级别不同的“屏幕叠加感”
                this.additive = count >= 7;

                // 初始位置
                this.x = this.baseX;
                this.y = this.baseY;

                // 小技巧：高连击更“弹”
                this.pop = 1.15 + (count - 2) * 0.03;
            }

            // easing：弹性进入 + 平滑消失
            easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }
            easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

            update(dt) {
                // 时间推进（0 → 1）
                this.t += dt / this.duration;
                if (this.t > 1) this.t = 1;

                // 位移（像素/秒）
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;

                // 重力（像素/秒²）
                this.vy += this.gravity * dt * 60;

                // 空气阻力（指数衰减）
                const drag = Math.pow(0.96, dt * 60);
                this.vx *= drag;

                // 旋转
                this.rot += this.rotVel * dt * 60;

                // 透明度
                if (this.t < 0.55) {
                    this.life = 1;
                } else {
                    this.life = Math.max(0, 1 - (this.t - 0.55) / 0.45);
                }

                // 抖动强度
                const jStrength = (1 - this.easeOutCubic(Math.min(this.t / 0.3, 1))) * this.p.jitter;
                this.jx = (Math.random() - 0.5) * jStrength * 2;
                this.jy = (Math.random() - 0.5) * jStrength * 2;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                // scale：前段弹出、后段微缩
                const popT = Math.min(this.t / 0.25, 1);
                const popScale = this.easeOutBack(popT) * this.pop;
                const settle = this.t > 0.35 ? (1 - (this.t - 0.35) * 0.12) : 1;
                const scale = popScale * settle;

                ctx.save();

                if (this.additive) ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.life;

                ctx.translate(this.x + this.jx, this.y + this.jy);
                ctx.rotate(this.rot);
                ctx.scale(scale, scale);

                // 字体：更“游戏击杀提示”的感觉
                ctx.font = `italic 900 ${this.p.size}px "Arial Black", "Impact", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // 1) 黑色厚描边（清晰度）
                ctx.lineJoin = 'round';
                ctx.strokeStyle = 'rgba(0,0,0,0.95)';
                ctx.lineWidth = this.p.stroke;
                ctx.strokeText(this.p.text, 0, 0);

                // 2) 彩色外辉光（霓虹感）
                ctx.shadowBlur = this.p.glow;
                ctx.shadowColor = this.p.color;
                ctx.fillStyle = this.p.color;
                ctx.fillText(this.p.text, 0, 0);

                // 3) 白色高光（立体）
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(this.p.text, -2, -2);

                // 4) 超高连击：加一道“切割高光线”（更像爆发）
                if (this.count >= 8) {
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-this.p.size * 1.2, -this.p.size * 0.2);
                    ctx.lineTo(this.p.size * 1.2, -this.p.size * 0.55);
                    ctx.stroke();
                }

                ctx.restore();
                ctx.globalCompositeOperation = 'source-over';
            }
        }


        class Shockwave {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = CONFIG.cellSize * 1.5;
                this.color = color;
                this.life = 1.0;
                this.decay = 0.08;
            }

            update(dt) {
                const f = dt * 60;
                this.radius += 3 * f;
                this.life -= this.decay * f;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class RayEffect {
            constructor(startX, startY, dirX, dirY, lengthCells, isFailure = false) {
                const cs = CONFIG.cellSize;
                this.sx = (startX + 0.5) * cs;
                this.sy = (startY + 0.5) * cs;
                this.ex = this.sx + (dirX * lengthCells * cs);
                this.ey = this.sy + (dirY * lengthCells * cs);
                this.life = 1.0;

                this.isFailure = isFailure;

                // 生成一个基于位置的随机偏移量，用于脉冲动画，
                // 确保每条射线的脉冲步调不一致。
                this.pulseOffset = (this.sx + this.sy) * 0.1 + Math.random() * 10;

                if (this.isFailure) {
                    // === 失败射线参数 ===
                    this.width = 2;       // 依然保持极细
                    // 这里不再定义单一 color，而是在 draw 里定义血色层次
                    this.maxJitter = 0;   //稍微增加一点抖动，配合脉冲
                } else {
                    // === 普通射线参数 ===
                    this.width = 15;
                    this.color = CONFIG.colors.blue;
                    this.maxJitter = 10;
                }

                this.jitter = 0;
            }

            update(dt) {
                const f = dt * 60;

                this.life -= (this.isFailure ? 0.03 : 0.08) * f;

                if (!this.isFailure) {
                    this.width *= Math.pow(0.9, f);
                }

                this.jitter = (Math.random() - 0.5) * this.maxJitter;
            }

            draw(ctx) {
                // 失败模式依然使用 lighter，让交叉点极其明亮
                ctx.globalCompositeOperation = this.isFailure ? 'lighter' : 'screen';
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(this.sx, this.sy);
                ctx.lineTo(this.ex + this.jitter, this.ey + this.jitter);

                if (this.isFailure) {
                    // === 修改点：血色脉冲激光风格 ===

                    // 计算脉冲因子：利用当前时间 + 自身偏移量计算正弦波
                    // 速度较快 ( * 0.02 )
                    const time = performance.now();
                    const pulseWave = Math.sin(time * 0.02 + this.pulseOffset);
                    // 将正弦波(-1到1)映射到一个亮度波动范围，例如 0.6 到 1.0 之间
                    const pulseFactor = (pulseWave * 0.2) + 0.8;

                    // 层1: 深血色外晕 (提供深邃的背景，不脉冲，稳定存在)
                    ctx.lineWidth = 5; // 稍微宽一点点作为底色
                    ctx.strokeStyle = '#660000'; // 深沉的干涸血色
                    ctx.globalAlpha = this.life * 0.5; // 半透明
                    ctx.stroke();

                    // 层2: 鲜血核心 (极细，高饱和，带有脉冲效果)
                    ctx.lineWidth = 1.5; // 极细核心
                    // 使用鲜艳的动脉血红，而不是之前的粉白
                    ctx.strokeStyle = '#ff0000';
                    // Alpha 由生命值和脉冲因子共同决定
                    ctx.globalAlpha = this.life * pulseFactor * 0.9;
                    ctx.stroke();

                } else {
                    // === 普通蓝色扫描线 (保持原样) ===
                    ctx.lineWidth = this.width * 3;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.2;
                    ctx.stroke();

                    ctx.lineWidth = this.width;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.stroke();

                    ctx.lineWidth = this.width * 0.3;
                    ctx.strokeStyle = '#ffffff';
                    ctx.globalAlpha = this.life;
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = 'source-over';
            }
        }
        function startRenderLoop() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            let lastTime = performance.now();

            function loop(now) {
                const deltaTime = Math.min((now - lastTime) / 1000, 0.05);
                lastTime = now;

                // 1. 获取网格当前在屏幕上的实际位置
                // 这解决了不同屏幕布局、横竖屏切换后位置不对的问题
                const rect = gridEl.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // 2. 清空全屏画布
                // 注意：因为 resizeCanvasToDisplaySize 会改变 canvas.width/height，
                // 我们需要用 canvas 的实际物理像素尺寸来清空
                rayCtx.setTransform(1, 0, 0, 1, 0, 0); // 重置矩阵以确保清空全屏
                rayCtx.clearRect(0, 0, rayCanvas.width, rayCanvas.height);

                // 3. 设置绘制矩阵：
                // 缩放 (dpr) + 平移 (rect.left, rect.top)
                // 还要加上 padding (4px) 的偏移，因为 grid-wrapper 有 padding
                // 如果你的 rect 是取自 #grid 元素本身，就不需要加 padding，直接用 rect.left
                rayCtx.setTransform(dpr, 0, 0, dpr, rect.left * dpr, rect.top * dpr);

                // --- 下面的绘制逻辑完全不用动 ---
                for (let i = activeEffects.length - 1; i >= 0; i--) {
                    const effect = activeEffects[i];
                    effect.update(deltaTime);
                    effect.draw(rayCtx);
                    if (effect.life <= 0) {
                        activeEffects.splice(i, 1);
                    }
                }

                animationFrameId = requestAnimationFrame(loop);
            }

            animationFrameId = requestAnimationFrame(loop);
        }

        //const MAX_PARTICLES = 150;
        function spawnExplosion(cx, cy, color = CONFIG.colors.red) {
            //if (activeEffects.length > MAX_PARTICLES) {
            //    return;
            // }

            const particleCount = 20;
            const pixelX = (cx + 0.5) * CONFIG.cellSize;
            const pixelY = (cy + 0.5) * CONFIG.cellSize;
            for (let i = 0; i < particleCount; i++) {
                activeEffects.push(new Particle(pixelX, pixelY, color));
            }
            activeEffects.push(new Shockwave(pixelX, pixelY, color));
        }

        // 修改：增加了 length 参数，默认为 null
        function spawnRay(x, y, dx, dy, length = null, isFailure = false) {
            activeEffects.push(new RayEffect(x, y, dx, dy, Math.max(CONFIG.rayLength, length), isFailure));
        }

        function explodeNeighbors(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                        const neighbor = gridData[ny][nx];
                        if (!neighbor.isRevealed) {
                            neighbor.reveal();
                        }
                    }
                }
            }
        }

        function floodFill(x, y) {
            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            for (let dir of dirs) {
                const nx = x + dir.x;
                const ny = y + dir.y;

                if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                    const neighbor = gridData[ny][nx];
                    if (!neighbor.isRevealed && !neighbor.isMine && neighbor.neighborCount === 0) {
                        neighbor.reveal();
                    }
                }
            }
        }

        function animatedFloodFill(startX, startY) {
            // 1. 定义 BFS 结构
            const queue = [{ x: startX, y: startY, dist: 0 }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            // 这个数组用来存 { cell, dist }，用于稍后生成动画
            const animationQueue = [];

            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
            ];

            // 2. === 阶段一：同步逻辑处理（瞬间完成） ===
            // 在这个循环里，我们只修改数据状态 (isRevealed)，不操作 DOM
            let head = 0;
            while (head < queue.length) {
                const { x, y, dist } = queue[head++];
                const currentCell = gridData[y][x];

                // 如果不是起点（起点在 cell.reveal 里已经处理了），记录下来做动画
                if (dist > 0) {
                    animationQueue.push({ cell: currentCell, dist: dist });
                }

                // 如果当前格子是空地 (0)，则继续扩散
                // 注意：这里我们不需要判断 neighborCount === 0，
                // 因为只有 0 才能进队列继续搜寻邻居（边界数字不扩散）
                if (currentCell.neighborCount === 0) {
                    for (let dir of dirs) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        const key = `${nx},${ny}`;

                        // 越界检查
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (!visited.has(key)) {
                                const neighbor = gridData[ny][nx];

                                // 关键：只要没揭开，就立即在逻辑上揭开
                                if (!neighbor.isRevealed) {
                                    // --- 状态锁定 ---
                                    neighbor.isRevealed = true; // 锁死状态，防止再次点击
                                    neighbor.isMarked = false;  // 逻辑上去除标记

                                    visited.add(key);

                                    // 只有 0 继续入队扩散，数字只揭开不扩散
                                    if (neighbor.neighborCount === 0) {
                                        queue.push({ x: nx, y: ny, dist: dist + 1 });
                                    } else {
                                        // 这是一个边界数字，记录动画，但不再入队
                                        animationQueue.push({ cell: neighbor, dist: dist + 1 });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 3. === 阶段二：异步视觉动画 ===
            // 此时所有相关格子的 isRevealed 已经是 true 了，玩家点不动了
            // 我们只需要安安静静地把样式刷上去

            if (animationQueue.length === 0) return;

            if (isGameOver) {
                animationQueue.forEach(item => {
                    item.cell.updateVisuals();
                });
                // 失败时不需要播放扩散音效，也不需要更新HUD（反正都要输了）
                return;
            }

            // 先找到最大层级 (最远的那个格子离起点的距离)
            let maxDist = 0;
            animationQueue.forEach(item => { if (item.dist > maxDist) maxDist = item.dist; });

            // === 核心修改：动态时间步长 ===
            let stepDelay = 30;           // 默认的基础速度 (ms/步)
            const maxTotalDuration = 500; // 最大总耗时限制 (ms)

            // 计算：如果按默认速度跑完会超过 500ms
            if (maxDist * stepDelay > maxTotalDuration) {
                // 强制压缩：用总时间除以总步数
                stepDelay = maxTotalDuration / maxDist;
            }

            for (let d = 1; d <= maxDist; d++) {
                setTimeout(() => {
                    if (isGameOver) return;

                    animationQueue.forEach(item => {
                        if (item.dist === d) {
                            // 调用我们刚才写的纯视觉更新函数
                            item.cell.updateVisuals();
                        }
                    });
                }, d * stepDelay);
            }

            updateHUD();
        }

        function revealRayPath(startX, startY, dirX, dirY) {
            for (let i = 1; i <= CONFIG.rayLength; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);
                if (tx < 0 || tx >= CONFIG.gridW || ty < 0 || ty >= CONFIG.gridH) break;

                const targetCell = gridData[ty][tx];
                if (!targetCell.isMine && !targetCell.isRevealed) {
                    targetCell.reveal();
                }
            }
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.isMine = false;
                this.isRevealed = false;
                this.isMarked = false;
                this.neighborCount = 0;
                this.element = document.createElement('div');
                this.element.className = 'cell';
                this.element.dataset.x = x;
                this.element.dataset.y = y;
            }

            toggleMark() {
                if (this.isRevealed) return;
                this.isMarked = !this.isMarked;
                this.element.classList.toggle('marked', this.isMarked);
                playSound('mark');
            }

            reveal() {
                if (this.isRevealed) return;

                this.isRevealed = true;
                this.isMarked = false;

                this.updateVisuals();

                if (this.isMine) {
                    this.element.classList.add('mine');
                    this.element.textContent = '☢';
                    this.element.dataset.num = 'mine';

                    this.element.classList.add('mine-flash');
                    setTimeout(() => this.element.classList.remove('mine-flash'), 150);

                    revealedMines++;
                    playSound('explode');
                    spawnExplosion(this.x, this.y, CONFIG.colors.red);

                    const container = document.getElementById('game-container');
                    container.classList.remove('shake');
                    void container.offsetWidth;
                    container.classList.add('shake');

                } else {
                    if (this.neighborCount === 0) {
                        animatedFloodFill(this.x, this.y);
                    } else {
                        spawnExplosion(this.x, this.y, 'rgba(0, 243, 255, 0.4)');
                    }
                }
                updateHUD();
            }

            updateVisuals() {
                // 移除标记样式
                this.element.classList.remove('marked');
                // 添加揭示样式
                this.element.classList.add('revealed');

                if (!this.isMine) {
                    // 显示数字
                    this.element.textContent = this.neighborCount === 0 ? '' : this.neighborCount;
                    this.element.dataset.num = this.neighborCount;
                }
            }
        }

        function startTimer() {
            if (timerInterval) return;
            gameStartTime = Date.now();
            const display = document.getElementById('timer-display');

            timerInterval = setInterval(() => {
                const now = Date.now();
                elapsedTime = Math.floor((now - gameStartTime) / 1000);
                display.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function resizeCanvasToDisplaySize(canvas, cssWidth, cssHeight) {
            const dpr = window.devicePixelRatio || 1;

            // 1) 设定 CSS 尺寸（页面上看到的尺寸）
            canvas.style.width = cssWidth + 'px';
            canvas.style.height = cssHeight + 'px';

            // 2) 设定实际像素尺寸（乘 DPR，保证清晰）
            const displayWidth = Math.round(cssWidth * dpr);
            const displayHeight = Math.round(cssHeight * dpr);

            // 避免重复 set 造成抖动/重置状态
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            return dpr;
        }

        function initGame() {
            // 清理可能的旧延时操作
            if (window.failTimeout) clearTimeout(window.failTimeout);
            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);
            window.failIntervals = window.failIntervals || [];
            window.failIntervals.forEach(id => clearTimeout(id));
            window.failIntervals = [];

            stopTimer();
            elapsedTime = 0;
            document.getElementById('timer-display').textContent = "00:00";

            gridEl.innerHTML = '';
            gridData = [];
            revealedMines = 0;
            isFirstMove = true;
            isGameOver = false;
            activeEffects = [];
            hudStatus.textContent = "待命";
            hudStatus.style.color = "var(--neon-green)";
            setMode('detonate');

            // 智能计算布局
            const isLandscape = window.innerWidth > window.innerHeight;
            const margin = 10;
            const hudHeight = 70;
            const guideHeight = 40;

            // 根据方向判断工具栏占用的空间
            const toolbarW = isLandscape ? 70 : 0;
            const toolbarH = isLandscape ? 0 : 80;

            const availableWidth = window.innerWidth - margin - toolbarW;
            const availableHeight = window.innerHeight - hudHeight - guideHeight - margin - toolbarH;

            const sizeW = Math.floor(availableWidth / CONFIG.gridW);
            const sizeH = Math.floor(availableHeight / CONFIG.gridH);

            let size = Math.min(sizeW, sizeH, 50);
            size = Math.max(size, 20);

            CONFIG.cellSize = size;

            const totalWidth = size * CONFIG.gridW;
            const totalHeight = size * CONFIG.gridH;

            gridEl.style.gridTemplateColumns = `repeat(${CONFIG.gridW}, ${size}px)`;
            gridEl.style.gridTemplateRows = `repeat(${CONFIG.gridH}, ${size}px)`;

            const dpr = resizeCanvasToDisplaySize(rayCanvas, window.innerWidth, window.innerHeight);

            // 关键：把坐标系缩回“CSS 像素”，这样你后面用的 cellSize/像素计算都不用改
            rayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

            for (let y = 0; y < CONFIG.gridH; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.gridW; x++) {
                    const cell = new Cell(x, y);
                    gridEl.appendChild(cell.element);
                    row.push(cell);
                }
                gridData.push(row);
            }

            totalMines = Math.floor(CONFIG.gridW * CONFIG.gridH * CONFIG.density);
            updateHUD();
            startRenderLoop();
        }

        function generateMines(startX, startY, dirX, dirY) {
            // 先确保起点是雷
            gridData[startY][startX].isMine = true;
            let placed = 1;

            // 此时我们不干预分布，纯粹随机
            while (placed < totalMines) {
                const rx = Math.floor(Math.random() * CONFIG.gridW);
                const ry = Math.floor(Math.random() * CONFIG.gridH);

                if (!gridData[ry][rx].isMine) {
                    gridData[ry][rx].isMine = true;
                    placed++;
                }
            }

            // 收集该方向上距离 2 到 5 的合法格子
            const candidates = [];
            let hasMineInPath = false;

            // 距离0是起点，距离1是九宫格边缘（会被直接炸开），
            // 射线穿透4个未揭示格，所以覆盖的是距离 2, 3, 4, 5
            for (let i = 2; i <= 5; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);

                // 越界检查
                if (tx >= 0 && tx < CONFIG.gridW && ty >= 0 && ty < CONFIG.gridH) {
                    const cell = gridData[ty][tx];
                    candidates.push(cell);
                    if (cell.isMine) {
                        hasMineInPath = true; // 运气不错，自然生成了
                    }
                }
            }

            if (!hasMineInPath && candidates.length > 0) {

                // A. 从路径候选格中选一个幸运儿变成雷
                const luckyCell = candidates[Math.floor(Math.random() * candidates.length)];
                luckyCell.isMine = true;

                // B. 为了保持总雷数不变，必须擦除掉地图上另一个现有的雷
                //    这个雷不能是起点，也不能是我们刚才选中的幸运儿
                let removed = false;
                while (!removed) {
                    const rx = Math.floor(Math.random() * CONFIG.gridW);
                    const ry = Math.floor(Math.random() * CONFIG.gridH);
                    const target = gridData[ry][rx];

                    // 必须是雷，且不是起点，且不是刚才新设的那个位置
                    if (target.isMine &&
                        !(rx === startX && ry === startY) &&
                        !(rx === luckyCell.x && ry === luckyCell.y)) {

                        target.isMine = false; // 移除这颗雷
                        removed = true;
                    }
                }
            }

            // 统一计算数字
            calculateNumbers();
        }

        function calculateNumbers() {
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
            ];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    let count = 0;
                    for (let dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (gridData[ny][nx].isMine) count++;
                        }
                    }
                    gridData[y][x].neighborCount = count;
                }
            }
        }

        function calculateRayPath(startX, startY, dirX, dirY) {
            let currentX = startX;
            let currentY = startY;
            let distance = 0;
            let unrevealedHitCount = 0;
            const path = []; // 存储路径上经过的格子

            while (true) {
                //以此前进一格
                currentX += dirX;
                currentY += dirY;
                distance++;

                // 1. 撞墙检测（屏幕边缘）
                if (currentX < 0 || currentX >= CONFIG.gridW ||
                    currentY < 0 || currentY >= CONFIG.gridH) {
                    break;
                }

                const cell = gridData[currentY][currentX];
                path.push(cell);

                // 2. 穿透检测
                // 如果格子未揭开（无论是雷还是安全），消耗一点穿透力
                if (!cell.isRevealed) {
                    unrevealedHitCount++;
                }

                // 3. 耗尽停止
                // 如果已经穿透了指定数量的未揭开格子，就停止
                if (unrevealedHitCount >= CONFIG.penetrationLimit) {
                    break;
                }
            }

            return { distance, path };
        }

        function fireRay(startX, startY, dirX, dirY, delay = 0) {
            setTimeout(() => {
                if (isGameOver) return;

                // 1. 先计算路径（逻辑核心）
                const { distance, path } = calculateRayPath(startX, startY, dirX, dirY);

                playSound('ray');

                // 2. 视觉生成：传入计算出的实际距离 (distance)
                // 这样射线就能在墙边或者第4个格子处精准停下
                spawnRay(startX, startY, dirX, dirY, distance);

                // 3. 游戏逻辑：遍历路径上的格子
                for (const targetCell of path) {

                    if (targetCell.isMine) {
                        if (!targetCell.isRevealed) {
                            targetCell.reveal(); // 揭示雷
                            explodeNeighbors(targetCell.x, targetCell.y); // 炸开周围
                            fireRay(targetCell.x, targetCell.y, dirX, dirY, 120);

                            comboCounter++;
                            const showCount = Math.min(comboCounter, 10);

                            if (showCount >= 2) {
                                activeEffects.push(new FloatingText(targetCell.x, targetCell.y, showCount));
                            }

                            hitMine = true;
                        }
                    } else {
                        targetCell.reveal();
                    }
                }
                checkWinCondition();
            }, delay);
        }


        let isPaused = false;
        let pausedTimerWasRunning = false;

        function openTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.remove('hidden');

            // 暂停输入
            isPaused = true;

            // 暂停计时（如果正在计时）
            pausedTimerWasRunning = !!timerInterval;
            stopTimer();

            playSound('hover');
        }

        function closeTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.add('hidden');

            // 恢复输入
            isPaused = false;

            // 恢复计时（仅当游戏未结束、且之前在计时）
            if (!isGameOver && !isFirstMove && pausedTimerWasRunning) {
                startTimer(); // startTimer 下面会做“按 elapsedTime 续计”
            }

            pausedTimerWasRunning = false;
            playSound('hover');
        }

        function startTimer() {
            if (timerInterval) return;

            // ✅ 关键：支持暂停恢复
            gameStartTime = Date.now() - (elapsedTime * 1000);

            const display = document.getElementById('timer-display');
            timerInterval = setInterval(() => {
                const now = Date.now();
                elapsedTime = Math.floor((now - gameStartTime) / 1000);
                display.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        document.getElementById('btn-tutorial').addEventListener('click', () => {
            openTutorial();
        });

        document.getElementById('btn-ingame-tutorial').addEventListener('click', () => {
            openTutorial();
        });

        document.getElementById('btn-tutorial-back').addEventListener('click', () => {
            closeTutorial();
        });

        document.getElementById('tutorial-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'tutorial-overlay') closeTutorial();
        });

        function setupInput() {
            // 1. 禁止网格区域的浏览器默认右键菜单
            gridEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });

            const getCellCoords = (e) => {
                const rect = gridEl.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const x = Math.floor((clientX - rect.left) / CONFIG.cellSize);
                const y = Math.floor((clientY - rect.top) / CONFIG.cellSize);
                return { x, y, clientX, clientY };
            };

            const startDrag = (e) => {
                if (isGameOver || isPaused) return;

                // 只有触摸事件才需要 preventDefault 防止滚动，鼠标左键不需要，
                // 但为了处理右键不弹出菜单，上面已经加了 contextmenu 的监听
                if (e.type === 'touchstart') e.preventDefault();

                const coords = getCellCoords(e);

                // 判断是否为右键点击 (鼠标右键 button 值为 2)
                const isRightClick = e.button === 2;

                if (coords.x >= 0 && coords.x < CONFIG.gridW && coords.y >= 0 && coords.y < CONFIG.gridH) {
                    const cell = gridData[coords.y][coords.x];

                    if (cell.isRevealed) return;

                    // === 修改后的逻辑核心 ===
                    // 满足以下任一条件则执行【标记】操作：
                    // 1. 用户点击了鼠标右键
                    // 2. 当前本来就是“标记模式” (currentMode === 'mark')
                    if (isRightClick || currentMode === 'mark') {
                        cell.toggleMark();
                        return; // 标记是瞬间动作，不需要后续的拖拽逻辑
                    }

                    // === 下面是引爆模式的左键拖拽逻辑 ===
                    if (currentMode === 'detonate' && cell.isMarked) {
                        return; // 引爆模式下，不能拖动已标记的格子
                    }

                    startCell = { x: coords.x, y: coords.y };
                    cell.element.classList.add('active');
                    isDragging = true;
                    dragLine = { x: coords.clientX, y: coords.clientY };
                    playSound('hover');
                }
            };

            const moveDrag = (e) => {
                // 如果是标记模式，或者刚才触发的是右键标记，则不处理拖动
                if (!isDragging || currentMode === 'mark') return;
                e.preventDefault();
            };

            const endDrag = (e) => {
                if (currentMode === 'mark') return;
                if (!isDragging) return;

                const coords = e.changedTouches ?
                    { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY } :
                    { clientX: e.clientX, clientY: e.clientY };

                const dx = coords.clientX - dragLine.x;
                const dy = coords.clientY - dragLine.y;

                if (startCell && gridData[startCell.y] && gridData[startCell.y][startCell.x]) {
                    gridData[startCell.y][startCell.x].element.classList.remove('active');
                }

                if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
                    const angle = Math.atan2(dy, dx);
                    const degree = angle * (180 / Math.PI);
                    const octant = Math.round(degree / 45);

                    const dirs = [
                        { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 },
                        { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }
                    ];

                    let dirIndex = octant;
                    if (dirIndex < 0) dirIndex += 8;
                    dirIndex = dirIndex % 8;

                    const dir = dirs[dirIndex];
                    handleAction(startCell.x, startCell.y, dir.x, dir.y);
                }

                isDragging = false;
                startCell = null;
            };

            gridEl.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', moveDrag);
            window.addEventListener('mouseup', endDrag);

            gridEl.addEventListener('touchstart', startDrag, { passive: false });
            window.addEventListener('touchmove', moveDrag, { passive: false });
            window.addEventListener('touchend', endDrag);
        }

        function handleAction(x, y, dirX, dirY) {
            const cell = gridData[y][x];
            if (cell.isRevealed || cell.isMarked) return;

            comboCounter = 1;

            if (isFirstMove) {
                generateMines(x, y, dirX, dirY);
                isFirstMove = false;
                hudStatus.textContent = "链接建立";
                startTimer();
            }

            if (cell.isMine) {
                cell.reveal();
                // 现在采取的是邻居优先不链式反应的规则，可以解释为周围被炸坏了
                explodeNeighbors(x, y);
                fireRay(x, y, dirX, dirY);
            } else {
                cell.element.style.backgroundColor = "var(--neon-red)";
                spawnExplosion(x, y, CONFIG.colors.red);
                gameOver(false);
            }
        }

        let endDuration = 0.0;

        function triggerChainFailure() {
            hudStatus.textContent = "系统崩溃";
            hudStatus.style.color = "var(--neon-red)";
            playSound('error');

            const hiddenMines = [];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    if (gridData[y][x].isMine && !gridData[y][x].isRevealed) {
                        hiddenMines.push(gridData[y][x]);
                    }
                }
            }

            hiddenMines.sort(() => Math.random() - 0.5);

            // 动态间隔计算
            let interval = 300;
            if (hiddenMines.length > 10) {
                // 如果雷多于10个，确保在3000ms内炸完
                interval = 3000 / hiddenMines.length;
            }

            // 清理旧的定时器数组
            window.failIntervals = [];
            endDuration = interval * hiddenMines.length;

            hiddenMines.forEach((cell, index) => {
                const id = setTimeout(() => {
                    cell.element.classList.add('mine');
                    cell.element.textContent = '☢';
                    cell.element.classList.add('mine-flash');
                    setTimeout(() => cell.element.classList.remove('mine-flash'), 150);

                    playSound('explode');
                    spawnExplosion(cell.x, cell.y, CONFIG.colors.red);

                    const dirs = [
                        { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 },
                        { x: 0, y: 1 }, { x: -1, y: 1 }, { x: -1, y: 0 }, { x: -1, y: -1 }
                    ];
                    dirs.forEach(d => {
                        const { distance, path } = calculateRayPath(cell.x, cell.y, d.x, d.y);
                        spawnRay(cell.x, cell.y, d.x, d.y, distance, true);
                        revealRayPath(cell.x, cell.y, d.x, d.y);
                    });

                }, index * interval);
                window.failIntervals.push(id);
            });
        }

        function checkWinCondition() {
            if (revealedMines >= totalMines) {
                gameOver(true);
            }
        }

        function gameOver(win, reason) {
            if (isGameOver) return;

            stopTimer();

            isGameOver = true;
            if (!win) {
                triggerChainFailure();
                // 注意：失败时我们稍后弹出界面，但数据现在就要准备好
            } else {
                // 胜利直接处理
                hudStatus.textContent = "胜利";
                hudStatus.style.color = "var(--neon-green)";
                playSound('hover');
            }

            // 准备界面数据
            const card = document.querySelector('.result-card');
            const title = document.getElementById('end-title');
            const timeDisplay = document.getElementById('end-time');
            const diffDisplay = document.getElementById('end-difficulty');
            const pctDisplay = document.getElementById('end-percentage');
            const reasonText = document.getElementById('end-reason');
            const overlay = document.getElementById('game-over-overlay');

            // 设置基本数据
            timeDisplay.textContent = formatTime(elapsedTime);
            diffDisplay.textContent = `${CONFIG.gridW}x${CONFIG.gridH} (${Math.round(CONFIG.density * 100)}%)`;

            // 移除旧主题
            card.classList.remove('win-theme', 'lose-theme');

            // 延迟显示逻辑 (为了配合爆炸动画)
            const showDelay = win ? 1500 : (endDuration + 1500);

            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            window.gameResultTimeout = setTimeout(() => {
                if (win) {
                    title.textContent = "SYSTEM PURGED";
                    title.className = "win"; // 保持文字颜色逻辑
                    card.classList.add('win-theme');
                    pctDisplay.textContent = "100%";
                    reasonText.textContent = "所有威胁已消除，系统恢复正常。";
                } else {
                    title.textContent = "CONNECTION LOST";
                    title.className = "lose";
                    card.classList.add('lose-theme');
                    // 计算完成度
                    const pct = Math.floor((revealedMines / totalMines) * 100);
                    pctDisplay.textContent = `${pct}% THREATS NEUTRALIZED`;
                    reasonText.textContent = "逻辑链路崩溃，协议执行失败。";
                }
                overlay.classList.remove('hidden');
            }, showDelay);
        }

        function updateHUD() {
            hudMines.textContent = `${totalMines - revealedMines}`;
        }

        const menuOverlay = document.getElementById('menu-overlay');
        const inpW = document.getElementById('inp-w');
        const inpH = document.getElementById('inp-h');
        const inpD = document.getElementById('inp-d');

        [inpW, inpH, inpD].forEach(el => {
            el.addEventListener('input', () => {
                document.getElementById(`val-${el.id.split('-')[1]}`).textContent =
                    el.id === 'inp-d' ? el.value + '%' : el.value;
            });
        });

        document.getElementById('btn-start').addEventListener('click', () => {
            // 获取当前滑块的值
            const w = parseInt(inpW.value);
            const h = parseInt(inpH.value);
            const d = parseInt(inpD.value);

            // 1. 更新全局配置
            CONFIG.gridW = w;
            CONFIG.gridH = h;
            CONFIG.density = d / 100;

            // 2. 步到 URL ===
            updateURLSettings(w, h, d);

            // 3. 开始游戏
            menuOverlay.classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-restart').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-menu').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            clearURLSettings();
            menuOverlay.classList.remove('hidden');
        });

        // 游戏内菜单按钮事件
        document.getElementById('btn-ingame-restart').addEventListener('click', () => {
            initGame();
        });

        // === 修改后的菜单按钮逻辑 ===
        document.getElementById('btn-ingame-menu').addEventListener('click', () => {
            // 1. 立即停止计时器 (核心修复：防止背景时间继续走)
            stopTimer();

            // 2. 标记游戏结束，阻断后续交互
            isGameOver = true;

            // 3. 清理所有可能的失败动画/延时
            if (window.failIntervals) {
                window.failIntervals.forEach(id => clearTimeout(id));
                window.failIntervals = [];
            }
            if (window.failTimeout) clearTimeout(window.failTimeout);
            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            // 4. 更新 HUD 状态
            hudStatus.textContent = "已挂起";
            hudStatus.style.color = "#888";

            clearURLSettings();

            // 5. 确保结算弹窗关闭，并显示主菜单
            document.getElementById('game-over-overlay').classList.add('hidden');
            menuOverlay.classList.remove('hidden');
        });

        // 监听窗口大小变化以重新计算布局（可选，简单起见直接重置可能更好，或者动态调整 grid-wrapper）
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // 只有在非游戏进行中或者你想支持动态调整时才调用
                // 这里为了体验流畅，建议用户手动重开，或者只重新计算 grid 尺寸而不清空数据
                // 简单处理：重新初始化
                if (!isGameOver && revealedMines === 0) {
                    initGame();
                }
            }, 500);
        });

        setupInput();

        function loadSettingsFromURL() {
            const params = new URLSearchParams(window.location.search);

            // 检查参数是否存在：只有当宽、高、密度三个参数都有时，才视为有效配置
            const hasParams = params.has('w') && params.has('h') && params.has('d');

            // 辅助验证函数
            const getSafeVal = (key, min, max, defaultVal) => {
                if (!params.has(key)) return defaultVal;
                const val = parseInt(params.get(key));
                if (isNaN(val)) return defaultVal;
                return Math.max(min, Math.min(max, val));
            };

            // 读取并更新滑块 (即使参数不全，能读多少读多少)
            const w = getSafeVal('w', 8, 32, 10);
            const h = getSafeVal('h', 8, 32, 15);
            const d = getSafeVal('d', 25, 75, 30);

            inpW.value = w;
            inpH.value = h;
            inpD.value = d;

            document.getElementById('val-w').textContent = w;
            document.getElementById('val-h').textContent = h;
            document.getElementById('val-d').textContent = d + '%';

            // 无论是否自动开始，都先把 CONFIG 更新好
            CONFIG.gridW = w;
            CONFIG.gridH = h;
            CONFIG.density = d / 100;

            if (hasParams) {
                updateURLSettings(w, h, d);
            }

            return hasParams; // 返回是否检测到完整参数
        }

        // === 新增：将当前设置写入 URL (不刷新页面) ===
        function updateURLSettings(w, h, d) {
            const url = new URL(window.location);
            url.searchParams.set('w', w);
            url.searchParams.set('h', h);
            url.searchParams.set('d', d);

            // 使用 replaceState 更新 URL 但不增加浏览器历史记录堆栈（避免按返回键回不去）
            window.history.replaceState({}, '', url);
        }

        function clearURLSettings() {
            // 获取当前路径（不含查询参数）
            const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
            window.history.replaceState({}, '', cleanUrl);
        }

        // 1. 读取设置，并获取是否应该自动开始
        const shouldAutoStart = loadSettingsFromURL();

        if (shouldAutoStart) {
            // 2. 如果是带参数的链接：隐藏菜单，直接开始
            menuOverlay.classList.add('hidden');
            initGame();
        } else {
            // 3. 如果是普通访问：显示菜单（这一步其实默认HTML里就是不带hidden的，写在这里是为了逻辑清晰）
            menuOverlay.classList.remove('hidden');
        }
    </script>
</body>

</html>
