<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mineseeker: 逆转版扫雷</title>
    <style>
        :root {
            --bg-color: #050505;
            --grid-bg: #000000;
            --cell-unrevealed: #1a1a1a;
            --cell-revealed: #050505;
            --cell-border-light: #333;
            --cell-border-dark: #111;

            --neon-blue: #00f3ff;
            --neon-red: #ff003c;
            --neon-green: #00ff66;
            --neon-yellow: #fcee0a;
            --text-main: #e0e0e0;
        }

        @font-face {
            font-family: 'Cyber';
            src: local('Courier New');
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #game-container {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .shake {
            animation: shake-anim 0.2s ease-in-out;
        }

        @keyframes shake-anim {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-3px, 3px);
            }

            50% {
                transform: translate(3px, -3px);
            }

            75% {
                transform: translate(-3px, -3px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* 顶部 HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            width: 100%;
            padding: 15px 20px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0));
            text-shadow: 0 0 5px var(--neon-blue);
            z-index: 20;
            pointer-events: none;
            /* 让下面的点击穿透，除了按钮 */
        }

        /* === 修改 .hud-info === */
        .hud-info {
            display: flex;
            gap: 20px;
            font-size: 1rem;
            font-weight: bold;
            flex-grow: 1;
            overflow: hidden;
            /* 防止溢出 */
        }

        /* === 新增：针对内部每一个小项的样式 === */
        .hud-info div {
            /* 核心修复：强制不换行，让 "状态：就绪" 永远连在一起 */
            white-space: nowrap;
        }

        /* === 新增：手机竖屏下的适配 === */
        @media (max-width: 480px) {
            .hud-info {
                /* 手机屏幕窄，减小间距 */
                gap: 8px;
                /* 稍微减小字体，确保三个数据能排成一行 */
                font-size: 0.85rem;
            }

            /* 如果屏幕特别小（如 iPhone SE），稍微压缩一下顶部按钮的边距 */
            #hud {
                padding: 10px 10px;
            }
        }

        /* 顶部常驻按钮组 */
        .top-controls {
            display: flex;
            gap: 10px;
            pointer-events: auto;
            /* 恢复按钮交互 */
        }

        .icon-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        #grid-wrapper {
            position: relative;
            padding: 4px;
            border: 1px solid var(--cell-border-light);
            background: var(--grid-bg);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: margin 0.3s;
        }

        #grid {
            display: grid;
            border: 1px solid var(--cell-border-light);
            position: relative;
            z-index: 2;
        }

        #ray-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: screen;

            will-change: transform, opacity;
            /* 提示浏览器这是个动态层 */
            transform: translateZ(0);
            /* 强制开启 GPU 加速层 */
        }

        .cell {
            background-color: var(--cell-unrevealed);
            border: 1px solid #333;
            box-shadow: inset 1px 1px 0 rgba(255, 255, 255, 0.05), inset -1px -1px 0 rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s;
            position: relative;
            font-size: 1.1rem;
            color: transparent;
        }

        .cell.active {
            background-color: #333;
            box-shadow: inset 0 0 10px var(--neon-blue);
        }

        .cell.revealed {
            background-color: var(--cell-revealed);
            border: 1px solid #111;
            box-shadow: none;
            color: inherit;
            cursor: default;
        }

        .cell.marked::after {
            content: '';
            /* 清空文字内容 */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* 绝对定位居中 */

            width: 60%;
            /* 控制盾牌大小，相对于格子 */
            height: 60%;

            /* 核心技术：使用 CSS 变量作为背景色 */
            background-color: var(--neon-green);

            /* 核心技术：使用 SVG 作为遮罩来塑造形状 */
            /* 这里使用的是选项 B (棱角盾牌) 的 URL 编码数据 */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            /* 使用 box-shadow 代替 text-shadow 来制造发光效果 */
            box-shadow: 0 0 10px var(--neon-green);

            opacity: 0.9;
            pointer-events: none;
            /* 确保鼠标事件穿透图标打到格子上 */
            z-index: 5;
        }

        .cell[data-num="0"] {
            color: #222;
        }

        .cell[data-num="1"] {
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
        }

        .cell[data-num="2"] {
            color: var(--neon-green);
            text-shadow: 0 0 8px var(--neon-green);
        }

        .cell[data-num="3"] {
            color: var(--neon-yellow);
            text-shadow: 0 0 8px var(--neon-yellow);
        }

        .cell[data-num="4"] {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }

        .cell[data-num="5"] {
            color: var(--neon-red);
            text-shadow: 0 0 8px var(--neon-red);
        }

        .cell[data-num="6"] {
            color: cyan;
        }

        .cell[data-num="7"] {
            color: white;
        }

        .cell[data-num="8"] {
            color: grey;
        }

        .cell.mine-flash {
            background-color: #fff !important;
            transition: background-color 0.05s;
            box-shadow: 0 0 20px #fff;
            z-index: 10;
        }

        .cell.mine {
            background-color: rgba(255, 0, 60, 0.2);
            border: 1px solid var(--neon-red);
            box-shadow: inset 0 0 10px rgba(255, 0, 60, 0.3);
            animation: pulse-border 1.5s infinite;
            color: var(--neon-red) !important;
            text-shadow: 0 0 8px var(--neon-red);
        }

        @keyframes pulse-border {
            0% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }

            50% {
                box-shadow: inset 0 0 15px rgba(255, 0, 60, 0.6);
            }

            100% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }
        }

        /* 响应式工具栏 */
        #toolbar {
            position: absolute;
            z-index: 30;
            display: flex;
            gap: 15px;
            padding: 10px;
            pointer-events: auto;
        }

        /* 竖屏模式 (Portrait): 工具栏在底部 */
        @media (orientation: portrait) {
            #toolbar {
                bottom: 60px;
                /* 给底部文字留点空间 */
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
            }

            #grid-wrapper {
                margin: 0;
                margin-bottom: 100px;
                /* 给下方工具栏留空 */
            }
        }

        /* 横屏模式 (Landscape): 工具栏在右侧 */
        @media (orientation: landscape) {
            #toolbar {
                right: 20px;
                top: 50%;
                transform: translateY(-50%);
                flex-direction: column;
            }

            #grid-wrapper {
                margin-right: 80px;
                /* 给右侧工具栏留空 */
                margin-bottom: 0;
            }
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #666;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: -2px 2px 10px rgba(0, 0, 0, 0.5);
            touch-action: manipulation;
        }

        .tool-btn span {
            pointer-events: none;
        }

        .tool-btn.active {
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: scale(1.1);
        }

        .tool-btn#btn-mode-mark.active {
            background: rgba(0, 255, 102, 0.15);
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 15px rgba(0, 255, 102, 0.3);
        }

        #btn-mode-mark span {
            display: inline-block;
            width: 28px;
            /* 设置图标宽度 */
            height: 28px;
            /* 设置图标高度 */

            /* 核心：让背景色继承父级按钮的颜色 (灰色或霓虹绿) */
            background-color: currentColor;

            /* 使用与格子标记相同的 SVG 遮罩 */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            pointer-events: none;
            /* 保持穿透 */
        }

        #guide-text {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            text-shadow: 0 0 3px black;
            z-index: 20;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0));
            padding-bottom: 5px;
        }

        #menu-overlay,
        #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        h1 {
            color: var(--neon-blue);
            text-shadow: 0 0 15px var(--neon-blue);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-align: center;
        }

        .control-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 300px;
        }

        label {
            color: var(--neon-green);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: #333;
            height: 6px;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--neon-blue);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-blue);
            border: 2px solid #fff;
        }

        .menu-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            font-size: 1.1rem;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .menu-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue);
        }

        .hidden {
            display: none !important;
        }

        #end-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .win {
            color: var(--neon-green);
            text-shadow: 0 0 20px var(--neon-green);
        }

        .lose {
            color: var(--neon-red);
            text-shadow: 0 0 20px var(--neon-red);
        }

        /* === 计时器样式 === */
        #timer-display {
            font-family: 'Cyber', monospace;
            color: var(--neon-blue);
            min-width: 60px;
            display: inline-block;
        }

        /* === 全新的结算卡片样式 === */
        .result-card {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 0, 0, 0.8);
            padding: 2px;
            /* 给内边框留空 */
            width: 90%;
            max-width: 400px;
            position: relative;
            backdrop-filter: blur(10px);
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 动画激活状态 */
        #game-over-overlay:not(.hidden) .result-card {
            transform: scale(1);
            opacity: 1;
        }

        .card-header {
            background: rgba(0, 243, 255, 0.1);
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid #333;
            position: relative;
            overflow: hidden;
        }

        .card-header h2 {
            margin: 0;
            font-size: 1.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* 扫描线动画 */
        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--neon-blue);
            opacity: 0.5;
            animation: scan-down 2s linear infinite;
        }

        @keyframes scan-down {
            0% {
                top: 0%;
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                top: 100%;
                opacity: 0;
            }
        }

        .card-body {
            padding: 20px 30px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            border-bottom: 1px dashed #333;
            padding-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        .stat-value {
            color: var(--text-main);
            font-weight: bold;
            font-family: 'Cyber', monospace;
            font-size: 1.1rem;
        }

        .flavor-text {
            text-align: center;
            margin-top: 20px;
            color: #888;
            font-style: italic;
            font-size: 0.9rem;
        }

        .card-actions {
            padding: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        /* 次级按钮样式 */
        .menu-btn.secondary {
            background: transparent;
            border-color: #444;
            color: #888;
            box-shadow: none;
            font-size: 0.9rem;
        }

        .menu-btn.secondary:hover {
            border-color: #fff;
            color: #fff;
        }

        /* 胜利时的卡片配色变种 */
        .result-card.win-theme {
            border-color: var(--neon-green);
            box-shadow: 0 0 30px rgba(0, 255, 102, 0.15);
        }

        .result-card.win-theme .card-header {
            background: rgba(0, 255, 102, 0.1);
        }

        .result-card.win-theme .scan-line {
            background: var(--neon-green);
        }

        /* 失败时的卡片配色变种 */
        .result-card.lose-theme {
            border-color: var(--neon-red);
            box-shadow: 0 0 30px rgba(255, 0, 60, 0.15);
        }

        .result-card.lose-theme .card-header {
            background: rgba(255, 0, 60, 0.1);
        }

        .result-card.lose-theme .scan-line {
            background: var(--neon-red);
        }
    </style>
</head>

<body>

    <div class="scanlines"></div>

    <div id="game-container">
        <div id="hud">
            <div class="hud-info">
                <div>目标: <span id="mines-left">0</span></div>
                <div>时间: <span id="timer-display">00:00</span></div>
                <div>状态: <span id="status-text" style="color:var(--neon-green)">就绪</span></div>
            </div>
            <div class="top-controls">
                <div class="icon-btn" id="btn-ingame-restart" title="重开">↻</div>
                <div class="icon-btn" id="btn-ingame-menu" title="菜单">☰</div>
            </div>
        </div>

        <div id="game-over-overlay" class="hidden">
            <div class="result-card">
                <div class="card-header">
                    <h2 id="end-title">MISSION COMPLETE</h2>
                    <div class="scan-line"></div>
                </div>

                <div class="card-body">
                    <div class="stat-row">
                        <span class="stat-label">耗时 / TIME</span>
                        <span class="stat-value" id="end-time">00:00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">难度 / DIFFICULTY</span>
                        <span class="stat-value" id="end-difficulty">NORMAL</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">完成度 / COMPLETION</span>
                        <span class="stat-value" id="end-percentage">100%</span>
                    </div>

                    <p id="end-reason" class="flavor-text">所有威胁已消除</p>
                </div>

                <div class="card-actions">
                    <button class="menu-btn" id="btn-restart">重启系统</button>
                    <button class="menu-btn secondary" id="btn-menu">返回菜单</button>
                </div>
            </div>
        </div>

        <div id="grid-wrapper">
            <div id="grid"></div>
            <canvas id="ray-canvas"></canvas>
        </div>

        <div id="toolbar">
            <div class="tool-btn active" id="btn-mode-detonate" onclick="setMode('detonate')" title="引爆模式">
                <span>⚡</span>
            </div>
            <div class="tool-btn" id="btn-mode-mark" onclick="setMode('mark')" title="标记模式">
                <span></span>
            </div>
        </div>

        <div id="guide-text">长按雷区并滑动 > 必须命中雷才能存活</div>
    </div>

    <div id="menu-overlay">
        <h1>MINESEEKER</h1>
        <div class="control-group">
            <label>网格宽度: <span id="val-w">10</span></label>
            <input type="range" id="inp-w" min="8" max="32" value="10">
        </div>
        <div class="control-group">
            <label>网格高度: <span id="val-h">15</span></label>
            <input type="range" id="inp-h" min="8" max="32" value="15">
        </div>
        <div class="control-group">
            <label>地雷密度: <span id="val-d">30%</span></label>
            <input type="range" id="inp-d" min="25" max="75" value="30" step="5">
        </div>
        <button class="menu-btn" id="btn-start">启动协议</button>
    </div>

    <script>
        const CONFIG = {
            gridW: 10,
            gridH: 15,
            density: 0.3,
            cellSize: 35,
            rayLength: 5,
            colors: {
                blue: '#00f3ff',
                green: '#00ff66',
                red: '#ff003c',
                yellow: '#fcee0a',
                white: '#ffffff',
                purple: '#bc13fe'
            }
        };

        const AUDIO_CTX = new (window.AudioContext || window.webkitAudioContext)();

        let gridData = [];
        let totalMines = 0;
        let revealedMines = 0;
        let isFirstMove = true;
        let isGameOver = false;
        let currentMode = 'detonate';

        let gameStartTime = 0;
        let timerInterval = null;
        let elapsedTime = 0;

        const rayCanvas = document.getElementById('ray-canvas');
        const rayCtx = rayCanvas.getContext('2d');
        let animationFrameId;
        let activeEffects = [];
        let comboCounter = 0;

        const gridEl = document.getElementById('grid');
        const hudMines = document.getElementById('mines-left');
        const hudStatus = document.getElementById('status-text');
        const guideText = document.getElementById('guide-text');

        let startCell = null;
        let isDragging = false;
        let dragLine = { x: 0, y: 0 };

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btn-mode-detonate').classList.toggle('active', mode === 'detonate');
            document.getElementById('btn-mode-mark').classList.toggle('active', mode === 'mark');

            if (mode === 'detonate') {
                guideText.textContent = "左键或手指朝八个方向拖动引爆 / 电脑端右键标记安全区";
                guideText.style.color = "#888";
            } else {
                guideText.textContent = "点击未知区域 > 标记或取消安全区";
                guideText.style.color = "var(--neon-green)";
            }

            playSound('hover');
        }

        function playSound(type) {
            if (AUDIO_CTX.state === 'suspended') AUDIO_CTX.resume();
            const osc = AUDIO_CTX.createOscillator();
            const gainNode = AUDIO_CTX.createGain();
            osc.connect(gainNode);
            gainNode.connect(AUDIO_CTX.destination);

            const t = AUDIO_CTX.currentTime;

            if (type === 'hover') {
                osc.frequency.setValueAtTime(800, t);
                gainNode.gain.setValueAtTime(0.01, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.05);
            } else if (type === 'mark') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, t);
                gainNode.gain.setValueAtTime(0.05, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
            } else if (type === 'ray') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                gainNode.gain.setValueAtTime(0.15, t);
                gainNode.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t);
                osc.stop(t + 0.2);
            } else if (type === 'explode') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t);
                osc.stop(t + 0.4);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.start(t);
                osc.stop(t + 0.5);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.04 + 0.02;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.gravity = 0.2;
            }

            update(dt) {
                const f = dt * 60;

                this.x += this.vx * f;
                this.y += this.vy * f;
                this.vy += this.gravity * f;

                this.life -= this.decay * f;
                this.size *= Math.pow(0.95, f);
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class FloatingText {
            constructor(x, y, count) {
                const cs = CONFIG.cellSize;
                this.baseX = (x + 0.5) * cs;
                this.baseY = (y + 0.5) * cs;

                // —— 2~10 每个都不同：文字、色相、描边、抖动、旋转、光晕强度 ——
                const PRESET = {
                    2: { text: 'DOUBLE', color: '#00f3ff', glow: 18, stroke: 7, size: 34, jitter: 0.8, rot: -0.10 },
                    3: { text: 'TRIPLE', color: '#00ff66', glow: 20, stroke: 7, size: 36, jitter: 1.0, rot: 0.10 },
                    4: { text: 'QUAD', color: '#bc13fe', glow: 22, stroke: 8, size: 40, jitter: 1.2, rot: -0.08 },
                    5: { text: 'PENTA', color: '#fcee0a', glow: 26, stroke: 9, size: 44, jitter: 1.5, rot: 0.06 },
                    6: { text: 'HEX', color: '#ff7a00', glow: 28, stroke: 10, size: 48, jitter: 1.8, rot: -0.05 },
                    7: { text: 'SEPT', color: '#ff003c', glow: 30, stroke: 11, size: 52, jitter: 2.2, rot: 0.04 },
                    8: { text: 'OCTA', color: '#ffffff', glow: 34, stroke: 12, size: 58, jitter: 2.6, rot: -0.03 },
                    9: { text: 'NOVA', color: '#00ffff', glow: 38, stroke: 12, size: 64, jitter: 3.0, rot: 0.02 },
                    10: { text: 'DECA+', color: '#ff00ff', glow: 44, stroke: 14, size: 72, jitter: 3.4, rot: 0.00 },
                };

                this.count = count;
                this.p = PRESET[count] || PRESET[10];

                // 让文字更“有力”：初速度更集中（上冲 + 轻微左右散射）
                this.vx = (Math.random() - 0.5) * 2.2;
                this.vy = -5.2 - Math.random() * 1.4;
                this.gravity = 0.16;

                // 用“时间进度”驱动动画（更稳定）
                this.t = 0;          // 0 -> 1
                this.duration = 0.75; // 秒
                this.life = 1.0;     // 兼容你现有的销毁逻辑

                // 旋转 & 抖动
                this.rot = this.p.rot + (Math.random() - 0.5) * 0.06;
                this.rotVel = (Math.random() - 0.5) * 0.012;

                // 每个连击级别不同的“屏幕叠加感”
                this.additive = count >= 7;

                // 初始位置
                this.x = this.baseX;
                this.y = this.baseY;

                // 小技巧：高连击更“弹”
                this.pop = 1.15 + (count - 2) * 0.03;
            }

            // easing：弹性进入 + 平滑消失
            easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }
            easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

            update(dt) {
                // 时间推进（0 → 1）
                this.t += dt / this.duration;
                if (this.t > 1) this.t = 1;

                // 位移（像素/秒）
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;

                // 重力（像素/秒²）
                this.vy += this.gravity * dt * 60;

                // 空气阻力（指数衰减）
                const drag = Math.pow(0.96, dt * 60);
                this.vx *= drag;

                // 旋转
                this.rot += this.rotVel * dt * 60;

                // 透明度
                if (this.t < 0.55) {
                    this.life = 1;
                } else {
                    this.life = Math.max(0, 1 - (this.t - 0.55) / 0.45);
                }

                // 抖动强度
                const jStrength = (1 - this.easeOutCubic(Math.min(this.t / 0.3, 1))) * this.p.jitter;
                this.jx = (Math.random() - 0.5) * jStrength * 2;
                this.jy = (Math.random() - 0.5) * jStrength * 2;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                // scale：前段弹出、后段微缩
                const popT = Math.min(this.t / 0.25, 1);
                const popScale = this.easeOutBack(popT) * this.pop;
                const settle = this.t > 0.35 ? (1 - (this.t - 0.35) * 0.12) : 1;
                const scale = popScale * settle;

                ctx.save();

                if (this.additive) ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.life;

                ctx.translate(this.x + this.jx, this.y + this.jy);
                ctx.rotate(this.rot);
                ctx.scale(scale, scale);

                // 字体：更“游戏击杀提示”的感觉
                ctx.font = `italic 900 ${this.p.size}px "Arial Black", "Impact", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // 1) 黑色厚描边（清晰度）
                ctx.lineJoin = 'round';
                ctx.strokeStyle = 'rgba(0,0,0,0.95)';
                ctx.lineWidth = this.p.stroke;
                ctx.strokeText(this.p.text, 0, 0);

                // 2) 彩色外辉光（霓虹感）
                ctx.shadowBlur = this.p.glow;
                ctx.shadowColor = this.p.color;
                ctx.fillStyle = this.p.color;
                ctx.fillText(this.p.text, 0, 0);

                // 3) 白色高光（立体）
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(this.p.text, -2, -2);

                // 4) 超高连击：加一道“切割高光线”（更像爆发）
                if (this.count >= 8) {
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-this.p.size * 1.2, -this.p.size * 0.2);
                    ctx.lineTo(this.p.size * 1.2, -this.p.size * 0.55);
                    ctx.stroke();
                }

                ctx.restore();
                ctx.globalCompositeOperation = 'source-over';
            }
        }


        class Shockwave {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = CONFIG.cellSize * 1.5;
                this.color = color;
                this.life = 1.0;
                this.decay = 0.08;
            }

            update(dt) {
                const f = dt * 60;
                this.radius += 3 * f;
                this.life -= this.decay * f;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class RayEffect {
            constructor(startX, startY, dirX, dirY, lengthCells, isFailure = false) {
                const cs = CONFIG.cellSize;
                this.sx = (startX + 0.5) * cs;
                this.sy = (startY + 0.5) * cs;
                this.ex = this.sx + (dirX * lengthCells * cs);
                this.ey = this.sy + (dirY * lengthCells * cs);
                this.life = 1.0;

                this.isFailure = isFailure;

                // 生成一个基于位置的随机偏移量，用于脉冲动画，
                // 确保每条射线的脉冲步调不一致。
                this.pulseOffset = (this.sx + this.sy) * 0.1 + Math.random() * 10;

                if (this.isFailure) {
                    // === 失败射线参数 ===
                    this.width = 2;       // 依然保持极细
                    // 这里不再定义单一 color，而是在 draw 里定义血色层次
                    this.maxJitter = 0;   //稍微增加一点抖动，配合脉冲
                } else {
                    // === 普通射线参数 ===
                    this.width = 15;
                    this.color = CONFIG.colors.blue;
                    this.maxJitter = 10;
                }

                this.jitter = 0;
            }

            update(dt) {
                const f = dt * 60;

                this.life -= (this.isFailure ? 0.03 : 0.08) * f;

                if (!this.isFailure) {
                    this.width *= Math.pow(0.9, f);
                }

                this.jitter = (Math.random() - 0.5) * this.maxJitter;
            }

            draw(ctx) {
                // 失败模式依然使用 lighter，让交叉点极其明亮
                ctx.globalCompositeOperation = this.isFailure ? 'lighter' : 'screen';
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(this.sx, this.sy);
                ctx.lineTo(this.ex + this.jitter, this.ey + this.jitter);

                if (this.isFailure) {
                    // === 修改点：血色脉冲激光风格 ===

                    // 计算脉冲因子：利用当前时间 + 自身偏移量计算正弦波
                    // 速度较快 ( * 0.02 )
                    const time = performance.now();
                    const pulseWave = Math.sin(time * 0.02 + this.pulseOffset);
                    // 将正弦波(-1到1)映射到一个亮度波动范围，例如 0.6 到 1.0 之间
                    const pulseFactor = (pulseWave * 0.2) + 0.8;

                    // 层1: 深血色外晕 (提供深邃的背景，不脉冲，稳定存在)
                    ctx.lineWidth = 5; // 稍微宽一点点作为底色
                    ctx.strokeStyle = '#660000'; // 深沉的干涸血色
                    ctx.globalAlpha = this.life * 0.5; // 半透明
                    ctx.stroke();

                    // 层2: 鲜血核心 (极细，高饱和，带有脉冲效果)
                    ctx.lineWidth = 1.5; // 极细核心
                    // 使用鲜艳的动脉血红，而不是之前的粉白
                    ctx.strokeStyle = '#ff0000';
                    // Alpha 由生命值和脉冲因子共同决定
                    ctx.globalAlpha = this.life * pulseFactor * 0.9;
                    ctx.stroke();

                } else {
                    // === 普通蓝色扫描线 (保持原样) ===
                    ctx.lineWidth = this.width * 3;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.2;
                    ctx.stroke();

                    ctx.lineWidth = this.width;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.stroke();

                    ctx.lineWidth = this.width * 0.3;
                    ctx.strokeStyle = '#ffffff';
                    ctx.globalAlpha = this.life;
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = 'source-over';
            }
        }
        function startRenderLoop() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            let lastTime = performance.now();

            function loop(now) {
                const deltaTime = Math.min((now - lastTime) / 1000, 0.05);
                lastTime = now;

                rayCtx.clearRect(0, 0, rayCanvas.width, rayCanvas.height);

                for (let i = activeEffects.length - 1; i >= 0; i--) {
                    const effect = activeEffects[i];
                    effect.update(deltaTime);
                    effect.draw(rayCtx);
                    if (effect.life <= 0) {
                        activeEffects.splice(i, 1);
                    }
                }

                animationFrameId = requestAnimationFrame(loop);
            }

            animationFrameId = requestAnimationFrame(loop);
        }

        //const MAX_PARTICLES = 150;
        function spawnExplosion(cx, cy, color = CONFIG.colors.red) {
            //if (activeEffects.length > MAX_PARTICLES) {
            //    return;
            // }

            const particleCount = 20;
            const pixelX = (cx + 0.5) * CONFIG.cellSize;
            const pixelY = (cy + 0.5) * CONFIG.cellSize;
            for (let i = 0; i < particleCount; i++) {
                activeEffects.push(new Particle(pixelX, pixelY, color));
            }
            activeEffects.push(new Shockwave(pixelX, pixelY, color));
        }

        function spawnRay(x, y, dx, dy, isFailure = false) {
            activeEffects.push(new RayEffect(x, y, dx, dy, CONFIG.rayLength, isFailure));
        }

        function explodeNeighbors(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                        const neighbor = gridData[ny][nx];
                        if (!neighbor.isRevealed) {
                            neighbor.reveal();
                        }
                    }
                }
            }
        }

        function floodFill(x, y) {
            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            for (let dir of dirs) {
                const nx = x + dir.x;
                const ny = y + dir.y;

                if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                    const neighbor = gridData[ny][nx];
                    if (!neighbor.isRevealed && !neighbor.isMine && neighbor.neighborCount === 0) {
                        neighbor.reveal();
                    }
                }
            }
        }

        function revealRayPath(startX, startY, dirX, dirY) {
            for (let i = 1; i <= CONFIG.rayLength; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);
                if (tx < 0 || tx >= CONFIG.gridW || ty < 0 || ty >= CONFIG.gridH) break;

                const targetCell = gridData[ty][tx];
                if (!targetCell.isMine && !targetCell.isRevealed) {
                    targetCell.reveal();
                }
            }
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.isMine = false;
                this.isRevealed = false;
                this.isMarked = false;
                this.neighborCount = 0;
                this.element = document.createElement('div');
                this.element.className = 'cell';
                this.element.dataset.x = x;
                this.element.dataset.y = y;
            }

            toggleMark() {
                if (this.isRevealed) return;
                this.isMarked = !this.isMarked;
                this.element.classList.toggle('marked', this.isMarked);
                playSound('mark');
            }

            reveal() {
                if (this.isRevealed) return;

                this.isMarked = false;
                this.element.classList.remove('marked');

                this.isRevealed = true;
                this.element.classList.add('revealed');

                if (this.isMine) {
                    this.element.classList.add('mine');
                    this.element.textContent = '☢';
                    this.element.dataset.num = 'mine';

                    this.element.classList.add('mine-flash');
                    setTimeout(() => this.element.classList.remove('mine-flash'), 150);

                    revealedMines++;
                    playSound('explode');
                    spawnExplosion(this.x, this.y, CONFIG.colors.red);

                    const container = document.getElementById('game-container');
                    container.classList.remove('shake');
                    void container.offsetWidth;
                    container.classList.add('shake');

                } else {
                    this.element.textContent = this.neighborCount === 0 ? '' : this.neighborCount;
                    this.element.dataset.num = this.neighborCount;

                    if (this.neighborCount === 0) {
                        floodFill(this.x, this.y);
                    } else {
                        spawnExplosion(this.x, this.y, 'rgba(0, 243, 255, 0.4)');
                    }
                }
                updateHUD();
            }
        }

        function startTimer() {
            if (timerInterval) return;
            gameStartTime = Date.now();
            const display = document.getElementById('timer-display');

            timerInterval = setInterval(() => {
                const now = Date.now();
                elapsedTime = Math.floor((now - gameStartTime) / 1000);
                display.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function resizeCanvasToDisplaySize(canvas, cssWidth, cssHeight) {
            const dpr = window.devicePixelRatio || 1;

            // 1) 设定 CSS 尺寸（页面上看到的尺寸）
            canvas.style.width = cssWidth + 'px';
            canvas.style.height = cssHeight + 'px';

            // 2) 设定实际像素尺寸（乘 DPR，保证清晰）
            const displayWidth = Math.round(cssWidth * dpr);
            const displayHeight = Math.round(cssHeight * dpr);

            // 避免重复 set 造成抖动/重置状态
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            return dpr;
        }

        function initGame() {
            // 清理可能的旧延时操作
            if (window.failTimeout) clearTimeout(window.failTimeout);
            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);
            window.failIntervals = window.failIntervals || [];
            window.failIntervals.forEach(id => clearTimeout(id));
            window.failIntervals = [];

            stopTimer();
            elapsedTime = 0;
            document.getElementById('timer-display').textContent = "00:00";

            gridEl.innerHTML = '';
            gridData = [];
            revealedMines = 0;
            isFirstMove = true;
            isGameOver = false;
            activeEffects = [];
            hudStatus.textContent = "待命";
            hudStatus.style.color = "var(--neon-green)";
            setMode('detonate');

            // 智能计算布局
            const isLandscape = window.innerWidth > window.innerHeight;
            const margin = 10;
            const hudHeight = 70;
            const guideHeight = 40;

            // 根据方向判断工具栏占用的空间
            const toolbarW = isLandscape ? 70 : 0;
            const toolbarH = isLandscape ? 0 : 80;

            const availableWidth = window.innerWidth - margin - toolbarW;
            const availableHeight = window.innerHeight - hudHeight - guideHeight - margin - toolbarH;

            const sizeW = Math.floor(availableWidth / CONFIG.gridW);
            const sizeH = Math.floor(availableHeight / CONFIG.gridH);

            let size = Math.min(sizeW, sizeH, 50);
            size = Math.max(size, 20);

            CONFIG.cellSize = size;

            const totalWidth = size * CONFIG.gridW;
            const totalHeight = size * CONFIG.gridH;

            gridEl.style.gridTemplateColumns = `repeat(${CONFIG.gridW}, ${size}px)`;
            gridEl.style.gridTemplateRows = `repeat(${CONFIG.gridH}, ${size}px)`;

            const dpr = resizeCanvasToDisplaySize(rayCanvas, totalWidth, totalHeight);

            // 关键：把坐标系缩回“CSS 像素”，这样你后面用的 cellSize/像素计算都不用改
            rayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

            for (let y = 0; y < CONFIG.gridH; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.gridW; x++) {
                    const cell = new Cell(x, y);
                    gridEl.appendChild(cell.element);
                    row.push(cell);
                }
                gridData.push(row);
            }

            totalMines = Math.floor(CONFIG.gridW * CONFIG.gridH * CONFIG.density);
            updateHUD();
            startRenderLoop();
        }

        function generateMines(startX, startY) {
            gridData[startY][startX].isMine = true;
            let placed = 1;

            while (placed < totalMines) {
                const rx = Math.floor(Math.random() * CONFIG.gridW);
                const ry = Math.floor(Math.random() * CONFIG.gridH);

                if (!gridData[ry][rx].isMine) {
                    gridData[ry][rx].isMine = true;
                    placed++;
                }
            }

            calculateNumbers();
        }

        function calculateNumbers() {
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
            ];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    let count = 0;
                    for (let dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (gridData[ny][nx].isMine) count++;
                        }
                    }
                    gridData[y][x].neighborCount = count;
                }
            }
        }

        function fireRay(startX, startY, dirX, dirY, delay = 0) {
            setTimeout(() => {
                if (isGameOver) return;

                playSound('ray');
                spawnRay(startX, startY, dirX, dirY);

                let hitMine = false;

                for (let i = 1; i <= CONFIG.rayLength; i++) {
                    const tx = startX + (dirX * i);
                    const ty = startY + (dirY * i);

                    if (tx < 0 || tx >= CONFIG.gridW || ty < 0 || ty >= CONFIG.gridH) break;

                    const targetCell = gridData[ty][tx];

                    if (targetCell.isMine) {
                        if (!targetCell.isRevealed) {
                            targetCell.reveal();
                            explodeNeighbors(tx, ty);
                            fireRay(tx, ty, dirX, dirY, 120);

                            comboCounter++;
                            const showCount = Math.min(comboCounter, 10);

                            if (showCount >= 2) {
                                activeEffects.push(new FloatingText(tx, ty, showCount));
                            }

                            hitMine = true;
                        }
                    } else {
                        targetCell.reveal();
                    }
                }
                checkWinCondition();
            }, delay);
        }

        function setupInput() {
            // 1. 禁止网格区域的浏览器默认右键菜单
            gridEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });

            const getCellCoords = (e) => {
                const rect = gridEl.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const x = Math.floor((clientX - rect.left) / CONFIG.cellSize);
                const y = Math.floor((clientY - rect.top) / CONFIG.cellSize);
                return { x, y, clientX, clientY };
            };

            const startDrag = (e) => {
                if (isGameOver) return;

                // 只有触摸事件才需要 preventDefault 防止滚动，鼠标左键不需要，
                // 但为了处理右键不弹出菜单，上面已经加了 contextmenu 的监听
                if (e.type === 'touchstart') e.preventDefault();

                const coords = getCellCoords(e);

                // 判断是否为右键点击 (鼠标右键 button 值为 2)
                const isRightClick = e.button === 2;

                if (coords.x >= 0 && coords.x < CONFIG.gridW && coords.y >= 0 && coords.y < CONFIG.gridH) {
                    const cell = gridData[coords.y][coords.x];

                    if (cell.isRevealed) return;

                    // === 修改后的逻辑核心 ===
                    // 满足以下任一条件则执行【标记】操作：
                    // 1. 用户点击了鼠标右键
                    // 2. 当前本来就是“标记模式” (currentMode === 'mark')
                    if (isRightClick || currentMode === 'mark') {
                        cell.toggleMark();
                        return; // 标记是瞬间动作，不需要后续的拖拽逻辑
                    }

                    // === 下面是引爆模式的左键拖拽逻辑 ===
                    if (currentMode === 'detonate' && cell.isMarked) {
                        return; // 引爆模式下，不能拖动已标记的格子
                    }

                    startCell = { x: coords.x, y: coords.y };
                    cell.element.classList.add('active');
                    isDragging = true;
                    dragLine = { x: coords.clientX, y: coords.clientY };
                    playSound('hover');
                }
            };

            const moveDrag = (e) => {
                // 如果是标记模式，或者刚才触发的是右键标记，则不处理拖动
                if (!isDragging || currentMode === 'mark') return;
                e.preventDefault();
            };

            const endDrag = (e) => {
                if (currentMode === 'mark') return;
                if (!isDragging) return;

                const coords = e.changedTouches ?
                    { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY } :
                    { clientX: e.clientX, clientY: e.clientY };

                const dx = coords.clientX - dragLine.x;
                const dy = coords.clientY - dragLine.y;

                if (startCell && gridData[startCell.y] && gridData[startCell.y][startCell.x]) {
                    gridData[startCell.y][startCell.x].element.classList.remove('active');
                }

                if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
                    const angle = Math.atan2(dy, dx);
                    const degree = angle * (180 / Math.PI);
                    const octant = Math.round(degree / 45);

                    const dirs = [
                        { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 },
                        { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }
                    ];

                    let dirIndex = octant;
                    if (dirIndex < 0) dirIndex += 8;
                    dirIndex = dirIndex % 8;

                    const dir = dirs[dirIndex];
                    handleAction(startCell.x, startCell.y, dir.x, dir.y);
                }

                isDragging = false;
                startCell = null;
            };

            gridEl.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', moveDrag);
            window.addEventListener('mouseup', endDrag);

            gridEl.addEventListener('touchstart', startDrag, { passive: false });
            window.addEventListener('touchmove', moveDrag, { passive: false });
            window.addEventListener('touchend', endDrag);
        }

        function handleAction(x, y, dirX, dirY) {
            const cell = gridData[y][x];
            if (cell.isRevealed || cell.isMarked) return;

            comboCounter = 0;

            if (isFirstMove) {
                generateMines(x, y);
                isFirstMove = false;
                hudStatus.textContent = "链接建立";
                startTimer();
            }

            if (cell.isMine) {
                cell.reveal();
                // 现在采取的是邻居优先不链式反应的规则，可以解释为周围被炸坏了
                explodeNeighbors(x, y);
                fireRay(x, y, dirX, dirY);
            } else {
                cell.element.style.backgroundColor = "var(--neon-red)";
                spawnExplosion(x, y, CONFIG.colors.red);
                gameOver(false);
            }
        }

        let endDuration = 0.0;

        function triggerChainFailure() {
            hudStatus.textContent = "系统崩溃";
            hudStatus.style.color = "var(--neon-red)";
            playSound('error');

            const hiddenMines = [];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    if (gridData[y][x].isMine && !gridData[y][x].isRevealed) {
                        hiddenMines.push(gridData[y][x]);
                    }
                }
            }

            hiddenMines.sort(() => Math.random() - 0.5);

            // 动态间隔计算
            let interval = 300;
            if (hiddenMines.length > 10) {
                // 如果雷多于10个，确保在3000ms内炸完
                interval = 3000 / hiddenMines.length;
            }

            // 清理旧的定时器数组
            window.failIntervals = [];
            endDuration = interval * hiddenMines.length;

            hiddenMines.forEach((cell, index) => {
                const id = setTimeout(() => {
                    cell.element.classList.add('mine');
                    cell.element.textContent = '☢';
                    cell.element.classList.add('mine-flash');
                    setTimeout(() => cell.element.classList.remove('mine-flash'), 150);

                    playSound('explode');
                    spawnExplosion(cell.x, cell.y, CONFIG.colors.red);

                    const dirs = [
                        { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 },
                        { x: 0, y: 1 }, { x: -1, y: 1 }, { x: -1, y: 0 }, { x: -1, y: -1 }
                    ];
                    dirs.forEach(d => {
                        spawnRay(cell.x, cell.y, d.x, d.y, true);
                        revealRayPath(cell.x, cell.y, d.x, d.y);
                    });

                }, index * interval);
                window.failIntervals.push(id);
            });
        }

        function checkWinCondition() {
            if (revealedMines >= totalMines) {
                gameOver(true);
            }
        }

        function gameOver(win, reason) {
            if (isGameOver) return;

            stopTimer();

            isGameOver = true;
            if (!win) {
                triggerChainFailure();
                // 注意：失败时我们稍后弹出界面，但数据现在就要准备好
            } else {
                // 胜利直接处理
                hudStatus.textContent = "胜利";
                hudStatus.style.color = "var(--neon-green)";
                playSound('hover');
            }

            // 准备界面数据
            const card = document.querySelector('.result-card');
            const title = document.getElementById('end-title');
            const timeDisplay = document.getElementById('end-time');
            const diffDisplay = document.getElementById('end-difficulty');
            const pctDisplay = document.getElementById('end-percentage');
            const reasonText = document.getElementById('end-reason');
            const overlay = document.getElementById('game-over-overlay');

            // 设置基本数据
            timeDisplay.textContent = formatTime(elapsedTime);
            diffDisplay.textContent = `${CONFIG.gridW}x${CONFIG.gridH} (${Math.round(CONFIG.density * 100)}%)`;

            // 移除旧主题
            card.classList.remove('win-theme', 'lose-theme');

            // 延迟显示逻辑 (为了配合爆炸动画)
            const showDelay = win ? 1500 : (endDuration + 1500);

            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            window.gameResultTimeout = setTimeout(() => {
                if (win) {
                    title.textContent = "SYSTEM PURGED";
                    title.className = "win"; // 保持文字颜色逻辑
                    card.classList.add('win-theme');
                    pctDisplay.textContent = "100%";
                    reasonText.textContent = "所有威胁已消除，系统恢复正常。";
                } else {
                    title.textContent = "CONNECTION LOST";
                    title.className = "lose";
                    card.classList.add('lose-theme');
                    // 计算完成度
                    const pct = Math.floor((revealedMines / totalMines) * 100);
                    pctDisplay.textContent = `${pct}% THREATS NEUTRALIZED`;
                    reasonText.textContent = "逻辑链路崩溃，协议执行失败。";
                }
                overlay.classList.remove('hidden');
            }, showDelay);
        }

        function updateHUD() {
            hudMines.textContent = `${totalMines - revealedMines}`;
        }

        const menuOverlay = document.getElementById('menu-overlay');
        const inpW = document.getElementById('inp-w');
        const inpH = document.getElementById('inp-h');
        const inpD = document.getElementById('inp-d');

        [inpW, inpH, inpD].forEach(el => {
            el.addEventListener('input', () => {
                document.getElementById(`val-${el.id.split('-')[1]}`).textContent =
                    el.id === 'inp-d' ? el.value + '%' : el.value;
            });
        });

        document.getElementById('btn-start').addEventListener('click', () => {
            CONFIG.gridW = parseInt(inpW.value);
            CONFIG.gridH = parseInt(inpH.value);
            CONFIG.density = parseInt(inpD.value) / 100;
            menuOverlay.classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-restart').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-menu').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            menuOverlay.classList.remove('hidden');
        });

        // 游戏内菜单按钮事件
        document.getElementById('btn-ingame-restart').addEventListener('click', () => {
            initGame();
        });

        // === 修改后的菜单按钮逻辑 ===
        document.getElementById('btn-ingame-menu').addEventListener('click', () => {
            // 1. 立即结束游戏状态，防止后续点击
            isGameOver = true;

            // 2. 如果正在进行连锁爆炸动画，立即清除定时器，防止后台卡顿或声音继续播放
            if (window.failIntervals) {
                window.failIntervals.forEach(id => clearTimeout(id));
                window.failIntervals = [];
            }
            if (window.failTimeout) clearTimeout(window.failTimeout);

            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            // 3. 更新 HUD 状态
            hudStatus.textContent = "已中断";
            hudStatus.style.color = "#888";

            // 4. 显示菜单
            menuOverlay.classList.remove('hidden');
        });

        // 监听窗口大小变化以重新计算布局（可选，简单起见直接重置可能更好，或者动态调整 grid-wrapper）
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // 只有在非游戏进行中或者你想支持动态调整时才调用
                // 这里为了体验流畅，建议用户手动重开，或者只重新计算 grid 尺寸而不清空数据
                // 简单处理：重新初始化
                if (!isGameOver && revealedMines === 0) {
                    initGame();
                }
            }, 500);
        });

        setupInput();

    </script>
</body>

</html>
