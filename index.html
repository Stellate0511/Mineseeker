<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mineseeker: ÈÄÜËΩ¨ÁâàÊâ´Èõ∑</title>
    <style>
        :root {
            --bg-color: #050505;
            --grid-bg: #000000;
            --cell-unrevealed: #1a1a1a;
            --cell-revealed: #050505;
            --cell-border-light: #333;
            --cell-border-dark: #111;
            
            --neon-blue: #00f3ff;
            --neon-red: #ff003c;
            --neon-green: #00ff66;
            --neon-yellow: #fcee0a;
            --text-main: #e0e0e0;
        }

        @font-face {
            font-family: 'Cyber';
            src: local('Courier New');
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh; 
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #game-container {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .shake {
            animation: shake-anim 0.2s ease-in-out;
        }
        @keyframes shake-anim {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-3px, 3px); }
            50% { transform: translate(3px, -3px); }
            75% { transform: translate(-3px, -3px); }
            100% { transform: translate(0, 0); }
        }

        /* È°∂ÈÉ® HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            width: 100%;
            padding: 15px 20px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
            text-shadow: 0 0 5px var(--neon-blue);
            z-index: 20;
            pointer-events: none; /* ËÆ©‰∏ãÈù¢ÁöÑÁÇπÂáªÁ©øÈÄèÔºåÈô§‰∫ÜÊåâÈíÆ */
        }

        .hud-info {
            display: flex;
            gap: 20px;
            font-size: 1rem; 
            font-weight: bold;
            flex-grow: 1;
        }

        /* È°∂ÈÉ®Â∏∏È©ªÊåâÈíÆÁªÑ */
        .top-controls {
            display: flex;
            gap: 10px;
            pointer-events: auto; /* ÊÅ¢Â§çÊåâÈíÆ‰∫§‰∫í */
        }

        .icon-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
        }
        .icon-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        #grid-wrapper {
            position: relative;
            padding: 4px;
            border: 1px solid var(--cell-border-light);
            background: var(--grid-bg);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: margin 0.3s;
        }

        #grid {
            display: grid;
            border: 1px solid var(--cell-border-light);
            position: relative;
            z-index: 2;
        }

        #ray-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: screen; 
        }

        .cell {
            background-color: var(--cell-unrevealed);
            border: 1px solid #333;
            box-shadow: inset 1px 1px 0 rgba(255,255,255,0.05), inset -1px -1px 0 rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s;
            position: relative;
            font-size: 1.1rem;
            color: transparent; 
        }

        .cell.active {
            background-color: #333;
            box-shadow: inset 0 0 10px var(--neon-blue);
        }

        .cell.revealed {
            background-color: var(--cell-revealed);
            border: 1px solid #111;
            box-shadow: none;
            color: inherit; 
            cursor: default; 
        }
        
        .cell.marked::after {
            content: 'üõ°';
            color: var(--neon-green);
            text-shadow: 0 0 5px var(--neon-green);
            font-size: 0.8em;
            opacity: 0.8;
        }

        .cell[data-num="0"] { color: #222; }
        .cell[data-num="1"] { color: var(--neon-blue); text-shadow: 0 0 8px var(--neon-blue); }
        .cell[data-num="2"] { color: var(--neon-green); text-shadow: 0 0 8px var(--neon-green); }
        .cell[data-num="3"] { color: var(--neon-yellow); text-shadow: 0 0 8px var(--neon-yellow); }
        .cell[data-num="4"] { color: #ff00ff; text-shadow: 0 0 8px #ff00ff; }
        .cell[data-num="5"] { color: var(--neon-red); text-shadow: 0 0 8px var(--neon-red); }
        .cell[data-num="6"] { color: cyan; }
        .cell[data-num="7"] { color: white; }
        .cell[data-num="8"] { color: grey; }

        .cell.mine-flash {
            background-color: #fff !important;
            transition: background-color 0.05s;
            box-shadow: 0 0 20px #fff;
            z-index: 10;
        }

        .cell.mine {
            background-color: rgba(255, 0, 60, 0.2);
            border: 1px solid var(--neon-red);
            box-shadow: inset 0 0 10px rgba(255, 0, 60, 0.3);
            animation: pulse-border 1.5s infinite;
            color: var(--neon-red) !important;
            text-shadow: 0 0 8px var(--neon-red);
        }

        @keyframes pulse-border {
            0% { box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3); }
            50% { box-shadow: inset 0 0 15px rgba(255, 0, 60, 0.6); }
            100% { box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3); }
        }

        /* ÂìçÂ∫îÂºèÂ∑•ÂÖ∑Ê†è */
        #toolbar {
            position: absolute;
            z-index: 30;
            display: flex;
            gap: 15px;
            padding: 10px;
            pointer-events: auto;
        }

        /* Á´ñÂ±èÊ®°Âºè (Portrait): Â∑•ÂÖ∑Ê†èÂú®Â∫ïÈÉ® */
        @media (orientation: portrait) {
            #toolbar {
                bottom: 60px; /* ÁªôÂ∫ïÈÉ®ÊñáÂ≠óÁïôÁÇπÁ©∫Èó¥ */
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
            }
            #grid-wrapper {
                margin: 0;
                margin-bottom: 100px; /* Áªô‰∏ãÊñπÂ∑•ÂÖ∑Ê†èÁïôÁ©∫ */
            }
        }

        /* Ê®™Â±èÊ®°Âºè (Landscape): Â∑•ÂÖ∑Ê†èÂú®Âè≥‰æß */
        @media (orientation: landscape) {
            #toolbar {
                right: 20px;
                top: 50%;
                transform: translateY(-50%);
                flex-direction: column;
            }
            #grid-wrapper {
                margin-right: 80px; /* ÁªôÂè≥‰æßÂ∑•ÂÖ∑Ê†èÁïôÁ©∫ */
                margin-bottom: 0;
            }
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            color: #666;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: -2px 2px 10px rgba(0,0,0,0.5);
            touch-action: manipulation;
        }

        .tool-btn span { pointer-events: none; }

        .tool-btn.active {
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: scale(1.1);
        }

        .tool-btn#btn-mode-mark.active {
            background: rgba(0, 255, 102, 0.15);
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 15px rgba(0, 255, 102, 0.3);
        }

        #guide-text {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            text-shadow: 0 0 3px black;
            z-index: 20; 
            background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0));
            padding-bottom: 5px;
        }

        #menu-overlay, #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        h1 {
            color: var(--neon-blue);
            text-shadow: 0 0 15px var(--neon-blue);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-align: center;
        }

        .control-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 300px;
        }

        label {
            color: var(--neon-green);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            background: #333;
            height: 6px;
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--neon-blue);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-blue);
            border: 2px solid #fff;
        }

        .menu-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            font-size: 1.1rem;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .menu-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue);
        }

        .hidden { display: none !important; }

        #end-title { font-size: 2.5rem; margin-bottom: 20px; text-align: center;}
        .win { color: var(--neon-green); text-shadow: 0 0 20px var(--neon-green); }
        .lose { color: var(--neon-red); text-shadow: 0 0 20px var(--neon-red); }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <div id="game-container">
        <div id="hud">
            <div class="hud-info">
                <div>ÁõÆÊ†á: <span id="mines-left">0</span></div>
                <div>Áä∂ÊÄÅ: <span id="status-text" style="color:var(--neon-green)">Â∞±Áª™</span></div>
            </div>
            <div class="top-controls">
                <div class="icon-btn" id="btn-ingame-restart" title="ÈáçÂºÄ">‚Üª</div>
                <div class="icon-btn" id="btn-ingame-menu" title="ËèúÂçï">‚ò∞</div>
            </div>
        </div>
        
        <div id="grid-wrapper">
            <div id="grid"></div>
            <canvas id="ray-canvas"></canvas>
        </div>

        <div id="toolbar">
            <div class="tool-btn active" id="btn-mode-detonate" onclick="setMode('detonate')" title="ÂºïÁàÜÊ®°Âºè">
                <span>‚ö°</span>
            </div>
            <div class="tool-btn" id="btn-mode-mark" onclick="setMode('mark')" title="Ê†áËÆ∞Ê®°Âºè">
                <span>üõ°</span>
            </div>
        </div>

        <div id="guide-text">ÈïøÊåâÈõ∑Âå∫Âπ∂ÊªëÂä® > ÂøÖÈ°ªÂëΩ‰∏≠Èõ∑ÊâçËÉΩÂ≠òÊ¥ª</div>
    </div>

    <div id="menu-overlay">
        <h1>MINESEEKER</h1>
        <div class="control-group">
            <label>ÁΩëÊ†ºÂÆΩÂ∫¶: <span id="val-w">10</span></label>
            <input type="range" id="inp-w" min="8" max="20" value="10">
        </div>
        <div class="control-group">
            <label>ÁΩëÊ†ºÈ´òÂ∫¶: <span id="val-h">15</span></label>
            <input type="range" id="inp-h" min="8" max="25" value="15">
        </div>
        <div class="control-group">
            <label>Âú∞Èõ∑ÂØÜÂ∫¶: <span id="val-d">30%</span></label>
            <input type="range" id="inp-d" min="10" max="50" value="30">
        </div>
        <button class="menu-btn" id="btn-start">ÂêØÂä®ÂçèËÆÆ</button>
    </div>

    <div id="game-over-overlay" class="hidden">
        <h1 id="end-title">ËøûÊé•‰∏¢Â§±</h1>
        <p id="end-reason" style="color:white; margin-bottom:20px; text-align:center;">ÈÄªËæëÈîôËØØ</p>
        <button class="menu-btn" id="btn-restart">ÈáçÂêØÁ≥ªÁªü</button>
        <button class="menu-btn" id="btn-menu" style="margin-top: 10px; font-size: 0.8rem; padding: 10px 20px;">ËøîÂõûËèúÂçï</button>
    </div>

    <script>
        const CONFIG = {
            gridW: 10,
            gridH: 15,
            density: 0.3,
            cellSize: 35, 
            rayLength: 5, 
            colors: {
                blue: '#00f3ff',
                green: '#00ff66',
                red: '#ff003c',
                yellow: '#fcee0a',
                white: '#ffffff',
                purple: '#bc13fe'
            }
        };

        const AUDIO_CTX = new (window.AudioContext || window.webkitAudioContext)();

        let gridData = [];
        let totalMines = 0;
        let revealedMines = 0;
        let isFirstMove = true;
        let isGameOver = false;
        let currentMode = 'detonate'; 
        
        const rayCanvas = document.getElementById('ray-canvas');
        const rayCtx = rayCanvas.getContext('2d');
        let animationFrameId;
        let activeEffects = [];

        const gridEl = document.getElementById('grid');
        const hudMines = document.getElementById('mines-left');
        const hudStatus = document.getElementById('status-text');
        const guideText = document.getElementById('guide-text');

        let startCell = null;
        let isDragging = false;
        let dragLine = { x: 0, y: 0 };

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btn-mode-detonate').classList.toggle('active', mode === 'detonate');
            document.getElementById('btn-mode-mark').classList.toggle('active', mode === 'mark');
            
            if (mode === 'detonate') {
                guideText.textContent = "ÈïøÊåâÈõ∑Âå∫Âπ∂ÊªëÂä® > ÂøÖÈ°ªÂëΩ‰∏≠Èõ∑ÊâçËÉΩÂ≠òÊ¥ª";
                guideText.style.color = "#888";
            } else {
                guideText.textContent = "ÁÇπÂáªÊú™Áü•Âå∫Âüü > Ê†áËÆ∞ÊàñÂèñÊ∂àÂÆâÂÖ®Âå∫";
                guideText.style.color = "var(--neon-green)";
            }
            
            playSound('hover');
        }

        function playSound(type) {
            if (AUDIO_CTX.state === 'suspended') AUDIO_CTX.resume();
            const osc = AUDIO_CTX.createOscillator();
            const gainNode = AUDIO_CTX.createGain();
            osc.connect(gainNode);
            gainNode.connect(AUDIO_CTX.destination);

            const t = AUDIO_CTX.currentTime;

            if (type === 'hover') {
                osc.frequency.setValueAtTime(800, t);
                gainNode.gain.setValueAtTime(0.01, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.05);
            } else if (type === 'mark') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, t);
                gainNode.gain.setValueAtTime(0.05, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
            } else if (type === 'ray') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                gainNode.gain.setValueAtTime(0.15, t);
                gainNode.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t);
                osc.stop(t + 0.2);
            } else if (type === 'explode') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t);
                osc.stop(t + 0.4);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.start(t);
                osc.stop(t + 0.5);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2; 
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.04 + 0.02;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.gravity = 0.2; 
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
                this.size *= 0.95; 
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Shockwave {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = CONFIG.cellSize * 1.5;
                this.color = color;
                this.life = 1.0;
                this.decay = 0.08;
            }

            update() {
                this.radius += 3;
                this.life -= this.decay;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class RayEffect {
            constructor(startX, startY, dirX, dirY, lengthCells) {
                const cs = CONFIG.cellSize;
                this.sx = (startX + 0.5) * cs;
                this.sy = (startY + 0.5) * cs;
                this.ex = this.sx + (dirX * lengthCells * cs);
                this.ey = this.sy + (dirY * lengthCells * cs);
                this.life = 1.0;
                this.width = 15; 
                this.color = CONFIG.colors.blue;
                this.jitter = 0;
            }

            update() {
                this.life -= 0.08; 
                this.width *= 0.9;
                this.jitter = (Math.random() - 0.5) * 10; 
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                ctx.moveTo(this.sx, this.sy);
                ctx.lineTo(this.ex + this.jitter, this.ey + this.jitter);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = this.width * 0.4;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(this.sx, this.sy);
                ctx.lineTo(this.ex, this.ey);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.width;
                ctx.stroke();

                ctx.shadowBlur = 0; 
            }
        }

        function startRenderLoop() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            function loop() {
                rayCtx.clearRect(0, 0, rayCanvas.width, rayCanvas.height);
                
                for (let i = activeEffects.length - 1; i >= 0; i--) {
                    const effect = activeEffects[i];
                    effect.update();
                    effect.draw(rayCtx);
                    if (effect.life <= 0) {
                        activeEffects.splice(i, 1);
                    }
                }

                animationFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function spawnExplosion(cx, cy, color = CONFIG.colors.red) {
            const particleCount = 20; 
            const pixelX = (cx + 0.5) * CONFIG.cellSize;
            const pixelY = (cy + 0.5) * CONFIG.cellSize;
            for (let i = 0; i < particleCount; i++) {
                activeEffects.push(new Particle(pixelX, pixelY, color));
            }
            activeEffects.push(new Shockwave(pixelX, pixelY, color));
        }

        function spawnRay(x, y, dx, dy) {
            activeEffects.push(new RayEffect(x, y, dx, dy, CONFIG.rayLength));
        }

        function explodeNeighbors(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                        const neighbor = gridData[ny][nx];
                        if (!neighbor.isRevealed) {
                            neighbor.reveal();
                        }
                    }
                }
            }
        }

        function floodFill(x, y) {
            const dirs = [
                {x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}
            ];
            
            for (let dir of dirs) {
                const nx = x + dir.x;
                const ny = y + dir.y;
                
                if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                    const neighbor = gridData[ny][nx];
                    if (!neighbor.isRevealed && !neighbor.isMine && neighbor.neighborCount === 0) {
                        neighbor.reveal();
                    }
                }
            }
        }

        function revealRayPath(startX, startY, dirX, dirY) {
            for (let i = 1; i <= CONFIG.rayLength; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);
                if (tx < 0 || tx >= CONFIG.gridW || ty < 0 || ty >= CONFIG.gridH) break;
                
                const targetCell = gridData[ty][tx];
                if (!targetCell.isMine && !targetCell.isRevealed) {
                    targetCell.reveal();
                }
            }
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.isMine = false;
                this.isRevealed = false;
                this.isMarked = false;
                this.neighborCount = 0;
                this.element = document.createElement('div');
                this.element.className = 'cell';
                this.element.dataset.x = x;
                this.element.dataset.y = y;
            }

            toggleMark() {
                if (this.isRevealed) return;
                this.isMarked = !this.isMarked;
                this.element.classList.toggle('marked', this.isMarked);
                playSound('mark');
            }

            reveal() {
                if (this.isRevealed) return;
                
                this.isMarked = false;
                this.element.classList.remove('marked');
                
                this.isRevealed = true;
                this.element.classList.add('revealed');
                
                if (this.isMine) {
                    this.element.classList.add('mine');
                    this.element.textContent = '‚ò¢'; 
                    this.element.dataset.num = 'mine';
                    
                    this.element.classList.add('mine-flash');
                    setTimeout(() => this.element.classList.remove('mine-flash'), 150);
                    
                    revealedMines++;
                    playSound('explode');
                    spawnExplosion(this.x, this.y, CONFIG.colors.red);
                    
                    const container = document.getElementById('game-container');
                    container.classList.remove('shake');
                    void container.offsetWidth;
                    container.classList.add('shake');

                } else {
                    this.element.textContent = this.neighborCount; 
                    this.element.dataset.num = this.neighborCount;
                    
                    if (this.neighborCount === 0) {
                        floodFill(this.x, this.y);
                    } else {
                        spawnExplosion(this.x, this.y, 'rgba(0, 243, 255, 0.4)');
                    }
                }
                updateHUD();
            }
        }

        function initGame() {
            // Ê∏ÖÁêÜÂèØËÉΩÁöÑÊóßÂª∂Êó∂Êìç‰Ωú
            if (window.failTimeout) clearTimeout(window.failTimeout);
            window.failIntervals = window.failIntervals || [];
            window.failIntervals.forEach(id => clearTimeout(id));
            window.failIntervals = [];

            gridEl.innerHTML = '';
            gridData = [];
            revealedMines = 0;
            isFirstMove = true;
            isGameOver = false;
            activeEffects = [];
            hudStatus.textContent = "ÂæÖÂëΩ";
            hudStatus.style.color = "var(--neon-green)";
            setMode('detonate');

            // Êô∫ËÉΩËÆ°ÁÆóÂ∏ÉÂ±Ä
            const isLandscape = window.innerWidth > window.innerHeight;
            const margin = 10;
            const hudHeight = 70;
            const guideHeight = 40; 
            
            // Ê†πÊçÆÊñπÂêëÂà§Êñ≠Â∑•ÂÖ∑Ê†èÂç†Áî®ÁöÑÁ©∫Èó¥
            const toolbarW = isLandscape ? 70 : 0;
            const toolbarH = isLandscape ? 0 : 80;

            const availableWidth = window.innerWidth - margin - toolbarW;
            const availableHeight = window.innerHeight - hudHeight - guideHeight - margin - toolbarH;

            const sizeW = Math.floor(availableWidth / CONFIG.gridW);
            const sizeH = Math.floor(availableHeight / CONFIG.gridH);
            
            let size = Math.min(sizeW, sizeH, 50); 
            size = Math.max(size, 20);

            CONFIG.cellSize = size;
            
            const totalWidth = size * CONFIG.gridW;
            const totalHeight = size * CONFIG.gridH;
            
            gridEl.style.gridTemplateColumns = `repeat(${CONFIG.gridW}, ${size}px)`;
            gridEl.style.gridTemplateRows = `repeat(${CONFIG.gridH}, ${size}px)`;
            
            rayCanvas.width = totalWidth;
            rayCanvas.height = totalHeight;

            for (let y = 0; y < CONFIG.gridH; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.gridW; x++) {
                    const cell = new Cell(x, y);
                    gridEl.appendChild(cell.element);
                    row.push(cell);
                }
                gridData.push(row);
            }

            totalMines = Math.floor(CONFIG.gridW * CONFIG.gridH * CONFIG.density);
            updateHUD();
            startRenderLoop();
        }

        function generateMines(startX, startY) {
            gridData[startY][startX].isMine = true;
            let placed = 1;

            while (placed < totalMines) {
                const rx = Math.floor(Math.random() * CONFIG.gridW);
                const ry = Math.floor(Math.random() * CONFIG.gridH);
                
                if (!gridData[ry][rx].isMine) {
                    gridData[ry][rx].isMine = true;
                    placed++;
                }
            }
            
            calculateNumbers();
        }

        function calculateNumbers() {
            const directions = [
                {x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0},
                {x:-1, y:-1}, {x:1, y:-1}, {x:-1, y:1}, {x:1, y:1}
            ];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    let count = 0;
                    for (let dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (gridData[ny][nx].isMine) count++;
                        }
                    }
                    gridData[y][x].neighborCount = count;
                }
            }
        }

        function fireRay(startX, startY, dirX, dirY, delay = 0) {
            setTimeout(() => {
                if (isGameOver) return;
                
                playSound('ray');
                spawnRay(startX, startY, dirX, dirY);

                let hitMine = false;
                
                for (let i = 1; i <= CONFIG.rayLength; i++) {
                    const tx = startX + (dirX * i);
                    const ty = startY + (dirY * i);

                    if (tx < 0 || tx >= CONFIG.gridW || ty < 0 || ty >= CONFIG.gridH) break;

                    const targetCell = gridData[ty][tx];
                    
                    if (targetCell.isMine) {
                        if (!targetCell.isRevealed) {
                            targetCell.reveal();
                            explodeNeighbors(tx, ty);
                            fireRay(tx, ty, dirX, dirY, 120); 
                            hitMine = true;
                        }
                    } else {
                        targetCell.reveal();
                    }
                }
                checkWinCondition();
            }, delay);
        }

        function setupInput() {
            const getCellCoords = (e) => {
                const rect = gridEl.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const x = Math.floor((clientX - rect.left) / CONFIG.cellSize);
                const y = Math.floor((clientY - rect.top) / CONFIG.cellSize);
                return {x, y, clientX, clientY};
            };

            const startDrag = (e) => {
                if (isGameOver) return;
                if (e.type === 'touchstart') e.preventDefault();
                
                const coords = getCellCoords(e);
                if (coords.x >= 0 && coords.x < CONFIG.gridW && coords.y >= 0 && coords.y < CONFIG.gridH) {
                    const cell = gridData[coords.y][coords.x];
                    
                    if (cell.isRevealed) return; 

                    if (currentMode === 'mark') {
                        cell.toggleMark();
                        return; 
                    }

                    if (currentMode === 'detonate' && cell.isMarked) {
                        return; 
                    }

                    startCell = {x: coords.x, y: coords.y};
                    cell.element.classList.add('active');
                    isDragging = true;
                    dragLine = {x: coords.clientX, y: coords.clientY};
                    playSound('hover');
                }
            };

            const moveDrag = (e) => {
                if (!isDragging || currentMode === 'mark') return;
                e.preventDefault(); 
            };

            const endDrag = (e) => {
                if (currentMode === 'mark') return;
                if (!isDragging) return;
                
                const coords = e.changedTouches ? 
                    {clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY} : 
                    {clientX: e.clientX, clientY: e.clientY};

                const dx = coords.clientX - dragLine.x;
                const dy = coords.clientY - dragLine.y;
                
                if(startCell && gridData[startCell.y] && gridData[startCell.y][startCell.x]) {
                     gridData[startCell.y][startCell.x].element.classList.remove('active');
                }

                if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
                    const angle = Math.atan2(dy, dx);
                    const degree = angle * (180 / Math.PI);
                    const octant = Math.round(degree / 45);
                    
                    const dirs = [
                        {x:1, y:0}, {x:1, y:1}, {x:0, y:1}, {x:-1, y:1},
                        {x:-1, y:0}, {x:-1, y:-1}, {x:0, y:-1}, {x:1, y:-1}
                    ];
                    
                    let dirIndex = octant;
                    if (dirIndex < 0) dirIndex += 8;
                    dirIndex = dirIndex % 8;

                    const dir = dirs[dirIndex];
                    handleAction(startCell.x, startCell.y, dir.x, dir.y);
                }

                isDragging = false;
                startCell = null;
            };

            gridEl.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', moveDrag);
            window.addEventListener('mouseup', endDrag);

            gridEl.addEventListener('touchstart', startDrag, {passive: false});
            window.addEventListener('touchmove', moveDrag, {passive: false});
            window.addEventListener('touchend', endDrag);
        }

        function handleAction(x, y, dirX, dirY) {
            const cell = gridData[y][x];
            if (cell.isRevealed || cell.isMarked) return;

            if (isFirstMove) {
                generateMines(x, y);
                isFirstMove = false;
                hudStatus.textContent = "ÈìæÊé•Âª∫Á´ã";
            }

            if (cell.isMine) {
                if (!cell.isRevealed) {
                    cell.reveal();
                    explodeNeighbors(x, y);
                }
                fireRay(x, y, dirX, dirY);
            } else {
                cell.element.style.backgroundColor = "var(--neon-red)";
                spawnExplosion(x, y, CONFIG.colors.red);
                triggerChainFailure();
            }
        }

        function triggerChainFailure() {
            isGameOver = true;
            hudStatus.textContent = "Á≥ªÁªüÂ¥©Ê∫É";
            hudStatus.style.color = "var(--neon-red)";
            playSound('error');
            
            const hiddenMines = [];
            for(let y=0; y<CONFIG.gridH; y++) {
                for(let x=0; x<CONFIG.gridW; x++) {
                    if(gridData[y][x].isMine && !gridData[y][x].isRevealed) {
                        hiddenMines.push(gridData[y][x]);
                    }
                }
            }

            hiddenMines.sort(() => Math.random() - 0.5);

            // Âä®ÊÄÅÈó¥ÈöîËÆ°ÁÆó
            let interval = 300;
            if (hiddenMines.length > 10) {
                // Â¶ÇÊûúÈõ∑Â§ö‰∫é10‰∏™ÔºåÁ°Æ‰øùÂú®3000msÂÜÖÁÇ∏ÂÆå
                interval = 3000 / hiddenMines.length;
            }

            // Ê∏ÖÁêÜÊóßÁöÑÂÆöÊó∂Âô®Êï∞ÁªÑ
            window.failIntervals = [];

            hiddenMines.forEach((cell, index) => {
                const id = setTimeout(() => {
                    cell.element.classList.add('mine');
                    cell.element.textContent = '‚ò¢';
                    cell.element.classList.add('mine-flash');
                    setTimeout(() => cell.element.classList.remove('mine-flash'), 150);
                    
                    playSound('explode');
                    spawnExplosion(cell.x, cell.y, CONFIG.colors.red);
                    
                    const dirs = [
                        {x:0, y:-1}, {x:1, y:-1}, {x:1, y:0}, {x:1, y:1},
                        {x:0, y:1}, {x:-1, y:1}, {x:-1, y:0}, {x:-1, y:-1}
                    ];
                    dirs.forEach(d => {
                        spawnRay(cell.x, cell.y, d.x, d.y);
                        revealRayPath(cell.x, cell.y, d.x, d.y);
                    });

                }, index * interval);
                window.failIntervals.push(id);
            });

            const totalTime = hiddenMines.length * interval + 2000;
            window.failTimeout = setTimeout(() => {
                const overlay = document.getElementById('game-over-overlay');
                const title = document.getElementById('end-title');
                const reasonText = document.getElementById('end-reason');
                
                overlay.classList.remove('hidden');
                title.textContent = "ËøûÊé•‰∏¢Â§±";
                title.className = "lose";
                reasonText.textContent = "ÈÄªËæëÈìæË∑ØÂ¥©Ê∫É";
            }, totalTime);
        }

        function checkWinCondition() {
            if (revealedMines >= totalMines) {
                gameOver(true);
            }
        }

        function gameOver(win, reason) {
            if (isGameOver) return;
            if (!win) {
                triggerChainFailure();
                return;
            }
            
            isGameOver = true;
            const overlay = document.getElementById('game-over-overlay');
            const title = document.getElementById('end-title');
            const reasonText = document.getElementById('end-reason');
            
            title.textContent = "Á≥ªÁªüÂáÄÂåñÂÆåÊàê";
            title.className = "win";
            reasonText.textContent = "ÊâÄÊúâÂ®ÅËÉÅÂ∑≤Ê∂àÈô§";
            hudStatus.textContent = "ËÉúÂà©";
            playSound('hover'); 
            
            setTimeout(() => {
                overlay.classList.remove('hidden');
            }, 2000);
        }

        function updateHUD() {
            hudMines.textContent = `${totalMines - revealedMines}`;
        }

        const menuOverlay = document.getElementById('menu-overlay');
        const inpW = document.getElementById('inp-w');
        const inpH = document.getElementById('inp-h');
        const inpD = document.getElementById('inp-d');
        
        [inpW, inpH, inpD].forEach(el => {
            el.addEventListener('input', () => {
                document.getElementById(`val-${el.id.split('-')[1]}`).textContent = 
                    el.id === 'inp-d' ? el.value + '%' : el.value;
            });
        });

        document.getElementById('btn-start').addEventListener('click', () => {
            CONFIG.gridW = parseInt(inpW.value);
            CONFIG.gridH = parseInt(inpH.value);
            CONFIG.density = parseInt(inpD.value) / 100;
            menuOverlay.classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-restart').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-menu').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            menuOverlay.classList.remove('hidden');
        });

        // Ê∏∏ÊàèÂÜÖËèúÂçïÊåâÈíÆ‰∫ã‰ª∂
        document.getElementById('btn-ingame-restart').addEventListener('click', () => {
            initGame();
        });

        document.getElementById('btn-ingame-menu').addEventListener('click', () => {
            menuOverlay.classList.remove('hidden');
        });

        // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñ‰ª•ÈáçÊñ∞ËÆ°ÁÆóÂ∏ÉÂ±ÄÔºàÂèØÈÄâÔºåÁÆÄÂçïËµ∑ËßÅÁõ¥Êé•ÈáçÁΩÆÂèØËÉΩÊõ¥Â•ΩÔºåÊàñËÄÖÂä®ÊÄÅË∞ÉÊï¥ grid-wrapperÔºâ
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Âè™ÊúâÂú®ÈùûÊ∏∏ÊàèËøõË°å‰∏≠ÊàñËÄÖ‰Ω†ÊÉ≥ÊîØÊåÅÂä®ÊÄÅË∞ÉÊï¥Êó∂ÊâçË∞ÉÁî®
                // ËøôÈáå‰∏∫‰∫Ü‰ΩìÈ™åÊµÅÁïÖÔºåÂª∫ËÆÆÁî®Êà∑ÊâãÂä®ÈáçÂºÄÔºåÊàñËÄÖÂè™ÈáçÊñ∞ËÆ°ÁÆó grid Â∞∫ÂØ∏ËÄå‰∏çÊ∏ÖÁ©∫Êï∞ÊçÆ
                // ÁÆÄÂçïÂ§ÑÁêÜÔºöÈáçÊñ∞ÂàùÂßãÂåñ
                if (!isGameOver && revealedMines === 0) {
                    initGame();
                }
            }, 500);
        });

        setupInput();

    </script>
</body>
</html>
