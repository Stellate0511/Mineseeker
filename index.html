<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mineseeker: 逆转版扫雷</title>
    <style>
        :root {
            --bg-color: #050505;
            --grid-bg: #000000;
            --cell-unrevealed: #1a1a1a;
            --cell-revealed: #050505;
            --cell-border-light: #333;
            --cell-border-dark: #111;

            --neon-blue: #00f3ff;
            --neon-red: #ff003c;
            --neon-green: #00ff66;
            --neon-yellow: #fcee0a;
            --text-main: #e0e0e0;
        }

        @font-face {
            font-family: 'Cyber';
            src: local('Courier New');
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #game-container {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .shake {
            animation: shake-anim 0.2s ease-in-out;
        }

        @keyframes shake-anim {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-3px, 3px);
            }

            50% {
                transform: translate(3px, -3px);
            }

            75% {
                transform: translate(-3px, -3px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* 顶部 HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            width: 100%;
            padding: 15px 20px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0));
            text-shadow: 0 0 5px var(--neon-blue);
            z-index: 20;
            pointer-events: none;
        }

        /* === 修改 .hud-info === */
        .hud-info {
            display: flex;
            gap: 20px;
            font-size: 1rem;
            font-weight: bold;
            flex-grow: 1;
            overflow: hidden;
            /* 防止溢出 */
            flex-wrap: wrap;
            min-width: 0;
        }

        /* === 针对内部每一个小项的样式 === */
        .hud-info div {
            /* 强制不换行，让 "状态：就绪" 永远连在一起 */
            white-space: nowrap;
        }

        /* 窄屏：把第3项（状态）独占一行 */
        @media (max-width: 420px) {
            .hud-info {
                gap: 8px;
                font-size: 0.85rem;
            }

            .hud-info>div:nth-child(3) {
                flex-basis: 100%;
            }
        }

        /* === 新增：手机竖屏下的适配 === */
        @media (max-width: 480px) {
            .hud-info {
                /* 手机屏幕窄，减小间距 */
                gap: 8px;
                /* 稍微减小字体，确保三个数据能排成一行 */
                font-size: 0.85rem;
            }

            /* 如果屏幕特别小（如 iPhone SE），稍微压缩一下顶部按钮的边距 */
            #hud {
                padding: 10px 10px;
            }
        }

        /* 顶部常驻按钮组 */
        .top-controls {
            display: flex;
            gap: 10px;
            pointer-events: auto;
            /* 恢复按钮交互 */
        }

        .icon-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        #grid-wrapper {
            position: relative;
            padding: 4px;
            border: 1px solid var(--cell-border-light);
            background: var(--grid-bg);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: margin 0.3s;
            /* 这里的 position: relative 不再限制 canvas，因为 canvas 已经是 fixed 了 */
        }

        #grid {
            display: grid;
            border: 1px solid var(--cell-border-light);
            position: relative;
            z-index: 2;
        }

        #ray-canvas {
            position: fixed;
            /* 改为 fixed 全屏 */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            /* 关键：让鼠标点击能穿透它点到底下的游戏 */
            z-index: 50;
            /* 确保它在网格之上，但在弹窗(z-index:100)之下 */
            mix-blend-mode: screen;
            /* 保持原有的混合模式 */

            will-change: transform, opacity;
            transform: translateZ(0);
        }

        .cell {
            background-color: var(--cell-unrevealed);
            border: 1px solid #333;
            box-shadow: inset 1px 1px 0 rgba(255, 255, 255, 0.05), inset -1px -1px 0 rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s;
            position: relative;
            font-size: clamp(8px, calc(var(--cs, 30px) * 0.55), 18px);
            color: transparent;
            transition: background-color 0.2s ease-out, color 0.2s ease-out;
        }

        .cell.active {
            background-color: #333;
            box-shadow: inset 0 0 10px var(--neon-blue);
        }

        .cell.revealed {
            background-color: var(--cell-revealed);
            border: 1px solid #111;
            box-shadow: none;
            color: inherit;
            cursor: default;
            transition: background-color 0.3s ease-out;
        }

        .cell.marked::after {
            content: '';
            /* 清空文字内容 */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* 绝对定位居中 */

            width: 60%;
            /* 控制盾牌大小，相对于格子 */
            height: 60%;

            /* 核心技术：使用 CSS 变量作为背景色 */
            background-color: var(--neon-green);

            /* 核心技术：使用 SVG 作为遮罩来塑造形状 */
            /* 这里使用的是选项 B (棱角盾牌) 的 URL 编码数据 */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            /* 使用 box-shadow 代替 text-shadow 来制造发光效果 */
            box-shadow: 0 0 10px var(--neon-green);

            opacity: 0.9;
            pointer-events: none;
            /* 确保鼠标事件穿透图标打到格子上 */
            z-index: 5;
        }

        .cell[data-num="0"] {
            color: #222;
        }

        .cell[data-num="1"] {
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
        }

        .cell[data-num="2"] {
            color: var(--neon-green);
            text-shadow: 0 0 8px var(--neon-green);
        }

        .cell[data-num="3"] {
            color: var(--neon-yellow);
            text-shadow: 0 0 8px var(--neon-yellow);
        }

        .cell[data-num="4"] {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }

        .cell[data-num="5"] {
            color: var(--neon-red);
            text-shadow: 0 0 8px var(--neon-red);
        }

        .cell[data-num="6"] {
            color: cyan;
        }

        .cell[data-num="7"] {
            color: white;
        }

        .cell[data-num="8"] {
            color: grey;
        }

        .cell.mine-flash {
            background-color: #fff !important;
            transition: background-color 0.05s;
            box-shadow: 0 0 20px #fff;
            z-index: 10;
        }

        .cell.mine {
            background-color: rgba(255, 0, 60, 0.2);
            border: 1px solid var(--neon-red);
            box-shadow: inset 0 0 10px rgba(255, 0, 60, 0.3);
            animation: pulse-border 1.5s infinite;
            color: var(--neon-red) !important;
            text-shadow: 0 0 8px var(--neon-red);
        }

        @keyframes pulse-border {
            0% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }

            50% {
                box-shadow: inset 0 0 15px rgba(255, 0, 60, 0.6);
            }

            100% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }
        }

        /* 响应式工具栏 */
        #toolbar {
            position: fixed;
            z-index: 30;
            display: flex;
            gap: 15px;
            padding: 10px;
            pointer-events: auto;
        }

        /* 竖屏模式 (Portrait): 工具栏在底部 */
        @media (orientation: portrait) {
            #toolbar {
                bottom: calc(60px + env(safe-area-inset-bottom));
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
            }

            /* === PATCH: 不再用 margin-bottom 推 grid === */
            #grid-wrapper {
                margin: 0 !important;
            }
        }

        /* 横屏模式 (Landscape): 工具栏在右侧 */
        @media (orientation: landscape) {
            #toolbar {
                right: calc(20px + env(safe-area-inset-right));
                top: 50%;
                transform: translateY(-50%);
                flex-direction: column;
            }

            /* === PATCH: 不再用 margin-right 推 grid === */
            #grid-wrapper {
                margin: 0 !important;
            }
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #666;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: -2px 2px 10px rgba(0, 0, 0, 0.5);
            touch-action: manipulation;
        }

        .tool-btn span {
            pointer-events: none;
        }

        .tool-btn.active {
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: scale(1.1);
        }

        .tool-btn#btn-mode-mark.active {
            background: rgba(0, 255, 102, 0.15);
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 15px rgba(0, 255, 102, 0.3);
        }

        #btn-mode-mark span {
            display: inline-block;
            width: 28px;
            /* 设置图标宽度 */
            height: 28px;
            /* 设置图标高度 */

            /* 核心：让背景色继承父级按钮的颜色 (灰色或霓虹绿) */
            background-color: currentColor;

            /* 使用与格子标记相同的 SVG 遮罩 */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            pointer-events: none;
            /* 保持穿透 */
        }

        #guide-text {
            position: fixed;
            bottom: calc(12px + env(safe-area-inset-bottom));
            left: 0;
            right: 0;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            text-shadow: 0 0 3px black;
            z-index: 20;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0));
            padding-bottom: 0;
        }

        #menu-overlay,
        #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #menu-overlay {
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            /* 覆盖 body 的 touch-action:none，让菜单能滚动 */
            justify-content: flex-start;
            /* 避免内容超高时“居中”导致上下都被挤没 */
            padding-top: calc(80px + env(safe-area-inset-top));
            padding-bottom: calc(24px + env(safe-area-inset-bottom));
            box-sizing: border-box;
        }

        h1 {
            color: var(--neon-blue);
            text-shadow: 0 0 15px var(--neon-blue);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-align: center;
        }

        .control-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 300px;
        }

        label {
            color: var(--neon-green);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: #333;
            height: 6px;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--neon-blue);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-blue);
            border: 2px solid #fff;
        }

        .hidden {
            display: none !important;
        }

        #end-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .win {
            color: var(--neon-green);
            text-shadow: 0 0 20px var(--neon-green);
        }

        .lose {
            color: var(--neon-red);
            text-shadow: 0 0 20px var(--neon-red);
        }

        /* === 计时器样式 === */
        #timer-display {
            font-family: 'Cyber', monospace;
            color: var(--neon-blue);
            min-width: 60px;
            display: inline-block;
        }

        /* === 全新的结算卡片样式 === */
        .result-card {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 0, 0, 0.8);
            padding: 2px;
            /* 给内边框留空 */
            width: 90%;
            max-width: 400px;
            position: relative;
            backdrop-filter: blur(10px);
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 动画激活状态 */
        #game-over-overlay:not(.hidden) .result-card {
            transform: scale(1);
            opacity: 1;
        }

        .card-header {
            background: rgba(0, 243, 255, 0.1);
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid #333;
            position: relative;
            overflow: hidden;
        }

        .card-header h2 {
            margin: 0;
            font-size: 1.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* 扫描线动画 */
        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--neon-blue);
            opacity: 0.5;
            animation: scan-down 2s linear infinite;
        }

        @keyframes scan-down {
            0% {
                top: 0%;
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                top: 100%;
                opacity: 0;
            }
        }

        .card-body {
            padding: 20px 30px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            border-bottom: 1px dashed #333;
            padding-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        .stat-value {
            color: var(--text-main);
            font-weight: bold;
            font-family: 'Cyber', monospace;
            font-size: 1.1rem;
        }

        .flavor-text {
            text-align: center;
            margin-top: 20px;
            color: #888;
            font-style: italic;
            font-size: 0.9rem;
        }

        .card-actions {
            padding: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        /* 胜利时的卡片配色变种 */
        .result-card.win-theme {
            border-color: var(--neon-green);
            box-shadow: 0 0 30px rgba(0, 255, 102, 0.15);
        }

        .result-card.win-theme .card-header {
            background: rgba(0, 255, 102, 0.1);
        }

        .result-card.win-theme .scan-line {
            background: var(--neon-green);
        }

        /* 失败时的卡片配色变种 */
        .result-card.lose-theme {
            border-color: var(--neon-red);
            box-shadow: 0 0 30px rgba(255, 0, 60, 0.15);
        }

        .result-card.lose-theme .card-header {
            background: rgba(255, 0, 60, 0.1);
        }

        .result-card.lose-theme .scan-line {
            background: var(--neon-red);
        }


        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 110;
            /* 比 menu/gameover 更高也没问题 */
        }

        /* === 修改 .tutorial-card：增加弹性布局和最大高度 === */
        .tutorial-card {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 0, 0, 0.8);
            padding: 2px;
            /* 保持原有的 padding */
            width: 92%;
            max-width: 560px;
            backdrop-filter: blur(10px);

            /* --- 新增修复代码 --- */
            display: flex;
            /* 开启 Flex 布局 */
            flex-direction: column;
            /* 垂直排列 */
            max-height: 85vh;
            max-height: 85dvh;
            /* 限制最大高度为视口高度的 85% */
            overflow: hidden;
            /* 防止卡片自身溢出 */
        }

        /* === 修改 .card-body：允许内部滚动 === */
        .tutorial-card .card-body {
            /* 继承原有的 padding: 20px 30px; 但建议在手机上缩小一点 */
            padding: 20px;

            /* --- 新增修复代码 --- */
            overflow-y: auto;
            /* 允许垂直滚动 */
            flex: 1;
            /* 占据剩余空间 */
            min-height: 0;
            /* Firefox Flex 滚动修复 */
            -webkit-overflow-scrolling: touch;
            /* iOS 平滑滚动 */
        }

        /* === 新增：防止标题和底部按钮被压缩 === */
        .tutorial-card .card-header,
        .tutorial-card .card-actions {
            flex-shrink: 0;
            /* 禁止压缩头部和底部 */
            background: rgba(10, 10, 15, 0.95);
            /* 加深背景防止文字透视重叠 */
            z-index: 2;
        }

        /* 针对手机横屏的额外优化 */
        @media (max-height: 500px) {
            .tutorial-card {
                max-height: 95vh;
                max-height: 95dvh;
                /* 横屏时利用更多高度 */
            }

            .tutorial-card .card-body {
                padding: 10px 20px;
            }
        }

        .tutorial-section-title {
            color: var(--neon-green);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }

        .tutorial-grid {
            display: grid;
            grid-template-columns: 92px 1fr 1fr;
            gap: 8px 12px;
            align-items: start;
        }

        .tutorial-col-head {
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
            font-weight: bold;
            font-size: 0.9rem;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }

        .tutorial-col-head:nth-child(1) {
            grid-column: 2 / 3;
        }

        .tutorial-col-head:nth-child(2) {
            grid-column: 3 / 4;
        }

        .tutorial-label {
            color: #666;
            font-size: 0.85rem;
            padding-top: 4px;
            border-bottom: 1px dashed #222;
        }

        .tutorial-item {
            color: var(--text-main);
            font-size: 0.9rem;
            line-height: 1.35;
            border-bottom: 1px dashed #222;
            padding-bottom: 6px;
        }

        @media (max-width: 420px) {
            .tutorial-grid {
                grid-template-columns: 78px 1fr 1fr;
                gap: 6px 10px;
            }

            .tutorial-item {
                font-size: 0.85rem;
            }
        }

        /* --- 左上角头像挂件 (窗口内) --- */
        #profile-link {
            position: fixed;
            top: calc(12px + env(safe-area-inset-top));
            left: calc(12px + env(safe-area-inset-left));
            /* 调整到窗口内部左上角的合适位置 */
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            /* 稍微缩进一点间距 */
            text-decoration: none;
            /* 确保在启动屏幕(z-index:100)之上 */
            z-index: 120;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        #profile-link:hover {
            filter: brightness(1.2);
        }

        #profile-link:hover img {
            box-shadow: 0 0 20px #00f3ff;
            transform: scale(1.05) rotate(5deg);
            /* 增加一点点旋转动感 */
        }

        #profile-link img {
            width: 45px;
            /* 稍微缩小一点点以适应内部空间 */
            height: 45px;
            /* 核心修改：圆形蒙版 */
            border-radius: 50%;
            border: 2px solid #00f3ff;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            background: #000;
            object-fit: cover;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .profile-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .profile-name {
            color: #e0fbfc;
            font-size: 0.9rem;
            /* 字体稍微减小适配 */
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
            font-family: 'Courier New', monospace;
        }

        .profile-role {
            color: #005f73;
            font-size: 0.6rem;
            letter-spacing: 2px;
            font-weight: bold;
        }

        select {
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            outline: none;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);

            border-radius: 0;
            background-clip: padding-box;
        }

        select:hover {
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
        }

        select option {
            background: #000;
            color: var(--neon-blue);
        }

        /* 包裹滑块的容器，用于整体隐藏 */
        #custom-settings {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 调整头像位置，避免被终端挡住 */
        #profile-link {
            top: 15px;
            left: 15px;
        }

        /* 1. 终端主容器 */
        .menu-terminal {
            background: rgba(5, 5, 10, 0.85);
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 30px rgba(0, 0, 0, 0.8);
            padding: 30px;
            width: 90%;
            max-width: 800px;
            /* 限制最大宽度，大屏更精致 */
            backdrop-filter: blur(10px);
            position: relative;
            /* 切角效果 */
            clip-path: polygon(0 0,
                    100% 0,
                    100% calc(100% - 20px),
                    calc(100% - 20px) 100%,
                    0 100%);
        }

        /* 终端四角装饰 (伪元素实现) */
        .menu-terminal::before,
        .menu-terminal::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            border: 2px solid var(--neon-blue);
            pointer-events: none;
        }

        .menu-terminal::before {
            top: 0;
            left: 0;
            border-right: none;
            border-bottom: none;
        }

        .menu-terminal::after {
            bottom: 0;
            right: 0;
            border-left: none;
            border-top: none;
        }

        /* 2. 头部区域 */
        .menu-header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        /* 覆盖原有的 h1 样式 */
        .menu-header h1 {
            margin: 0 0 10px 0;
            font-size: 3rem;
            letter-spacing: 8px;
            text-shadow: 0 0 20px var(--neon-blue);
        }

        .terminal-subtitle {
            color: var(--neon-green);
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        .deco-slash {
            color: #444;
            margin: 0 5px;
        }

        .header-deco-line {
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            margin-top: 15px;
            opacity: 0.5;
        }

        /* 3. 主体区域（双栏布局） */
        .menu-body {
            display: grid;
            grid-template-columns: 1fr 1fr;
            /* 大屏双栏 */
            gap: 25px;
            margin-bottom: 30px;
        }

        /* 4. 通用面板样式 */
        .cyber-panel {
            background: rgba(0, 243, 255, 0.03);
            border: 1px solid rgba(0, 243, 255, 0.3);
            padding: 20px;
            position: relative;
            min-height: 220px;
            /* 保证两边高度大致平衡 */
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            margin: 0 0 20px 0;
            color: var(--neon-blue);
            font-size: 1.1rem;
            letter-spacing: 1px;
            border-bottom: 1px dashed rgba(0, 243, 255, 0.2);
            padding-bottom: 10px;
        }

        .deco-marker {
            color: var(--neon-green);
            margin-right: 8px;
            font-size: 0.8rem;
        }

        /* 修改 control-group 以适应面板 */
        .control-group.wide {
            width: 100%;
            max-width: none;
            margin: 15px 0;
            align-items: flex-start;
            /* label 左对齐 */
        }

        /* 强化 select 样式 */
        select {
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: inset 0 0 10px rgba(0, 243, 255, 0.1);
            padding: 10px;
            font-size: 1rem;
            transition: all 0.3s;
        }

        select:hover,
        select:focus {
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            background: rgba(0, 20, 30, 1);
        }

        /* 协议描述文本 */
        .terminal-text {
            margin-top: auto;
            /* 推到底部 */
            color: #888;
            font-size: 0.9rem;
            border-top: 1px solid #222;
            padding-top: 15px;
            text-align: left;
            line-height: 1.5;
        }

        /* 高亮数值 */
        .val-highlight {
            color: var(--neon-blue);
            font-weight: bold;
            margin-left: 5px;
            text-shadow: 0 0 5px var(--neon-blue);
        }

        /* 参数锁定时的占位动画 */
        #parameter-locked {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #444;
            font-family: 'Cyber', monospace;
        }

        #custom-settings.hidden+#parameter-locked {
            display: flex;
            /* 当自定义设置隐藏时，显示占位符 */
        }

        #parameter-locked {
            display: none;
            /* 默认隐藏 */
        }

        .blink-text {
            animation: blink 1.5s infinite;
            color: var(--neon-green);
            opacity: 0.7;
            letter-spacing: 1px;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 0.7;
            }

            50% {
                opacity: 0.2;
            }
        }

        .data-stream-deco {
            width: 80%;
            height: 2px;
            background: repeating-linear-gradient(90deg, #444 0%, #444 5%, transparent 5%, transparent 10%);
            margin-top: 15px;
            animation: data-scroll 2s linear infinite;
            opacity: 0.3;
        }

        @keyframes data-scroll {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 50px 0;
            }
        }

        /* 5. 底部操作区 */
        .menu-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }

        .menu-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            font-size: 1.1rem;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .menu-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue);

        }

        /* 强化按钮样式 */
        .menu-btn {
            margin-top: 0;
            /* 移除旧 margin */
            flex: 1;
            /* 按钮均分宽度 */
            max-width: 240px;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        /* 主要按钮 (启动) - 更大更亮 */
        .primary-btn {
            background: rgba(0, 243, 255, 0.15);
            font-size: 1.2rem;
            padding: 15px 30px;
            border-width: 2px;
            font-weight: bold;
        }

        .primary-btn:hover {
            background: var(--neon-blue);
            box-shadow: 0 0 40px var(--neon-blue);
        }

        /* 次要按钮 (教程) */
        .secondary-btn {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        @media (max-width: 640px) {
            .menu-terminal {
                width: calc(100% - 24px);
                padding: 16px;
                border: 0;
                clip-path: none;
            }

            .menu-terminal::before,
            .menu-terminal::after {
                display: none;
            }

            .menu-header h1 {
                font-size: 2.2rem;
            }

            .menu-body {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .cyber-panel {
                min-height: auto;
                padding: 15px;
            }

            .panel-title {
                margin-bottom: 15px;
            }

            .menu-actions {
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 12px;
            }

            .menu-btn {
                max-width: none;
                flex: 1 1 0;
                min-width: 0;
                padding: 12px 10px;
            }

            .primary-btn {
                font-size: 1.05rem;
            }
        }

        /* 横屏但高度不够：整体轻微缩小，尽量不出现滚动 */
        @media (orientation: landscape) and (max-height: 700px) {
            .menu-terminal {
                transform: scale(0.92);
                transform-origin: top center;
            }

            /* 额外收紧一些“高度杀手” */
            .menu-header {
                margin-bottom: 18px;
            }

            .menu-body {
                margin-bottom: 18px;
                gap: 16px;
            }

            .cyber-panel {
                padding: 12px;
            }

            .panel-title {
                margin: 0 0 12px 0;
                padding-bottom: 8px;
            }
        }

        /* 更极端的矮横屏（分屏/小平板）：再缩一点点 */
        @media (orientation: landscape) and (max-height: 580px) {
            .menu-terminal {
                transform: scale(0.86);
            }
        }

        @media (min-height: 820px) {
            #menu-overlay {
                justify-content: center;
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
            }
        }

        /* ================================
            Cyber Scrollbar（菜单 & 教程）
        ================================ */

        /* WebKit 系（Chrome / Safari / iOS / Edge） */
        #menu-overlay::-webkit-scrollbar,
        .tutorial-card .card-body::-webkit-scrollbar {
            width: 8px;
        }

        #menu-overlay::-webkit-scrollbar-track,
        .tutorial-card .card-body::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.4);
            border-left: 1px solid rgba(0, 243, 255, 0.15);
        }

        #menu-overlay::-webkit-scrollbar-thumb,
        .tutorial-card .card-body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg,
                    rgba(0, 243, 255, 0.9),
                    rgba(0, 243, 255, 0.4));
            border-radius: 6px;
            box-shadow:
                0 0 8px rgba(0, 243, 255, 0.6),
                inset 0 0 6px rgba(255, 255, 255, 0.25);
        }

        #menu-overlay::-webkit-scrollbar-thumb:hover,
        .tutorial-card .card-body::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 243, 255, 1);
        }

        /* Firefox（退化但干净） */
        #menu-overlay,
        .tutorial-card .card-body {
            scrollbar-width: thin;
            scrollbar-color: var(--neon-blue) rgba(0, 0, 0, 0.4);
        }
    </style>
</head>

<body>
    <div class="scanlines"></div>

    <div id="game-container">
        <div id="hud">
            <div class="hud-info">
                <div>目标: <span id="mines-left">0</span></div>
                <div>时间: <span id="timer-display">00:00</span></div>
                <div>状态: <span id="status-text" style="color:var(--neon-green)">就绪</span></div>
            </div>
            <div class="top-controls">
                <div class="icon-btn" id="btn-ingame-tutorial" title="教程">?</div>
                <div class="icon-btn" id="btn-ingame-restart" title="重开">↻</div>
                <div class="icon-btn" id="btn-ingame-menu" title="菜单">☰</div>
            </div>
        </div>

        <div id="game-over-overlay" class="hidden">
            <div class="result-card">
                <div class="card-header">
                    <h2 id="end-title">MISSION COMPLETE</h2>
                    <div class="scan-line"></div>
                </div>

                <div class="card-body">
                    <div class="stat-row">
                        <span class="stat-label">耗时</span>
                        <span class="stat-value" id="end-time">00:00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">难度</span>
                        <span class="stat-value" id="end-difficulty">NORMAL</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">完成度</span>
                        <span class="stat-value" id="end-percentage">100%</span>
                    </div>

                    <p id="end-reason" class="flavor-text">所有威胁已消除</p>
                </div>

                <div class="card-actions">
                    <button class="menu-btn" id="btn-restart">重启系统</button>
                    <button class="menu-btn secondary" id="btn-menu">返回菜单</button>
                </div>
            </div>
        </div>

        <div id="grid-wrapper">
            <div id="grid"></div>
        </div>

        <canvas id="ray-canvas"></canvas>

        <div id="guide-text">点击标记安全区<br>从格子拖动（八方向）引爆隐藏地雷</div>
    </div>

    <div id="menu-overlay">
        <a id="profile-link" href="/">
            <img src="/avatar.jpg" alt="Avatar">
            <div class="profile-info">
                <span class="profile-name">回到主页</span>
                <span class="profile-role">状态：已连接</span>
            </div>
        </a>

        <div class="menu-terminal">
            <div class="menu-header">
                <h1>MINESEEKER</h1>
                <div class="terminal-subtitle">
                    <span class="deco-slash">//</span> 战术寻雷系统接入终端 <span class="deco-slash">//</span>
                </div>
                <div class="header-deco-line"></div>
            </div>

            <div class="menu-body">
                <div class="cyber-panel protocol-panel">
                    <h3 class="panel-title">
                        <span class="deco-marker">►</span> 协议装载
                    </h3>
                    <div class="control-group wide">
                        <select id="difficulty-select">
                            <option value="normal">普通协议</option>
                            <option value="enhanced">增强协议</option>
                            <option value="ultimate">终极协议</option>
                            <option value="custom">自定义参数</option>
                        </select>
                    </div>
                    <div id="protocol-desc" class="flavor-text terminal-text">
                        标准寻雷任务配置。适用于初步勘探。
                    </div>
                </div>

                <div class="cyber-panel parameter-panel">
                    <h3 class="panel-title">
                        <span class="deco-marker">►</span> 参数校准
                    </h3>

                    <div id="custom-settings" class="hidden">
                        <div class="control-group wide">
                            <label>网格宽度: <span id="val-w" class="val-highlight">10</span></label>
                            <input type="range" id="inp-w" min="8" max="32" value="10">
                        </div>
                        <div class="control-group wide">
                            <label>网格高度: <span id="val-h" class="val-highlight">15</span></label>
                            <input type="range" id="inp-h" min="8" max="32" value="15">
                        </div>
                        <div class="control-group wide">
                            <label>地雷密度: <span id="val-d" class="val-highlight">30%</span></label>
                            <input type="range" id="inp-d" min="25" max="75" value="30" step="5">
                        </div>
                    </div>

                    <div id="parameter-locked">
                        <div class="locked-status">
                            <span class="blink-text">>> 参数已锁定，等待执行 <<< </span>
                        </div>
                        <div class="data-stream-deco"></div>
                    </div>
                </div>
            </div>

            <div class="menu-actions">
                <button class="menu-btn primary-btn" id="btn-start">启动协议</button>
                <button class="menu-btn secondary-btn" id="btn-tutorial">作战指南</button>
            </div>
        </div>
    </div>

    <div id="tutorial-overlay" class="hidden">
        <div class="tutorial-card">
            <div class="card-header">
                <h2>HOW TO PLAY</h2>
                <div class="scan-line"></div>
            </div>

            <div class="card-body">
                <div class="tutorial-section-title">Minesweeper vs. Mineseeker</div>

                <div class="tutorial-grid">
                    <div class="tutorial-col-head">扫雷 / MINESWEEPER</div>
                    <div class="tutorial-col-head">找雷 / MINESEEKER</div>

                    <div class="tutorial-label">目标</div>
                    <div class="tutorial-item">找出地雷 / 开完安全格</div>
                    <div class="tutorial-item"><b>揭示所有地雷的位置</b></div>

                    <div class="tutorial-label">失败</div>
                    <div class="tutorial-item">点到雷 = 失败</div>
                    <div class="tutorial-item"><b>起爆点选到非雷 = 失败</b></div>

                    <div class="tutorial-label">开局</div>
                    <div class="tutorial-item">第一下必安全</div>
                    <div class="tutorial-item"><b>第一下必是雷</b>（直接从任意点拖动开始）</div>

                    <div class="tutorial-label">操作</div>
                    <div class="tutorial-item">点击揭开 / 插旗</div>
                    <div class="tutorial-item"><b>按住并朝八方向拖动</b>发射射线；右键/标记模式可标记</div>

                    <div class="tutorial-label">引爆规则</div>
                    <div class="tutorial-item">爆炸后游戏结束</div>
                    <div class="tutorial-item">
                        <b>引爆→冲击波→射线</b><br>
                        ① 揭示周围8格<br>
                        ② 射线沿拖动方向穿透<b>至多4格未揭示格</b>（加上①则路径至少5格）<br>
                        ③ 射线命中未揭示地雷会朝同方向引爆，造成连锁反应</b><br>
                    </div>

                    <div class="tutorial-label">数字</div>
                    <div class="tutorial-item">周围8格雷数</div>
                    <div class="tutorial-item">周围8格雷数</div>
                </div>

                <p class="flavor-text" style="margin-top:14px;">
                    省流：<b>拖动发射射线；射线起点必须是隐藏地雷；把所有雷都揭示就赢。</b>
                </p>
            </div>

            <div class="card-actions">
                <button class="menu-btn" id="btn-tutorial-back">返回</button>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            gridW: 10,
            gridH: 15,
            density: 0.3,
            cellSize: 35,
            rayLength: 2,
            penetrationLimit: 4, // 最大穿透未揭开格子的数量
            colors: {
                blue: '#00f3ff',
                green: '#00ff66',
                red: '#ff003c',
                yellow: '#fcee0a',
                white: '#ffffff',
                purple: '#bc13fe'
            }
        };

        const AUDIO_CTX = new (window.AudioContext || window.webkitAudioContext)();

        let gridData = [];
        let totalMines = 0;
        let revealedMines = 0;
        let isFirstMove = true;
        let isGameOver = false;

        let gameStartTime = 0;
        let timerInterval = null;
        let elapsedTime = 0;

        const rayCanvas = document.getElementById('ray-canvas');
        const rayCtx = rayCanvas.getContext('2d');
        let animationFrameId;
        let activeEffects = [];
        let comboCounter = 0;

        const gridEl = document.getElementById('grid');
        const hudMines = document.getElementById('mines-left');
        const hudStatus = document.getElementById('status-text');

        let startCell = null;
        let isDragging = false;
        let dragLine = { x: 0, y: 0 };

        function playSound(type) {
            if (AUDIO_CTX.state === 'suspended') AUDIO_CTX.resume();
            const osc = AUDIO_CTX.createOscillator();
            const gainNode = AUDIO_CTX.createGain();
            osc.connect(gainNode);
            gainNode.connect(AUDIO_CTX.destination);

            const t = AUDIO_CTX.currentTime;

            if (type === 'hover') {
                osc.frequency.setValueAtTime(800, t);
                gainNode.gain.setValueAtTime(0.01, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.05);
            } else if (type === 'mark') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, t);
                gainNode.gain.setValueAtTime(0.05, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
            } else if (type === 'ray') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                gainNode.gain.setValueAtTime(0.15, t);
                gainNode.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t);
                osc.stop(t + 0.2);
            } else if (type === 'explode') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t);
                osc.stop(t + 0.4);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.start(t);
                osc.stop(t + 0.5);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.04 + 0.02;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.gravity = 0.2;
            }

            update(dt) {
                const f = dt * 60;

                this.x += this.vx * f;
                this.y += this.vy * f;
                this.vy += this.gravity * f;

                this.life -= this.decay * f;
                this.size *= Math.pow(0.95, f);
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class FloatingText {
            constructor(x, y, count) {
                const cs = CONFIG.cellSize;
                this.baseX = (x + 0.5) * cs;
                this.baseY = (y + 0.5) * cs;

                // —— 2~10 每个都不同：文字、色相、描边、抖动、旋转、光晕强度 ——
                const PRESET = {
                    2: { text: 'DOUBLE', color: '#00f3ff', glow: 18, stroke: 7, size: 34, jitter: 0.8, rot: -0.10 },
                    3: { text: 'TRIPLE', color: '#00ff66', glow: 20, stroke: 7, size: 36, jitter: 1.0, rot: 0.10 },
                    4: { text: 'QUAD', color: '#bc13fe', glow: 22, stroke: 8, size: 40, jitter: 1.2, rot: -0.08 },
                    5: { text: 'PENTA', color: '#fcee0a', glow: 26, stroke: 9, size: 44, jitter: 1.5, rot: 0.06 },
                    6: { text: 'HEX', color: '#ff7a00', glow: 28, stroke: 10, size: 48, jitter: 1.8, rot: -0.05 },
                    7: { text: 'SEPT', color: '#ff003c', glow: 30, stroke: 11, size: 52, jitter: 2.2, rot: 0.04 },
                    8: { text: 'OCTA', color: '#ff00ff', glow: 34, stroke: 12, size: 58, jitter: 2.6, rot: -0.03 },
                    9: { text: 'NOVA', color: '#00ffff', glow: 38, stroke: 12, size: 64, jitter: 3.0, rot: 0.02 },
                    10: { text: 'DECA+', color: '#ffffff', glow: 44, stroke: 14, size: 72, jitter: 3.4, rot: 0.00 },
                };

                this.count = count;
                this.p = PRESET[count] || PRESET[10];
                if (count === 10) this.p.color = PRESET[Math.floor(Math.random() * 9) + 2].color;

                // 让文字更“有力”：初速度更集中（上冲 + 轻微左右散射）
                this.vx = (Math.random() - 0.5) * 2.2;
                this.vy = -5.2 - Math.random() * 1.4;
                this.gravity = 0.16;

                // 用“时间进度”驱动动画（更稳定）
                this.t = 0;          // 0 -> 1
                this.duration = 0.75; // 秒
                this.life = 1.0;     // 兼容你现有的销毁逻辑

                // 旋转 & 抖动
                this.rot = this.p.rot + (Math.random() - 0.5) * 0.06;
                this.rotVel = (Math.random() - 0.5) * 0.012;

                // 每个连击级别不同的“屏幕叠加感”
                this.additive = count >= 7;

                // 初始位置
                this.x = this.baseX;
                this.y = this.baseY;

                // 小技巧：高连击更“弹”
                this.pop = 1.15 + (count - 2) * 0.03;
            }

            // easing：弹性进入 + 平滑消失
            easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }
            easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

            update(dt) {
                // 时间推进（0 → 1）
                this.t += dt / this.duration;
                if (this.t > 1) this.t = 1;

                // 位移（像素/秒）
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;

                // 重力（像素/秒²）
                this.vy += this.gravity * dt * 60;

                // 空气阻力（指数衰减）
                const drag = Math.pow(0.96, dt * 60);
                this.vx *= drag;

                // 旋转
                this.rot += this.rotVel * dt * 60;

                // 透明度
                if (this.t < 0.55) {
                    this.life = 1;
                } else {
                    this.life = Math.max(0, 1 - (this.t - 0.55) / 0.45);
                }

                // 抖动强度
                const jStrength = (1 - this.easeOutCubic(Math.min(this.t / 0.3, 1))) * this.p.jitter;
                this.jx = (Math.random() - 0.5) * jStrength * 2;
                this.jy = (Math.random() - 0.5) * jStrength * 2;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                // scale：前段弹出、后段微缩
                const popT = Math.min(this.t / 0.25, 1);
                const popScale = this.easeOutBack(popT) * this.pop;
                const settle = this.t > 0.35 ? (1 - (this.t - 0.35) * 0.12) : 1;
                const scale = popScale * settle;

                ctx.save();

                if (this.additive) ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.life;

                ctx.translate(this.x + this.jx, this.y + this.jy);
                ctx.rotate(this.rot);
                ctx.scale(scale, scale);

                // 字体：更“游戏击杀提示”的感觉
                ctx.font = `italic 900 ${this.p.size}px "Arial Black", "Impact", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // 1) 黑色厚描边（清晰度）
                ctx.lineJoin = 'round';
                ctx.strokeStyle = 'rgba(0,0,0,0.95)';
                ctx.lineWidth = this.p.stroke;
                ctx.strokeText(this.p.text, 0, 0);

                // 2) 彩色外辉光（霓虹感）
                ctx.shadowBlur = 0;
                ctx.shadowColor = this.p.color;
                ctx.fillStyle = this.p.color;
                ctx.fillText(this.p.text, 0, 0);

                // 3) 白色高光（立体）
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(this.p.text, -2, -2);

                // 4) 超高连击：加一道“切割高光线”（更像爆发）
                if (this.count >= 8) {
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-this.p.size * 1.2, -this.p.size * 0.2);
                    ctx.lineTo(this.p.size * 1.2, -this.p.size * 0.55);
                    ctx.stroke();
                }

                ctx.restore();
                ctx.globalCompositeOperation = 'source-over';
            }
        }


        class Shockwave {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = CONFIG.cellSize * 1.5;
                this.color = color;
                this.life = 1.0;
                this.decay = 0.08;
            }

            update(dt) {
                const f = dt * 60;
                this.radius += 3 * f;
                this.life -= this.decay * f;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class RayEffect {
            constructor(startX, startY, dirX, dirY, lengthCells, isFailure = false) {
                const cs = CONFIG.cellSize;
                this.sx = (startX + 0.5) * cs;
                this.sy = (startY + 0.5) * cs;
                this.ex = this.sx + (dirX * lengthCells * cs);
                this.ey = this.sy + (dirY * lengthCells * cs);
                this.life = 1.0;

                this.isFailure = isFailure;

                // 生成一个基于位置的随机偏移量，用于脉冲动画，
                // 确保每条射线的脉冲步调不一致。
                this.pulseOffset = (this.sx + this.sy) * 0.1 + Math.random() * 10;

                if (this.isFailure) {
                    // === 失败射线参数 ===
                    this.width = 2;       // 依然保持极细
                    // 这里不再定义单一 color，而是在 draw 里定义血色层次
                    this.maxJitter = 0;   //稍微增加一点抖动，配合脉冲
                } else {
                    // === 普通射线参数 ===
                    this.width = 15;
                    this.color = CONFIG.colors.blue;
                    this.maxJitter = 10;
                }

                this.jitter = 0;
            }

            update(dt) {
                const f = dt * 60;

                this.life -= (this.isFailure ? 0.03 : 0.08) * f;

                if (!this.isFailure) {
                    this.width *= Math.pow(0.9, f);
                }

                this.jitter = (Math.random() - 0.5) * this.maxJitter;
            }

            draw(ctx) {
                // 失败模式依然使用 lighter，让交叉点极其明亮
                ctx.globalCompositeOperation = this.isFailure ? 'lighter' : 'screen';
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(this.sx, this.sy);
                ctx.lineTo(this.ex + this.jitter, this.ey + this.jitter);

                if (this.isFailure) {
                    // === 修改点：血色脉冲激光风格 ===

                    // 计算脉冲因子：利用当前时间 + 自身偏移量计算正弦波
                    // 速度较快 ( * 0.02 )
                    const time = performance.now();
                    const pulseWave = Math.sin(time * 0.02 + this.pulseOffset);
                    // 将正弦波(-1到1)映射到一个亮度波动范围，例如 0.6 到 1.0 之间
                    const pulseFactor = (pulseWave * 0.2) + 0.8;

                    // 层1: 深血色外晕 (提供深邃的背景，不脉冲，稳定存在)
                    ctx.lineWidth = 5; // 稍微宽一点点作为底色
                    ctx.strokeStyle = '#660000'; // 深沉的干涸血色
                    ctx.globalAlpha = this.life * 0.5; // 半透明
                    ctx.stroke();

                    // 层2: 鲜血核心 (极细，高饱和，带有脉冲效果)
                    ctx.lineWidth = 1.5; // 极细核心
                    // 使用鲜艳的动脉血红，而不是之前的粉白
                    ctx.strokeStyle = '#ff0000';
                    // Alpha 由生命值和脉冲因子共同决定
                    ctx.globalAlpha = this.life * pulseFactor * 0.9;
                    ctx.stroke();

                } else {
                    // === 普通蓝色扫描线 (保持原样) ===
                    ctx.lineWidth = this.width * 3;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.2;
                    ctx.stroke();

                    ctx.lineWidth = this.width;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.stroke();

                    ctx.lineWidth = this.width * 0.3;
                    ctx.strokeStyle = '#ffffff';
                    ctx.globalAlpha = this.life;
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = 'source-over';
            }
        }
        function startRenderLoop() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            let lastTime = performance.now();

            function loop(now) {
                const deltaTime = Math.min((now - lastTime) / 1000, 0.05);
                lastTime = now;

                // 1. 获取网格当前在屏幕上的实际位置
                // 这解决了不同屏幕布局、横竖屏切换后位置不对的问题
                const rect = gridEl.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // 2. 清空全屏画布
                // 注意：因为 resizeCanvasToDisplaySize 会改变 canvas.width/height，
                // 我们需要用 canvas 的实际物理像素尺寸来清空
                rayCtx.setTransform(1, 0, 0, 1, 0, 0); // 重置矩阵以确保清空全屏
                rayCtx.clearRect(0, 0, rayCanvas.width, rayCanvas.height);

                // 3. 设置绘制矩阵：
                // 缩放 (dpr) + 平移 (rect.left, rect.top)
                // 还要加上 padding (4px) 的偏移，因为 grid-wrapper 有 padding
                // 如果你的 rect 是取自 #grid 元素本身，就不需要加 padding，直接用 rect.left
                rayCtx.setTransform(dpr, 0, 0, dpr, rect.left * dpr, rect.top * dpr);

                // --- 下面的绘制逻辑完全不用动 ---
                for (let i = activeEffects.length - 1; i >= 0; i--) {
                    const effect = activeEffects[i];
                    effect.update(deltaTime);
                    effect.draw(rayCtx);
                    if (effect.life <= 0) {
                        activeEffects.splice(i, 1);
                    }
                }

                animationFrameId = requestAnimationFrame(loop);
            }

            animationFrameId = requestAnimationFrame(loop);
        }

        //const MAX_PARTICLES = 150;
        function spawnExplosion(cx, cy, color = CONFIG.colors.red) {
            //if (activeEffects.length > MAX_PARTICLES) {
            //    return;
            // }

            const particleCount = 20;
            const pixelX = (cx + 0.5) * CONFIG.cellSize;
            const pixelY = (cy + 0.5) * CONFIG.cellSize;
            for (let i = 0; i < particleCount; i++) {
                activeEffects.push(new Particle(pixelX, pixelY, color));
            }
            activeEffects.push(new Shockwave(pixelX, pixelY, color));
        }

        // 修改：增加了 length 参数，默认为 null
        function spawnRay(x, y, dx, dy, length = null, isFailure = false) {
            activeEffects.push(new RayEffect(x, y, dx, dy, Math.max(CONFIG.rayLength, length), isFailure));
        }

        function explodeNeighbors(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                        const neighbor = gridData[ny][nx];
                        if (!neighbor.isRevealed) {
                            neighbor.reveal();
                        }
                    }
                }
            }
        }

        function floodFill(x, y) {
            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            for (let dir of dirs) {
                const nx = x + dir.x;
                const ny = y + dir.y;

                if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                    const neighbor = gridData[ny][nx];
                    if (!neighbor.isRevealed && !neighbor.isMine && neighbor.neighborCount === 0) {
                        neighbor.reveal();
                    }
                }
            }
        }

        function animatedFloodFill(startX, startY) {
            // 1. 定义 BFS 结构
            const queue = [{ x: startX, y: startY, dist: 0 }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            // 这个数组用来存 { cell, dist }，用于稍后生成动画
            const animationQueue = [];

            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
            ];

            // 2. === 阶段一：同步逻辑处理（瞬间完成） ===
            // 在这个循环里，我们只修改数据状态 (isRevealed)，不操作 DOM
            let head = 0;
            while (head < queue.length) {
                const { x, y, dist } = queue[head++];
                const currentCell = gridData[y][x];

                // 如果不是起点（起点在 cell.reveal 里已经处理了），记录下来做动画
                if (dist > 0) {
                    animationQueue.push({ cell: currentCell, dist: dist });
                }

                // 如果当前格子是空地 (0)，则继续扩散
                // 注意：这里我们不需要判断 neighborCount === 0，
                // 因为只有 0 才能进队列继续搜寻邻居（边界数字不扩散）
                if (currentCell.neighborCount === 0) {
                    for (let dir of dirs) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        const key = `${nx},${ny}`;

                        // 越界检查
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (!visited.has(key)) {
                                const neighbor = gridData[ny][nx];

                                // 关键：只要没揭开，就立即在逻辑上揭开
                                if (!neighbor.isRevealed && neighbor.neighborCount === 0) {
                                    // --- 状态锁定 ---
                                    neighbor.isRevealed = true; // 锁死状态，防止再次点击
                                    neighbor.isMarked = false;  // 逻辑上去除标记

                                    visited.add(key);

                                    // 只有 0 继续入队扩散，数字只揭开不扩散
                                    if (neighbor.neighborCount === 0) {
                                        queue.push({ x: nx, y: ny, dist: dist + 1 });
                                    } else {
                                        // 这是一个边界数字，记录动画，但不再入队
                                        animationQueue.push({ cell: neighbor, dist: dist + 1 });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 3. === 阶段二：异步视觉动画 ===
            // 此时所有相关格子的 isRevealed 已经是 true 了，玩家点不动了
            // 我们只需要安安静静地把样式刷上去

            if (animationQueue.length === 0) return;

            if (isGameOver) {
                animationQueue.forEach(item => {
                    item.cell.updateVisuals();
                });
                // 失败时不需要播放扩散音效，也不需要更新HUD（反正都要输了）
                return;
            }

            // 先找到最大层级 (最远的那个格子离起点的距离)
            let maxDist = 0;
            animationQueue.forEach(item => { if (item.dist > maxDist) maxDist = item.dist; });

            // === 核心修改：动态时间步长 ===
            let stepDelay = 30;           // 默认的基础速度 (ms/步)
            const maxTotalDuration = 500; // 最大总耗时限制 (ms)

            // 计算：如果按默认速度跑完会超过 500ms
            if (maxDist * stepDelay > maxTotalDuration) {
                // 强制压缩：用总时间除以总步数
                stepDelay = maxTotalDuration / maxDist;
            }

            for (let d = 1; d <= maxDist; d++) {
                setTimeout(() => {
                    if (isGameOver) return;

                    animationQueue.forEach(item => {
                        if (item.dist === d) {
                            // 调用我们刚才写的纯视觉更新函数
                            item.cell.updateVisuals();
                        }
                    });
                }, d * stepDelay);
            }

            updateHUD();
        }

        function revealRayPath(startX, startY, dirX, dirY) {
            for (let i = 1; i <= CONFIG.rayLength; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);
                if (tx < 0 || tx >= CONFIG.gridW || ty < 0 || ty >= CONFIG.gridH) break;

                const targetCell = gridData[ty][tx];
                if (!targetCell.isMine && !targetCell.isRevealed) {
                    targetCell.reveal();
                }
            }
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.isMine = false;
                this.isRevealed = false;
                this.isMarked = false;
                this.neighborCount = 0;
                this.element = document.createElement('div');
                this.element.className = 'cell';
                this.element.dataset.x = x;
                this.element.dataset.y = y;
            }

            toggleMark() {
                if (this.isRevealed) return;
                this.isMarked = !this.isMarked;
                this.element.classList.toggle('marked', this.isMarked);
                playSound('mark');
            }

            reveal() {
                if (this.isRevealed) return;

                this.isRevealed = true;
                this.isMarked = false;

                this.updateVisuals();

                if (this.isMine) {
                    this.element.classList.add('mine');
                    this.element.textContent = '☢';
                    this.element.dataset.num = 'mine';

                    this.element.classList.add('mine-flash');
                    setTimeout(() => this.element.classList.remove('mine-flash'), 150);

                    revealedMines++;
                    playSound('explode');
                    spawnExplosion(this.x, this.y, CONFIG.colors.red);

                    const container = document.getElementById('game-container');
                    container.classList.remove('shake');
                    void container.offsetWidth;
                    container.classList.add('shake');

                } else {
                    if (this.neighborCount === 0) {
                        animatedFloodFill(this.x, this.y);
                    } else {
                        spawnExplosion(this.x, this.y, 'rgba(0, 243, 255, 0.4)');
                    }
                }
                updateHUD();
            }

            updateVisuals() {
                // 移除标记样式
                this.element.classList.remove('marked');
                // 添加揭示样式
                this.element.classList.add('revealed');

                if (!this.isMine) {
                    // 显示数字
                    this.element.textContent = this.neighborCount === 0 ? '' : this.neighborCount;
                    this.element.dataset.num = this.neighborCount;
                }
            }
        }

        function startTimer() {
            if (timerInterval) return;
            gameStartTime = Date.now();
            const display = document.getElementById('timer-display');

            timerInterval = setInterval(() => {
                const now = Date.now();
                elapsedTime = Math.floor((now - gameStartTime) / 1000);
                display.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function resizeCanvasToDisplaySize(canvas, cssWidth, cssHeight) {
            const dpr = window.devicePixelRatio || 1;

            // 1) 设定 CSS 尺寸（页面上看到的尺寸）
            canvas.style.width = cssWidth + 'px';
            canvas.style.height = cssHeight + 'px';

            // 2) 设定实际像素尺寸（乘 DPR，保证清晰）
            const displayWidth = Math.round(cssWidth * dpr);
            const displayHeight = Math.round(cssHeight * dpr);

            // 避免重复 set 造成抖动/重置状态
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            return dpr;
        }

        function initGame() {
            // 清理可能的旧延时操作
            if (window.failTimeout) clearTimeout(window.failTimeout);
            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);
            window.failIntervals = window.failIntervals || [];
            window.failIntervals.forEach(id => clearTimeout(id));
            window.failIntervals = [];

            stopTimer();
            elapsedTime = 0;
            document.getElementById('timer-display').textContent = "00:00";

            gridEl.innerHTML = '';
            gridData = [];
            revealedMines = 0;
            isFirstMove = true;
            isGameOver = false;
            activeEffects = [];
            hudStatus.textContent = "待命";
            hudStatus.style.color = "var(--neon-green)";

            // === PATCH: initGame() 内部替换“智能计算布局”那一段 ===
            const isLandscape = window.innerWidth > window.innerHeight;
            const margin = 12;

            // 真实测量 HUD/Guide/Toolbar 的占用空间（避免字体/设备差异）
            const hudRect = document.getElementById('hud').getBoundingClientRect();
            const guideRect = document.getElementById('guide-text').getBoundingClientRect();

            // 顶部 HUD 高度
            const hudHeight = Math.ceil(hudRect.height);

            // 底部 guide 高度
            const guideHeight = Math.ceil(guideRect.height);

            // 工具栏占用：横屏占宽，竖屏占高
            const toolbarW = 0;
            const toolbarH = 0;

            // 可用空间（注意：HUD、Guide、Toolbar 都是 fixed 叠在视口上，所以要扣掉它们）
            const availableWidth = window.innerWidth - toolbarW - margin * 2;
            const availableHeight = window.innerHeight - hudHeight - guideHeight - toolbarH - margin * 2;

            // 计算 cellSize：不要硬卡到 20，否则小屏会溢出
            const sizeW = Math.floor(availableWidth / CONFIG.gridW);
            const sizeH = Math.floor(availableHeight / CONFIG.gridH);

            // 上限 50 保持观感，下限给到 6~8，宁愿变小也别溢出
            let size = Math.min(sizeW, sizeH, 50);
            size = Math.max(size, 6);

            CONFIG.cellSize = size;
            gridEl.style.setProperty('--cs', size + 'px');

            const totalWidth = size * CONFIG.gridW;
            const totalHeight = size * CONFIG.gridH;

            gridEl.style.gridTemplateColumns = `repeat(${CONFIG.gridW}, ${size}px)`;
            gridEl.style.gridTemplateRows = `repeat(${CONFIG.gridH}, ${size}px)`;

            const dpr = resizeCanvasToDisplaySize(rayCanvas, window.innerWidth, window.innerHeight);

            // 关键：把坐标系缩回“CSS 像素”，这样你后面用的 cellSize/像素计算都不用改
            rayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

            for (let y = 0; y < CONFIG.gridH; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.gridW; x++) {
                    const cell = new Cell(x, y);
                    gridEl.appendChild(cell.element);
                    row.push(cell);
                }
                gridData.push(row);
            }

            totalMines = Math.floor(CONFIG.gridW * CONFIG.gridH * CONFIG.density);
            updateHUD();
            startRenderLoop();
        }

        function generateMines(startX, startY, dirX, dirY) {
            // 先确保起点是雷
            gridData[startY][startX].isMine = true;
            let placed = 1;

            // 此时我们不干预分布，纯粹随机
            while (placed < totalMines) {
                const rx = Math.floor(Math.random() * CONFIG.gridW);
                const ry = Math.floor(Math.random() * CONFIG.gridH);

                if (!gridData[ry][rx].isMine) {
                    gridData[ry][rx].isMine = true;
                    placed++;
                }
            }

            // 收集该方向上距离 2 到 5 的合法格子
            const candidates = [];
            let hasMineInPath = false;

            // 距离0是起点，距离1是九宫格边缘（会被直接炸开），
            // 射线穿透4个未揭示格，所以覆盖的是距离 2, 3, 4, 5
            for (let i = 2; i <= 5; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);

                // 越界检查
                if (tx >= 0 && tx < CONFIG.gridW && ty >= 0 && ty < CONFIG.gridH) {
                    const cell = gridData[ty][tx];
                    candidates.push(cell);
                    if (cell.isMine) {
                        hasMineInPath = true; // 运气不错，自然生成了
                    }
                }
            }

            if (!hasMineInPath && candidates.length > 0) {

                // A. 从路径候选格中选一个幸运儿变成雷
                const luckyCell = candidates[Math.floor(Math.random() * candidates.length)];
                luckyCell.isMine = true;

                // B. 为了保持总雷数不变，必须擦除掉地图上另一个现有的雷
                //    这个雷不能是起点，也不能是我们刚才选中的幸运儿
                let removed = false;
                while (!removed) {
                    const rx = Math.floor(Math.random() * CONFIG.gridW);
                    const ry = Math.floor(Math.random() * CONFIG.gridH);
                    const target = gridData[ry][rx];

                    // 必须是雷，且不是起点，且不是刚才新设的那个位置
                    if (target.isMine &&
                        !(rx === startX && ry === startY) &&
                        !(rx === luckyCell.x && ry === luckyCell.y)) {

                        target.isMine = false; // 移除这颗雷
                        removed = true;
                    }
                }
            }

            // 统一计算数字
            calculateNumbers();
        }

        function calculateNumbers() {
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
            ];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    let count = 0;
                    for (let dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (gridData[ny][nx].isMine) count++;
                        }
                    }
                    gridData[y][x].neighborCount = count;
                }
            }
        }

        function calculateRayPath(startX, startY, dirX, dirY) {
            let currentX = startX;
            let currentY = startY;
            let distance = 0;
            let unrevealedHitCount = 0;
            const path = [];

            while (true) {
                currentX += dirX;
                currentY += dirY;
                distance++;

                // 1. 边界检查
                if (currentX < 0 || currentX >= CONFIG.gridW ||
                    currentY < 0 || currentY >= CONFIG.gridH) {
                    break;
                }

                const cell = gridData[currentY][currentX];
                path.push(cell);

                // 命中未揭示的地雷，立即停止 ===
                // 射线能量被这颗雷吸收并引爆，它不能再往前走了。
                // 后续的路径将由这颗雷爆炸产生的“新射线”接力完成。
                if (cell.isMine && !cell.isRevealed) {
                    break;
                }

                // 3. 穿透检测 (针对普通未知格子)
                if (!cell.isRevealed) {
                    unrevealedHitCount++;
                }

                // 4. 耗尽停止
                if (unrevealedHitCount >= CONFIG.penetrationLimit) {
                    break;
                }
            }

            return { distance, path };
        }

        function fireRay(startX, startY, dirX, dirY, delay = 0) {
            setTimeout(() => {
                if (isGameOver) return;

                // 1. 先计算路径（逻辑核心）
                const { distance, path } = calculateRayPath(startX, startY, dirX, dirY);

                playSound('ray');

                // 2. 视觉生成：传入计算出的实际距离 (distance)
                // 这样射线就能在墙边或者第4个格子处精准停下
                spawnRay(startX, startY, dirX, dirY, distance);

                // 3. 游戏逻辑：遍历路径上的格子
                for (const targetCell of path) {

                    if (targetCell.isMine) {
                        if (!targetCell.isRevealed) {
                            targetCell.reveal(); // 揭示雷
                            explodeNeighbors(targetCell.x, targetCell.y); // 炸开周围
                            fireRay(targetCell.x, targetCell.y, dirX, dirY, 120);

                            comboCounter++;
                            const showCount = Math.min(comboCounter, 10);

                            if (showCount >= 2) {
                                activeEffects.push(new FloatingText(targetCell.x, targetCell.y, showCount));
                            }

                            hitMine = true;
                        }
                    } else {
                        targetCell.reveal();
                    }
                }
                checkWinCondition();
            }, delay);
        }


        let isPaused = false;
        let pausedTimerWasRunning = false;

        function openTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.remove('hidden');

            // 暂停输入
            isPaused = true;

            // 暂停计时（如果正在计时）
            pausedTimerWasRunning = !!timerInterval;
            stopTimer();

            playSound('hover');
        }

        function closeTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.add('hidden');

            // 恢复输入
            isPaused = false;

            // 恢复计时（仅当游戏未结束、且之前在计时）
            if (!isGameOver && !isFirstMove && pausedTimerWasRunning) {
                startTimer(); // startTimer 下面会做“按 elapsedTime 续计”
            }

            pausedTimerWasRunning = false;
            playSound('hover');
        }

        function startTimer() {
            if (timerInterval) return;

            // ✅ 关键：支持暂停恢复
            gameStartTime = Date.now() - (elapsedTime * 1000);

            const display = document.getElementById('timer-display');
            timerInterval = setInterval(() => {
                const now = Date.now();
                elapsedTime = Math.floor((now - gameStartTime) / 1000);
                display.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        document.getElementById('btn-tutorial').addEventListener('click', () => {
            openTutorial();
        });

        document.getElementById('btn-ingame-tutorial').addEventListener('click', () => {
            openTutorial();
        });

        document.getElementById('btn-tutorial-back').addEventListener('click', () => {
            closeTutorial();
        });

        document.getElementById('tutorial-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'tutorial-overlay') closeTutorial();
        });

        function setupInput() {
            // 禁止网格区域默认右键菜单
            gridEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });

            const getCellCoords = (e) => {
                const rect = gridEl.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const x = Math.floor((clientX - rect.left) / CONFIG.cellSize);
                const y = Math.floor((clientY - rect.top) / CONFIG.cellSize);
                return { x, y, clientX, clientY };
            };

            // 调大阈值（至少 38px；并随格子大小略缩放）
            const getDragThreshold = () => Math.max(38, Math.round(CONFIG.cellSize * 0.45));
            let dragButton = 0;
            const startDrag = (e) => {
                if (isGameOver || isPaused) return;

                // touch 需要 preventDefault 防止页面滚动
                if (e.type === 'touchstart') e.preventDefault();

                const coords = getCellCoords(e);
                if (coords.x < 0 || coords.x >= CONFIG.gridW || coords.y < 0 || coords.y >= CONFIG.gridH) return;

                const cell = gridData[coords.y][coords.x];
                if (cell.isRevealed) return; // 已揭示不处理

                dragButton = (e.type === 'mousedown') ? e.button : 0;

                // 记录起点，等待 end 时判断是“点”还是“拖”
                startCell = { x: coords.x, y: coords.y };
                isDragging = true;
                dragLine = { x: coords.clientX, y: coords.clientY };

                cell.element.classList.add('active');
                playSound('hover');
            };

            const moveDrag = (e) => {
                if (!isDragging) return;
                // 触摸拖动时防滚动
                if (e.type === 'touchmove') e.preventDefault();
            };

            const endDrag = (e) => {
                if (!isDragging || !startCell) return;

                const end = e.changedTouches
                    ? { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY }
                    : { clientX: e.clientX, clientY: e.clientY };

                const dx = end.clientX - dragLine.x;
                const dy = end.clientY - dragLine.y;
                const dist = Math.hypot(dx, dy);

                const cell = gridData[startCell.y][startCell.x];
                cell.element.classList.remove('active');

                const threshold = getDragThreshold();

                if (dragButton === 2) {
                    if (dist < threshold) cell.toggleMark();
                    // else: 什么都不做
                    isDragging = false;
                    startCell = null;
                    return;
                }

                if (dist < threshold) {
                    // 视为点击：切换标记
                    cell.toggleMark();
                } else {
                    if (cell.isMarked) {
                        // 标记格子被认为“安全”，避免误操作
                        isDragging = false;
                        startCell = null;
                        return;
                    }

                    const angle = Math.atan2(dy, dx);
                    const degree = angle * (180 / Math.PI);
                    const octant = Math.round(degree / 45);

                    const dirs = [
                        { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 },
                        { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }
                    ];

                    let dirIndex = octant;
                    if (dirIndex < 0) dirIndex += 8;
                    dirIndex = dirIndex % 8;

                    const dir = dirs[dirIndex];
                    handleAction(startCell.x, startCell.y, dir.x, dir.y);
                }

                isDragging = false;
                startCell = null;
            };

            gridEl.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', moveDrag);
            window.addEventListener('mouseup', endDrag);

            gridEl.addEventListener('touchstart', startDrag, { passive: false });
            window.addEventListener('touchmove', moveDrag, { passive: false });
            window.addEventListener('touchend', endDrag);
        }

        function handleAction(x, y, dirX, dirY) {
            const cell = gridData[y][x];
            if (cell.isRevealed || cell.isMarked) return;

            comboCounter = 1;

            if (isFirstMove) {
                generateMines(x, y, dirX, dirY);
                isFirstMove = false;
                hudStatus.textContent = "链接建立";
                startTimer();
            }

            if (cell.isMine) {
                cell.reveal();
                // 现在采取的是邻居优先不链式反应的规则，可以解释为周围被炸坏了
                explodeNeighbors(x, y);
                fireRay(x, y, dirX, dirY);
            } else {
                cell.element.style.backgroundColor = "var(--neon-red)";
                spawnExplosion(x, y, CONFIG.colors.red);
                gameOver(false);
            }
        }

        let endDuration = 0.0;

        function triggerChainFailure() {
            hudStatus.textContent = "系统崩溃";
            hudStatus.style.color = "var(--neon-red)";
            playSound('error');

            const hiddenMines = [];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    if (gridData[y][x].isMine && !gridData[y][x].isRevealed) {
                        hiddenMines.push(gridData[y][x]);
                    }
                }
            }

            hiddenMines.sort(() => Math.random() - 0.5);

            // 动态间隔计算
            let interval = 300;
            if (hiddenMines.length > 10) {
                // 如果雷多于10个，确保在3000ms内炸完
                interval = 3000 / hiddenMines.length;
            }

            // 清理旧的定时器数组
            window.failIntervals = [];
            endDuration = interval * hiddenMines.length;

            hiddenMines.forEach((cell, index) => {
                const id = setTimeout(() => {
                    cell.element.classList.add('mine');
                    cell.element.textContent = '☢';
                    cell.element.classList.add('mine-flash');
                    setTimeout(() => cell.element.classList.remove('mine-flash'), 150);

                    playSound('explode');
                    spawnExplosion(cell.x, cell.y, CONFIG.colors.red);

                    const dirs = [
                        { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 },
                        { x: 0, y: 1 }, { x: -1, y: 1 }, { x: -1, y: 0 }, { x: -1, y: -1 }
                    ];
                    dirs.forEach(d => {
                        const { distance, path } = calculateRayPath(cell.x, cell.y, d.x, d.y);
                        spawnRay(cell.x, cell.y, d.x, d.y, distance, true);
                        revealRayPath(cell.x, cell.y, d.x, d.y);
                    });

                }, index * interval);
                window.failIntervals.push(id);
            });

            const finalRevealId = setTimeout(() => {
                for (let y = 0; y < CONFIG.gridH; y++) {
                    for (let x = 0; x < CONFIG.gridW; x++) {
                        const cell = gridData[y][x];
                        if (!cell.isRevealed && !cell.isMine) {
                            cell.isRevealed = true;
                            cell.isMarked = false;
                            // 静默更新视觉，不播放声音，不带动画，仿佛系统彻底死机显示数据
                            cell.updateVisuals();
                        }
                    }
                }
            }, endDuration);

            window.failIntervals.push(finalRevealId);
        }

        function checkWinCondition() {
            if (revealedMines >= totalMines) {
                gameOver(true);
            }
        }

        function gameOver(win, reason) {
            if (isGameOver) return;

            stopTimer();

            isGameOver = true;
            if (!win) {
                triggerChainFailure();
                // 注意：失败时我们稍后弹出界面，但数据现在就要准备好
            } else {
                // 胜利直接处理
                hudStatus.textContent = "胜利";
                hudStatus.style.color = "var(--neon-green)";
                playSound('hover');
            }

            // 准备界面数据
            const card = document.querySelector('.result-card');
            const title = document.getElementById('end-title');
            const timeDisplay = document.getElementById('end-time');
            const diffDisplay = document.getElementById('end-difficulty');
            const pctDisplay = document.getElementById('end-percentage');
            const reasonText = document.getElementById('end-reason');
            const overlay = document.getElementById('game-over-overlay');

            // 设置基本数据
            timeDisplay.textContent = formatTime(elapsedTime);
            diffDisplay.textContent = `${CONFIG.gridW}x${CONFIG.gridH} (${Math.round(CONFIG.density * 100)}%)`;

            // 移除旧主题
            card.classList.remove('win-theme', 'lose-theme');

            // 延迟显示逻辑 (为了配合爆炸动画)
            const showDelay = win ? 1500 : (endDuration + 1500);

            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            window.gameResultTimeout = setTimeout(() => {
                if (win) {
                    title.textContent = "SYSTEM PURGED";
                    title.className = "win"; // 保持文字颜色逻辑
                    card.classList.add('win-theme');
                    pctDisplay.textContent = "100%";
                    reasonText.textContent = "所有威胁已消除，系统恢复正常。";
                } else {
                    title.textContent = "CONNECTION LOST";
                    title.className = "lose";
                    card.classList.add('lose-theme');
                    // 计算完成度
                    const pct = Math.floor((revealedMines / totalMines) * 100);
                    pctDisplay.textContent = `${pct}% THREATS NEUTRALIZED`;
                    reasonText.textContent = "逻辑链路崩溃，协议执行失败。";
                }
                overlay.classList.remove('hidden');
            }, showDelay);
        }

        function updateHUD() {
            hudMines.textContent = `${totalMines - revealedMines}`;
        }

        const menuOverlay = document.getElementById('menu-overlay');
        const inpW = document.getElementById('inp-w');
        const inpH = document.getElementById('inp-h');
        const inpD = document.getElementById('inp-d');
        const diffSelect = document.getElementById('difficulty-select');
        const customSettings = document.getElementById('custom-settings');

        // === 1. 定义协议参数 ===
        const PRESETS = {
            // 10x10, 70% 密度
            'normal': { w: 10, h: 10, d: 70, adaptive: false },

            // 15x20, 50% 密度 (开启自适应：横屏宽20，竖屏宽15)
            'enhanced': { w: 15, h: 20, d: 50, adaptive: true },

            // 30x30, 30% 密度
            'ultimate': { w: 30, h: 30, d: 30, adaptive: false }
        };

        function getAdaptiveDimensions(baseW, baseH) {
            const isLandscape = window.innerWidth > window.innerHeight;
            const short = Math.min(baseW, baseH);
            const long = Math.max(baseW, baseH);

            // 如果是横屏，宽是长边；如果是竖屏，宽是短边
            return isLandscape
                ? { w: long, h: short }
                : { w: short, h: long };
        }

        function updateSliderLabels() {
            document.getElementById('val-w').textContent = inpW.value;
            document.getElementById('val-h').textContent = inpH.value;
            document.getElementById('val-d').textContent = inpD.value + '%';
        }

        [inpW, inpH, inpD].forEach(el => {
            el.addEventListener('input', () => {
                updateSliderLabels();
                // 如果用户动了滑块，自动切到自定义模式（但为了逻辑简单，这里只更新数值，模式切换由下拉框决定）
            });
        });

        diffSelect.addEventListener('change', () => {
            applyMode(diffSelect.value);
        });

        const protocolDesc = document.getElementById('protocol-desc');

        // 描述文本（完全汉化，修正难度逻辑）
        const DESCRIPTIONS = {
            'normal': "【低风险】雷区信号极强。目标高度饱和，连锁反应极易触发。适合快速上手与压力释放。",

            'enhanced': "【中风险】标准战术环境。威胁分布均衡，需在扫描与规避间寻找平衡。系统将自动适配屏幕视野。",

            'ultimate': "【极高风险】静默潜行任务。目标极度稀疏，大量安全区干扰判定。任何盲目试探都将导致任务失败。",

            'custom': "手动覆写系统参数。允许操作员自定义网格尺寸与威胁密度。请注意：密度越低，容错率越低。"
        };

        function applyMode(mode) {
            if (protocolDesc && DESCRIPTIONS[mode]) {
                protocolDesc.textContent = DESCRIPTIONS[mode];
            }

            if (mode === 'custom') {
                // 自定义模式：显示滑块，不强制修改数值
                customSettings.classList.remove('hidden');
            } else if (PRESETS[mode]) {
                // 预设模式：隐藏滑块
                customSettings.classList.add('hidden');

                const p = PRESETS[mode];
                let targetW = p.w;
                let targetH = p.h;

                // 【关键】如果是增强协议（adaptive=true），检查当前屏幕方向
                if (p.adaptive) {
                    const dims = getAdaptiveDimensions(p.w, p.h);
                    targetW = dims.w;
                    targetH = dims.h;
                }

                inpW.value = targetW;
                inpH.value = targetH;
                inpD.value = p.d;
                updateSliderLabels();
            }
        }

        document.getElementById('btn-start').addEventListener('click', () => {
            applyMode(diffSelect.value);

            // 获取当前滑块的值
            const w = parseInt(inpW.value);
            const h = parseInt(inpH.value);
            const d = parseInt(inpD.value);
            const mode = diffSelect.value;

            // 1. 更新全局配置
            CONFIG.gridW = w;
            CONFIG.gridH = h;
            CONFIG.density = d / 100;

            // 2. 步到 URL ===
            updateURLSettings(mode, w, h, d);

            // 3. 开始游戏
            menuOverlay.classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-restart').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-menu').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            clearURLSettings();
            menuOverlay.classList.remove('hidden');
        });

        // 游戏内菜单按钮事件
        document.getElementById('btn-ingame-restart').addEventListener('click', () => {
            initGame();
        });

        // === 修改后的菜单按钮逻辑 ===
        document.getElementById('btn-ingame-menu').addEventListener('click', () => {
            // 1. 立即停止计时器 (核心修复：防止背景时间继续走)
            stopTimer();

            // 2. 标记游戏结束，阻断后续交互
            isGameOver = true;

            // 3. 清理所有可能的失败动画/延时
            if (window.failIntervals) {
                window.failIntervals.forEach(id => clearTimeout(id));
                window.failIntervals = [];
            }
            if (window.failTimeout) clearTimeout(window.failTimeout);
            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            // 4. 更新 HUD 状态
            hudStatus.textContent = "已挂起";
            hudStatus.style.color = "#888";

            clearURLSettings();

            // 5. 确保结算弹窗关闭，并显示主菜单
            document.getElementById('game-over-overlay').classList.add('hidden');
            menuOverlay.classList.remove('hidden');

            applyMode(diffSelect.value);
        });

        // 监听窗口大小变化以重新计算布局（可选，简单起见直接重置可能更好，或者动态调整 grid-wrapper）
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // 只有在非游戏进行中或者你想支持动态调整时才调用
                // 这里为了体验流畅，建议用户手动重开，或者只重新计算 grid 尺寸而不清空数据
                // 简单处理：重新初始化
                if (!isGameOver && revealedMines === 0) {
                    initGame();
                }
            }, 500);
        });

        setupInput();

        function loadSettingsFromURL() {
            const params = new URLSearchParams(window.location.search);

            // 1. 优先检查 mode 参数
            if (params.has('mode')) {
                const mode = params.get('mode');

                // 如果是有效预设
                if (PRESETS[mode]) {
                    diffSelect.value = mode;
                    applyMode(mode);
                    // 这里我们需要手动更新 CONFIG，因为 applyMode 只更新了 DOM
                    CONFIG.gridW = PRESETS[mode].w;
                    CONFIG.gridH = PRESETS[mode].h;
                    CONFIG.density = PRESETS[mode].d / 100;
                    return true; // 自动开始
                }

                // 如果是自定义模式
                if (mode === 'custom') {
                    diffSelect.value = 'custom';
                    applyMode('custom');

                    // 尝试读取 w, h, d 参数
                    if (params.has('w') && params.has('h') && params.has('d')) {
                        const w = parseInt(params.get('w')) || 10;
                        const h = parseInt(params.get('h')) || 15;
                        const d = parseInt(params.get('d')) || 30;

                        inpW.value = w;
                        inpH.value = h;
                        inpD.value = d;
                        updateSliderLabels();

                        CONFIG.gridW = w;
                        CONFIG.gridH = h;
                        CONFIG.density = d / 100;
                        return true; // 自动开始
                    }
                }
            }

            // 默认情况：如果没有 mode，或者参数不全，不做自动开始，
            // 但我们可以初始化一下界面显示
            applyMode('normal'); // 默认选中第一个
            return false;
        }

        function updateURLSettings(mode, w, h, d) {
            const url = new URL(window.location);

            // 总是写入 mode
            url.searchParams.set('mode', mode);

            if (mode === 'custom') {
                // 只有自定义模式才写入 w, h, d
                url.searchParams.set('w', w);
                url.searchParams.set('h', h);
                url.searchParams.set('d', d);
            } else {
                // 非自定义模式，移除 w, h, d
                url.searchParams.delete('w');
                url.searchParams.delete('h');
                url.searchParams.delete('d');
            }

            window.history.replaceState({}, '', url);
        }

        function clearURLSettings() {
            const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
            window.history.replaceState({}, '', cleanUrl);
        }

        // 启动入口
        const shouldAutoStart = loadSettingsFromURL();
        if (shouldAutoStart) {
            menuOverlay.classList.add('hidden');
            initGame();
        } else {
            menuOverlay.classList.remove('hidden');
        }
    </script>
</body>

</html>
