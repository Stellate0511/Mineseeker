<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mineseeker: é€†è½¬ç‰ˆæ‰«é›·</title>
    <style>
        :root {
            --bg-color: #050505;
            --grid-bg: #000000;
            --cell-unrevealed: #1a1a1a;
            --cell-revealed: #050505;
            --cell-border-light: #333;
            --cell-border-dark: #111;

            --neon-blue: #00f3ff;
            --neon-red: #ff003c;
            --neon-green: #00ff66;
            --neon-yellow: #fcee0a;
            --text-main: #e0e0e0;
        }

        @font-face {
            font-family: 'Cyber';
            src: local('Courier New');
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #game-container {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .shake {
            animation: shake-anim 0.2s ease-in-out;
        }

        @keyframes shake-anim {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-3px, 3px);
            }

            50% {
                transform: translate(3px, -3px);
            }

            75% {
                transform: translate(-3px, -3px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* é¡¶éƒ¨ HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            width: 100%;
            padding: 15px 20px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0));
            text-shadow: 0 0 5px var(--neon-blue);
            z-index: 20;
            pointer-events: none;
        }

        /* === ä¿®æ”¹ .hud-info === */
        .hud-info {
            display: flex;
            gap: 20px;
            font-size: 1rem;
            font-weight: bold;
            flex-grow: 1;
            overflow: hidden;
            /* é˜²æ­¢æº¢å‡º */
            flex-wrap: wrap;
            min-width: 0;
        }

        /* === é’ˆå¯¹å†…éƒ¨æ¯ä¸€ä¸ªå°é¡¹çš„æ ·å¼ === */
        .hud-info div {
            /* å¼ºåˆ¶ä¸æ¢è¡Œï¼Œè®© "çŠ¶æ€ï¼šå°±ç»ª" æ°¸è¿œè¿åœ¨ä¸€èµ· */
            white-space: nowrap;
        }

        /* çª„å±ï¼šæŠŠç¬¬3é¡¹ï¼ˆçŠ¶æ€ï¼‰ç‹¬å ä¸€è¡Œ */
        @media (max-width: 420px) {
            .hud-info {
                gap: 8px;
                font-size: 0.85rem;
            }

            .hud-info>div:nth-child(3) {
                flex-basis: 100%;
            }
        }

        /* === æ–°å¢ï¼šæ‰‹æœºç«–å±ä¸‹çš„é€‚é… === */
        @media (max-width: 480px) {
            .hud-info {
                /* æ‰‹æœºå±å¹•çª„ï¼Œå‡å°é—´è· */
                gap: 8px;
                /* ç¨å¾®å‡å°å­—ä½“ï¼Œç¡®ä¿ä¸‰ä¸ªæ•°æ®èƒ½æ’æˆä¸€è¡Œ */
                font-size: 0.85rem;
            }

            /* å¦‚æœå±å¹•ç‰¹åˆ«å°ï¼ˆå¦‚ iPhone SEï¼‰ï¼Œç¨å¾®å‹ç¼©ä¸€ä¸‹é¡¶éƒ¨æŒ‰é’®çš„è¾¹è· */
            #hud {
                padding: 10px 10px;
            }
        }

        /* é¡¶éƒ¨å¸¸é©»æŒ‰é’®ç»„ */
        .top-controls {
            display: flex;
            gap: 10px;
            pointer-events: auto;
            /* æ¢å¤æŒ‰é’®äº¤äº’ */
        }

        .icon-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        #grid-wrapper {
            position: relative;
            padding: 4px;
            border: 1px solid var(--cell-border-light);
            background: var(--grid-bg);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;

            transform-origin: 0 0;
            transition: margin 0.3s, transform 180ms ease;
            will-change: transform;
            /* è¿™é‡Œçš„ position: relative ä¸å†é™åˆ¶ canvasï¼Œå› ä¸º canvas å·²ç»æ˜¯ fixed äº† */
        }

        #grid {
            display: grid;
            border: 1px solid var(--cell-border-light);
            position: relative;
            z-index: 2;
        }

        #ray-canvas {
            position: fixed;
            /* æ”¹ä¸º fixed å…¨å± */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            /* å…³é”®ï¼šè®©é¼ æ ‡ç‚¹å‡»èƒ½ç©¿é€å®ƒç‚¹åˆ°åº•ä¸‹çš„æ¸¸æˆ */
            z-index: 50;
            /* ç¡®ä¿å®ƒåœ¨ç½‘æ ¼ä¹‹ä¸Šï¼Œä½†åœ¨å¼¹çª—(z-index:100)ä¹‹ä¸‹ */
            mix-blend-mode: screen;
            /* ä¿æŒåŸæœ‰çš„æ··åˆæ¨¡å¼ */

            will-change: transform, opacity;
            transform: translateZ(0);
        }

        .cell {
            background-color: var(--cell-unrevealed);
            border: 1px solid #333;
            box-shadow: inset 1px 1px 0 rgba(255, 255, 255, 0.05), inset -1px -1px 0 rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s;
            position: relative;
            font-size: clamp(8px, calc(var(--cs, 30px) * 0.55), 18px);
            color: transparent;
            transition: background-color 0.2s ease-out, color 0.2s ease-out;
        }

        .cell.active {
            background-color: #333;
            box-shadow: inset 0 0 10px var(--neon-blue);
        }

        .cell.revealed {
            background-color: var(--cell-revealed);
            border: 1px solid #111;
            box-shadow: none;
            color: inherit;
            cursor: default;
            transition: background-color 0.3s ease-out;
        }

        .cell.marked::after {
            content: '';
            /* æ¸…ç©ºæ–‡å­—å†…å®¹ */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* ç»å¯¹å®šä½å±…ä¸­ */

            width: 60%;
            /* æ§åˆ¶ç›¾ç‰Œå¤§å°ï¼Œç›¸å¯¹äºæ ¼å­ */
            height: 60%;

            /* æ ¸å¿ƒæŠ€æœ¯ï¼šä½¿ç”¨ CSS å˜é‡ä½œä¸ºèƒŒæ™¯è‰² */
            background-color: var(--neon-green);

            /* æ ¸å¿ƒæŠ€æœ¯ï¼šä½¿ç”¨ SVG ä½œä¸ºé®ç½©æ¥å¡‘é€ å½¢çŠ¶ */
            /* è¿™é‡Œä½¿ç”¨çš„æ˜¯é€‰é¡¹ B (æ£±è§’ç›¾ç‰Œ) çš„ URL ç¼–ç æ•°æ® */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            /* ä½¿ç”¨ box-shadow ä»£æ›¿ text-shadow æ¥åˆ¶é€ å‘å…‰æ•ˆæœ */
            box-shadow: 0 0 10px var(--neon-green);

            opacity: 0.9;
            pointer-events: none;
            /* ç¡®ä¿é¼ æ ‡äº‹ä»¶ç©¿é€å›¾æ ‡æ‰“åˆ°æ ¼å­ä¸Š */
            z-index: 5;
        }

        .cell[data-num="0"] {
            color: #222;
        }

        .cell[data-num="1"] {
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
        }

        .cell[data-num="2"] {
            color: var(--neon-green);
            text-shadow: 0 0 8px var(--neon-green);
        }

        .cell[data-num="3"] {
            color: var(--neon-yellow);
            text-shadow: 0 0 8px var(--neon-yellow);
        }

        .cell[data-num="4"] {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }

        .cell[data-num="5"] {
            color: var(--neon-red);
            text-shadow: 0 0 8px var(--neon-red);
        }

        .cell[data-num="6"] {
            color: cyan;
        }

        .cell[data-num="7"] {
            color: white;
        }

        .cell[data-num="8"] {
            color: grey;
        }

        .cell.mine-flash {
            background-color: #fff !important;
            transition: background-color 0.05s;
            box-shadow: 0 0 20px #fff;
            z-index: 10;
        }

        .cell.mine {
            background-color: rgba(255, 0, 60, 0.2);
            border: 1px solid var(--neon-red);
            box-shadow: inset 0 0 10px rgba(255, 0, 60, 0.3);
            animation: pulse-border 1.5s infinite;
            color: var(--neon-red) !important;
            text-shadow: 0 0 8px var(--neon-red);
        }

        @keyframes pulse-border {
            0% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }

            50% {
                box-shadow: inset 0 0 15px rgba(255, 0, 60, 0.6);
            }

            100% {
                box-shadow: inset 0 0 5px rgba(255, 0, 60, 0.3);
            }
        }

        /* å“åº”å¼å·¥å…·æ  */
        #toolbar {
            position: fixed;
            z-index: 30;
            display: flex;
            gap: 15px;
            padding: 10px;
            pointer-events: auto;
        }

        /* ç«–å±æ¨¡å¼ (Portrait): å·¥å…·æ åœ¨åº•éƒ¨ */
        @media (orientation: portrait) {
            #toolbar {
                bottom: calc(60px + env(safe-area-inset-bottom));
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
            }

            /* === PATCH: ä¸å†ç”¨ margin-bottom æ¨ grid === */
            #grid-wrapper {
                margin: 0 !important;
            }
        }

        /* æ¨ªå±æ¨¡å¼ (Landscape): å·¥å…·æ åœ¨å³ä¾§ */
        @media (orientation: landscape) {
            #toolbar {
                right: calc(20px + env(safe-area-inset-right));
                top: 50%;
                transform: translateY(-50%);
                flex-direction: column;
            }

            /* === PATCH: ä¸å†ç”¨ margin-right æ¨ grid === */
            #grid-wrapper {
                margin: 0 !important;
            }
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #666;
            border-radius: 8px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: -2px 2px 10px rgba(0, 0, 0, 0.5);
            touch-action: manipulation;
        }

        .tool-btn span {
            pointer-events: none;
        }

        .tool-btn.active {
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: scale(1.1);
        }

        .tool-btn#btn-mode-mark.active {
            background: rgba(0, 255, 102, 0.15);
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 15px rgba(0, 255, 102, 0.3);
        }

        #btn-mode-mark span {
            display: inline-block;
            width: 28px;
            /* è®¾ç½®å›¾æ ‡å®½åº¦ */
            height: 28px;
            /* è®¾ç½®å›¾æ ‡é«˜åº¦ */

            /* æ ¸å¿ƒï¼šè®©èƒŒæ™¯è‰²ç»§æ‰¿çˆ¶çº§æŒ‰é’®çš„é¢œè‰² (ç°è‰²æˆ–éœ“è™¹ç»¿) */
            background-color: currentColor;

            /* ä½¿ç”¨ä¸æ ¼å­æ ‡è®°ç›¸åŒçš„ SVG é®ç½© */
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'%3E%3Cpath d='M21 11c0 5.55-3.84 10.74-9 12-5.16-1.26-9-6.45-9-12V5l9-4 9 4v6zm-9 10c3.75-1 7-5.46 7-9.78V6.3l-7-3.12-7 3.12v4.92c0 4.32 3.25 8.78 7 9.78z'/%3E%3C/svg%3E");

            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;

            pointer-events: none;
            /* ä¿æŒç©¿é€ */
        }

        #guide-text {
            position: fixed;
            bottom: calc(12px + env(safe-area-inset-bottom));
            left: 0;
            right: 0;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            text-shadow: 0 0 3px black;
            z-index: 20;
            background: none;
            padding: 0;
        }

        #menu-overlay,
        #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #menu-overlay {
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            /* è¦†ç›– body çš„ touch-action:noneï¼Œè®©èœå•èƒ½æ»šåŠ¨ */
            justify-content: flex-start;
            /* é¿å…å†…å®¹è¶…é«˜æ—¶â€œå±…ä¸­â€å¯¼è‡´ä¸Šä¸‹éƒ½è¢«æŒ¤æ²¡ */
            padding-top: calc(80px + env(safe-area-inset-top));
            padding-bottom: calc(24px + env(safe-area-inset-bottom));
            box-sizing: border-box;
        }

        h1 {
            color: var(--neon-blue);
            text-shadow: 0 0 15px var(--neon-blue);
            font-size: 2.5rem;
            margin-bottom: 2rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-align: center;
        }

        .control-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 300px;
        }

        label {
            color: var(--neon-green);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: #333;
            height: 6px;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--neon-blue);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-blue);
            border: 2px solid #fff;
        }

        .hidden {
            display: none !important;
        }

        #end-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .win {
            color: var(--neon-green);
            text-shadow: 0 0 20px var(--neon-green);
        }

        .lose {
            color: var(--neon-red);
            text-shadow: 0 0 20px var(--neon-red);
        }

        /* === è®¡æ—¶å™¨æ ·å¼ === */
        #timer-display {
            font-family: 'Cyber', monospace;
            color: var(--neon-blue);
            min-width: 60px;
            display: inline-block;
        }

        /* === å…¨æ–°çš„ç»“ç®—å¡ç‰‡æ ·å¼ === */
        .result-card {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 0, 0, 0.8);
            padding: 2px;
            /* ç»™å†…è¾¹æ¡†ç•™ç©º */
            width: 90%;
            max-width: 400px;
            position: relative;
            backdrop-filter: blur(10px);
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* åŠ¨ç”»æ¿€æ´»çŠ¶æ€ */
        #game-over-overlay:not(.hidden) .result-card {
            transform: scale(1);
            opacity: 1;
        }

        .card-header {
            background: rgba(0, 243, 255, 0.1);
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid #333;
            position: relative;
            overflow: hidden;
        }

        .card-header h2 {
            margin: 0;
            font-size: 1.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* æ‰«æçº¿åŠ¨ç”» */
        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--neon-blue);
            opacity: 0.5;
            animation: scan-down 2s linear infinite;
        }

        @keyframes scan-down {
            0% {
                top: 0%;
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                top: 100%;
                opacity: 0;
            }
        }

        .card-body {
            padding: 20px 30px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            border-bottom: 1px dashed #333;
            padding-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        .stat-value {
            color: var(--text-main);
            font-weight: bold;
            font-family: 'Cyber', monospace;
            font-size: 1.1rem;
        }

        .flavor-text {
            text-align: center;
            margin-top: 20px;
            color: #888;
            font-style: italic;
            font-size: 0.9rem;
        }

        .card-actions {
            padding: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        /* èƒœåˆ©æ—¶çš„å¡ç‰‡é…è‰²å˜ç§ */
        .result-card.win-theme {
            border-color: var(--neon-green);
            box-shadow: 0 0 30px rgba(0, 255, 102, 0.15);
        }

        .result-card.win-theme .card-header {
            background: rgba(0, 255, 102, 0.1);
        }

        .result-card.win-theme .scan-line {
            background: var(--neon-green);
        }

        /* å¤±è´¥æ—¶çš„å¡ç‰‡é…è‰²å˜ç§ */
        .result-card.lose-theme {
            border-color: var(--neon-red);
            box-shadow: 0 0 30px rgba(255, 0, 60, 0.15);
        }

        .result-card.lose-theme .card-header {
            background: rgba(255, 0, 60, 0.1);
        }

        .result-card.lose-theme .scan-line {
            background: var(--neon-red);
        }


        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 110;
            /* æ¯” menu/gameover æ›´é«˜ä¹Ÿæ²¡é—®é¢˜ */
        }

        /* === ä¿®æ”¹ .tutorial-cardï¼šå¢åŠ å¼¹æ€§å¸ƒå±€å’Œæœ€å¤§é«˜åº¦ === */
        .tutorial-card {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 20px rgba(0, 0, 0, 0.8);
            padding: 2px;
            /* ä¿æŒåŸæœ‰çš„ padding */
            width: 92%;
            max-width: 560px;
            backdrop-filter: blur(10px);

            /* --- æ–°å¢ä¿®å¤ä»£ç  --- */
            display: flex;
            /* å¼€å¯ Flex å¸ƒå±€ */
            flex-direction: column;
            /* å‚ç›´æ’åˆ— */
            max-height: 85vh;
            max-height: 85dvh;
            /* é™åˆ¶æœ€å¤§é«˜åº¦ä¸ºè§†å£é«˜åº¦çš„ 85% */
            overflow: hidden;
            /* é˜²æ­¢å¡ç‰‡è‡ªèº«æº¢å‡º */
        }

        /* === ä¿®æ”¹ .card-bodyï¼šå…è®¸å†…éƒ¨æ»šåŠ¨ === */
        .tutorial-card .card-body {
            /* ç»§æ‰¿åŸæœ‰çš„ padding: 20px 30px; ä½†å»ºè®®åœ¨æ‰‹æœºä¸Šç¼©å°ä¸€ç‚¹ */
            padding: 20px;

            /* --- æ–°å¢ä¿®å¤ä»£ç  --- */
            overflow-y: auto;
            /* å…è®¸å‚ç›´æ»šåŠ¨ */
            flex: 1;
            /* å æ®å‰©ä½™ç©ºé—´ */
            min-height: 0;
            /* Firefox Flex æ»šåŠ¨ä¿®å¤ */
            -webkit-overflow-scrolling: touch;
            /* iOS å¹³æ»‘æ»šåŠ¨ */
        }

        /* === æ–°å¢ï¼šé˜²æ­¢æ ‡é¢˜å’Œåº•éƒ¨æŒ‰é’®è¢«å‹ç¼© === */
        .tutorial-card .card-header,
        .tutorial-card .card-actions {
            flex-shrink: 0;
            /* ç¦æ­¢å‹ç¼©å¤´éƒ¨å’Œåº•éƒ¨ */
            background: rgba(10, 10, 15, 0.95);
            /* åŠ æ·±èƒŒæ™¯é˜²æ­¢æ–‡å­—é€è§†é‡å  */
            z-index: 2;
        }

        /* é’ˆå¯¹æ‰‹æœºæ¨ªå±çš„é¢å¤–ä¼˜åŒ– */
        @media (max-height: 500px) {
            .tutorial-card {
                max-height: 95vh;
                max-height: 95dvh;
                /* æ¨ªå±æ—¶åˆ©ç”¨æ›´å¤šé«˜åº¦ */
            }

            .tutorial-card .card-body {
                padding: 10px 20px;
            }
        }

        .tutorial-section-title {
            color: var(--neon-green);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }

        .tutorial-grid {
            display: grid;
            grid-template-columns: 92px 1fr 1fr;
            gap: 8px 12px;
            align-items: start;
        }

        .tutorial-col-head {
            color: var(--neon-blue);
            text-shadow: 0 0 8px var(--neon-blue);
            font-weight: bold;
            font-size: 0.9rem;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }

        .tutorial-col-head:nth-child(1) {
            grid-column: 2 / 3;
        }

        .tutorial-col-head:nth-child(2) {
            grid-column: 3 / 4;
        }

        .tutorial-label {
            color: #666;
            font-size: 0.85rem;
            padding-top: 4px;
            border-bottom: 1px dashed #222;
        }

        .tutorial-item {
            color: var(--text-main);
            font-size: 0.9rem;
            line-height: 1.35;
            border-bottom: 1px dashed #222;
            padding-bottom: 6px;
        }

        @media (max-width: 420px) {
            .tutorial-grid {
                grid-template-columns: 78px 1fr 1fr;
                gap: 6px 10px;
            }

            .tutorial-item {
                font-size: 0.85rem;
            }
        }

        /* --- å·¦ä¸Šè§’å¤´åƒæŒ‚ä»¶ (çª—å£å†…) --- */
        #profile-link {
            position: fixed;
            top: calc(12px + env(safe-area-inset-top));
            left: calc(12px + env(safe-area-inset-left));
            /* è°ƒæ•´åˆ°çª—å£å†…éƒ¨å·¦ä¸Šè§’çš„åˆé€‚ä½ç½® */
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            /* ç¨å¾®ç¼©è¿›ä¸€ç‚¹é—´è· */
            text-decoration: none;
            /* ç¡®ä¿åœ¨å¯åŠ¨å±å¹•(z-index:100)ä¹‹ä¸Š */
            z-index: 120;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        #profile-link:hover {
            filter: brightness(1.2);
        }

        #profile-link:hover img {
            box-shadow: 0 0 20px #00f3ff;
            transform: scale(1.05) rotate(5deg);
            /* å¢åŠ ä¸€ç‚¹ç‚¹æ—‹è½¬åŠ¨æ„Ÿ */
        }

        #profile-link img {
            width: 45px;
            /* ç¨å¾®ç¼©å°ä¸€ç‚¹ç‚¹ä»¥é€‚åº”å†…éƒ¨ç©ºé—´ */
            height: 45px;
            /* æ ¸å¿ƒä¿®æ”¹ï¼šåœ†å½¢è’™ç‰ˆ */
            border-radius: 50%;
            border: 2px solid #00f3ff;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            background: #000;
            object-fit: cover;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .profile-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .profile-name {
            color: #e0fbfc;
            font-size: 0.9rem;
            /* å­—ä½“ç¨å¾®å‡å°é€‚é… */
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
            font-family: 'Courier New', monospace;
        }

        .profile-role {
            color: #005f73;
            font-size: 0.6rem;
            letter-spacing: 2px;
            font-weight: bold;
        }

        select {
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            outline: none;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);

            border-radius: 0;
            background-clip: padding-box;
        }

        select:hover {
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
        }

        select option {
            background: #000;
            color: var(--neon-blue);
        }

        /* åŒ…è£¹æ»‘å—çš„å®¹å™¨ï¼Œç”¨äºæ•´ä½“éšè— */
        #custom-settings {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* è°ƒæ•´å¤´åƒä½ç½®ï¼Œé¿å…è¢«ç»ˆç«¯æŒ¡ä½ */
        #profile-link {
            top: 15px;
            left: 15px;
        }

        /* 1. ç»ˆç«¯ä¸»å®¹å™¨ */
        .menu-terminal {
            background: rgba(5, 5, 10, 0.85);
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15), inset 0 0 30px rgba(0, 0, 0, 0.8);
            padding: 30px;
            width: 90%;
            max-width: 800px;
            /* é™åˆ¶æœ€å¤§å®½åº¦ï¼Œå¤§å±æ›´ç²¾è‡´ */
            backdrop-filter: blur(10px);
            position: relative;
            /* åˆ‡è§’æ•ˆæœ */
            clip-path: polygon(0 0,
                    100% 0,
                    100% calc(100% - 20px),
                    calc(100% - 20px) 100%,
                    0 100%);
        }

        /* ç»ˆç«¯å››è§’è£…é¥° (ä¼ªå…ƒç´ å®ç°) */
        .menu-terminal::before,
        .menu-terminal::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            border: 2px solid var(--neon-blue);
            pointer-events: none;
        }

        .menu-terminal::before {
            top: 0;
            left: 0;
            border-right: none;
            border-bottom: none;
        }

        .menu-terminal::after {
            bottom: 0;
            right: 0;
            border-left: none;
            border-top: none;
        }

        /* 2. å¤´éƒ¨åŒºåŸŸ */
        .menu-header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        /* è¦†ç›–åŸæœ‰çš„ h1 æ ·å¼ */
        .menu-header h1 {
            margin: 0 0 10px 0;
            font-size: 3rem;
            letter-spacing: 8px;
            text-shadow: 0 0 20px var(--neon-blue);
        }

        .terminal-subtitle {
            color: var(--neon-green);
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        .deco-slash {
            color: #444;
            margin: 0 5px;
        }

        .header-deco-line {
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
            margin-top: 15px;
            opacity: 0.5;
        }

        /* 3. ä¸»ä½“åŒºåŸŸï¼ˆåŒæ å¸ƒå±€ï¼‰ */
        .menu-body {
            display: grid;
            grid-template-columns: 1fr 1fr;
            /* å¤§å±åŒæ  */
            gap: 25px;
            margin-bottom: 30px;
        }

        /* 4. é€šç”¨é¢æ¿æ ·å¼ */
        .cyber-panel {
            background: rgba(0, 243, 255, 0.03);
            border: 1px solid rgba(0, 243, 255, 0.3);
            padding: 20px;
            position: relative;
            min-height: 220px;
            /* ä¿è¯ä¸¤è¾¹é«˜åº¦å¤§è‡´å¹³è¡¡ */
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            margin: 0 0 20px 0;
            color: var(--neon-blue);
            font-size: 1.1rem;
            letter-spacing: 1px;
            border-bottom: 1px dashed rgba(0, 243, 255, 0.2);
            padding-bottom: 10px;
        }

        .deco-marker {
            color: var(--neon-green);
            margin-right: 8px;
            font-size: 0.8rem;
        }

        /* ä¿®æ”¹ control-group ä»¥é€‚åº”é¢æ¿ */
        .control-group.wide {
            width: 100%;
            max-width: none;
            margin: 15px 0;
            align-items: flex-start;
            /* label å·¦å¯¹é½ */
        }

        /* å¼ºåŒ– select æ ·å¼ */
        select {
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid var(--neon-blue);
            box-shadow: inset 0 0 10px rgba(0, 243, 255, 0.1);
            padding: 10px;
            font-size: 1rem;
            transition: all 0.3s;
        }

        select:hover,
        select:focus {
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            background: rgba(0, 20, 30, 1);
        }

        /* åè®®æè¿°æ–‡æœ¬ */
        .terminal-text {
            margin-top: auto;
            /* æ¨åˆ°åº•éƒ¨ */
            color: #888;
            font-size: 0.9rem;
            border-top: 1px solid #222;
            padding-top: 15px;
            text-align: left;
            line-height: 1.5;
        }

        /* é«˜äº®æ•°å€¼ */
        .val-highlight {
            color: var(--neon-blue);
            font-weight: bold;
            margin-left: 5px;
            text-shadow: 0 0 5px var(--neon-blue);
        }

        /* å‚æ•°é”å®šæ—¶çš„å ä½åŠ¨ç”» */
        #parameter-locked {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #444;
            font-family: 'Cyber', monospace;
        }

        #custom-settings.hidden+#parameter-locked {
            display: flex;
            /* å½“è‡ªå®šä¹‰è®¾ç½®éšè—æ—¶ï¼Œæ˜¾ç¤ºå ä½ç¬¦ */
        }

        #parameter-locked {
            display: none;
            /* é»˜è®¤éšè— */
        }

        .blink-text {
            animation: blink 1.5s infinite;
            color: var(--neon-green);
            opacity: 0.7;
            letter-spacing: 1px;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 0.7;
            }

            50% {
                opacity: 0.2;
            }
        }

        .data-stream-deco {
            width: 80%;
            height: 2px;
            background: repeating-linear-gradient(90deg, #444 0%, #444 5%, transparent 5%, transparent 10%);
            margin-top: 15px;
            animation: data-scroll 2s linear infinite;
            opacity: 0.3;
        }

        @keyframes data-scroll {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 50px 0;
            }
        }

        /* 5. åº•éƒ¨æ“ä½œåŒº */
        .menu-actions {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }

        .menu-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            font-size: 1.1rem;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .menu-btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue);

        }

        /* å¼ºåŒ–æŒ‰é’®æ ·å¼ */
        .menu-btn {
            margin-top: 0;
            /* ç§»é™¤æ—§ margin */
            flex: 1;
            /* æŒ‰é’®å‡åˆ†å®½åº¦ */
            max-width: 240px;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        /* ä¸»è¦æŒ‰é’® (å¯åŠ¨) - æ›´å¤§æ›´äº® */
        .primary-btn {
            background: rgba(0, 243, 255, 0.15);
            font-size: 1.2rem;
            padding: 15px 30px;
            border-width: 2px;
            font-weight: bold;
        }

        .primary-btn:hover {
            background: var(--neon-blue);
            box-shadow: 0 0 40px var(--neon-blue);
        }

        /* æ¬¡è¦æŒ‰é’® (æ•™ç¨‹) */
        .secondary-btn {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        @media (max-width: 640px) {
            .menu-terminal {
                width: calc(100% - 24px);
                padding: 16px;
                border: 0;
                clip-path: none;
            }

            .menu-terminal::before,
            .menu-terminal::after {
                display: none;
            }

            .menu-header h1 {
                font-size: 2.2rem;
            }

            .menu-body {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .cyber-panel {
                min-height: auto;
                padding: 15px;
            }

            .panel-title {
                margin-bottom: 15px;
            }

            .menu-actions {
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 12px;
            }

            .menu-btn {
                max-width: none;
                flex: 1 1 0;
                min-width: 0;
                padding: 12px 10px;
            }

            .primary-btn,
            .secondary-btn {
                font-size: 1.05rem;
            }
        }

        /* æ¨ªå±ä½†é«˜åº¦ä¸å¤Ÿï¼šæ•´ä½“è½»å¾®ç¼©å°ï¼Œå°½é‡ä¸å‡ºç°æ»šåŠ¨ */
        @media (orientation: landscape) and (max-height: 700px) {
            .menu-terminal {
                transform: scale(0.92);
                transform-origin: top center;
            }

            /* é¢å¤–æ”¶ç´§ä¸€äº›â€œé«˜åº¦æ€æ‰‹â€ */
            .menu-header {
                margin-bottom: 18px;
            }

            .menu-body {
                margin-bottom: 18px;
                gap: 16px;
            }

            .cyber-panel {
                padding: 12px;
            }

            .panel-title {
                margin: 0 0 12px 0;
                padding-bottom: 8px;
            }
        }

        /* æ›´æç«¯çš„çŸ®æ¨ªå±ï¼ˆåˆ†å±/å°å¹³æ¿ï¼‰ï¼šå†ç¼©ä¸€ç‚¹ç‚¹ */
        @media (orientation: landscape) and (max-height: 580px) {
            .menu-terminal {
                transform: scale(0.86);
            }
        }

        @media (min-height: 820px) {
            #menu-overlay {
                justify-content: center;
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
            }
        }

        /* ================================
            Cyber Scrollbarï¼ˆèœå• & æ•™ç¨‹ï¼‰
        ================================ */

        /* WebKit ç³»ï¼ˆChrome / Safari / iOS / Edgeï¼‰ */
        #menu-overlay::-webkit-scrollbar,
        .tutorial-card .card-body::-webkit-scrollbar {
            width: 8px;
        }

        #menu-overlay::-webkit-scrollbar-track,
        .tutorial-card .card-body::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.4);
            border-left: 1px solid rgba(0, 243, 255, 0.15);
        }

        #menu-overlay::-webkit-scrollbar-thumb,
        .tutorial-card .card-body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg,
                    rgba(0, 243, 255, 0.9),
                    rgba(0, 243, 255, 0.4));
            border-radius: 6px;
            box-shadow:
                0 0 8px rgba(0, 243, 255, 0.6),
                inset 0 0 6px rgba(255, 255, 255, 0.25);
        }

        #menu-overlay::-webkit-scrollbar-thumb:hover,
        .tutorial-card .card-body::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 243, 255, 1);
        }

        /* Firefoxï¼ˆé€€åŒ–ä½†å¹²å‡€ï¼‰ */
        #menu-overlay,
        .tutorial-card .card-body {
            scrollbar-width: thin;
            scrollbar-color: var(--neon-blue) rgba(0, 0, 0, 0.4);
        }
    </style>
</head>

<body>
    <div class="scanlines"></div>

    <div id="game-container">
        <div id="hud">
            <div class="hud-info">
                <div>ç›®æ ‡: <span id="mines-left">0</span></div>
                <div>æ—¶é—´: <span id="timer-display">00:00</span></div>
                <div>çŠ¶æ€: <span id="status-text" style="color:var(--neon-green)">å°±ç»ª</span></div>
            </div>
            <div class="top-controls">
                <div class="icon-btn" id="btn-ingame-tutorial" title="æ•™ç¨‹">?</div>
                <div class="icon-btn" id="btn-ingame-mute" title="é™éŸ³/å–æ¶ˆé™éŸ³">ğŸ”Š</div>
                <div class="icon-btn" id="btn-ingame-restart" title="é‡å¼€">â†»</div>
                <div class="icon-btn" id="btn-ingame-menu" title="èœå•">â˜°</div>
            </div>
        </div>

        <div id="game-over-overlay" class="hidden">
            <div class="result-card">
                <div class="card-header">
                    <h2 id="end-title">MISSION COMPLETE</h2>
                    <div class="scan-line"></div>
                </div>

                <div class="card-body">
                    <div class="stat-row">
                        <span class="stat-label">è€—æ—¶</span>
                        <span class="stat-value" id="end-time">00:00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">éš¾åº¦</span>
                        <span class="stat-value" id="end-difficulty">NORMAL</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">å®Œæˆåº¦</span>
                        <span class="stat-value" id="end-percentage">100%</span>
                    </div>

                    <p id="end-reason" class="flavor-text">æ‰€æœ‰å¨èƒå·²æ¶ˆé™¤</p>
                </div>

                <div class="card-actions">
                    <button class="menu-btn" id="btn-restart">é‡å¯ç³»ç»Ÿ</button>
                    <button class="menu-btn secondary" id="btn-menu">è¿”å›èœå•</button>
                </div>
            </div>
        </div>

        <div id="grid-wrapper">
            <div id="grid"></div>
        </div>

        <canvas id="ray-canvas"></canvas>

        <div id="guide-text">ç‚¹å‡»æ ‡è®°å®‰å…¨åŒº<br>ä»æ ¼å­æ‹–åŠ¨ï¼ˆå…«æ–¹å‘ï¼‰å¼•çˆ†éšè—åœ°é›·<br>é¼ æ ‡æ»šè½®/åŒæŒ‡è½»è§¦ç¼©æ”¾ä½œæˆ˜åŒº</div>
    </div>

    <div id="menu-overlay">
        <a id="profile-link" href="/">
            <img src="/avatar.jpg" alt="Avatar">
            <div class="profile-info">
                <span class="profile-name">å›åˆ°ä¸»é¡µ</span>
                <span class="profile-role">çŠ¶æ€ï¼šå·²è¿æ¥</span>
            </div>
        </a>

        <div class="menu-terminal">
            <div class="menu-header">
                <h1>MINESEEKER</h1>
                <div class="terminal-subtitle">
                    <span class="deco-slash">//</span> æˆ˜æœ¯å¯»é›·ç³»ç»Ÿæ¥å…¥ç»ˆç«¯ <span class="deco-slash">//</span>
                </div>
                <div class="header-deco-line"></div>
            </div>

            <div class="menu-body">
                <div class="cyber-panel protocol-panel">
                    <h3 class="panel-title">
                        <span class="deco-marker">â–º</span> åè®®è£…è½½
                    </h3>
                    <div class="control-group wide">
                        <select id="difficulty-select">
                            <option value="normal">æ™®é€šåè®®</option>
                            <option value="enhanced">å¢å¼ºåè®®</option>
                            <option value="ultimate">ç»ˆæåè®®</option>
                            <option value="custom">è‡ªå®šä¹‰å‚æ•°</option>
                        </select>
                    </div>
                    <div id="protocol-desc" class="flavor-text terminal-text">
                        æ ‡å‡†å¯»é›·ä»»åŠ¡é…ç½®ã€‚é€‚ç”¨äºåˆæ­¥å‹˜æ¢ã€‚
                    </div>
                </div>

                <div class="cyber-panel parameter-panel">
                    <h3 class="panel-title">
                        <span class="deco-marker">â–º</span> å‚æ•°æ ¡å‡†
                    </h3>

                    <div id="custom-settings" class="hidden">
                        <div class="control-group wide">
                            <label>ç½‘æ ¼å®½åº¦: <span id="val-w" class="val-highlight">10</span></label>
                            <input type="range" id="inp-w" min="8" max="32" value="10">
                        </div>
                        <div class="control-group wide">
                            <label>ç½‘æ ¼é«˜åº¦: <span id="val-h" class="val-highlight">15</span></label>
                            <input type="range" id="inp-h" min="8" max="32" value="15">
                        </div>
                        <div class="control-group wide">
                            <label>åœ°é›·å¯†åº¦: <span id="val-d" class="val-highlight">30%</span></label>
                            <input type="range" id="inp-d" min="25" max="75" value="30" step="5">
                        </div>
                    </div>

                    <div id="parameter-locked">
                        <div class="locked-status">
                            <span class="blink-text">>> å‚æ•°å·²é”å®šï¼Œç­‰å¾…æ‰§è¡Œ <<< </span>
                        </div>
                        <div class="data-stream-deco"></div>
                    </div>
                </div>
            </div>

            <div class="menu-actions">
                <button class="menu-btn primary-btn" id="btn-start">å¯åŠ¨åè®®</button>
                <button class="menu-btn secondary-btn" id="btn-tutorial">ä½œæˆ˜æŒ‡å—</button>
            </div>
        </div>
    </div>

    <div id="tutorial-overlay" class="hidden">
        <div class="tutorial-card">
            <div class="card-header">
                <h2>HOW TO PLAY</h2>
                <div class="scan-line"></div>
            </div>

            <div class="card-body">
                <div class="tutorial-section-title">Minesweeper vs. Mineseeker</div>

                <div class="tutorial-grid">
                    <div class="tutorial-col-head">æ‰«é›· / MINESWEEPER</div>
                    <div class="tutorial-col-head">æ‰¾é›· / MINESEEKER</div>

                    <div class="tutorial-label">ç›®æ ‡</div>
                    <div class="tutorial-item">æ‰¾å‡ºåœ°é›· / å¼€å®Œå®‰å…¨æ ¼</div>
                    <div class="tutorial-item"><b>æ­ç¤ºæ‰€æœ‰åœ°é›·çš„ä½ç½®</b></div>

                    <div class="tutorial-label">å¤±è´¥</div>
                    <div class="tutorial-item">ç‚¹åˆ°é›· = å¤±è´¥</div>
                    <div class="tutorial-item"><b>èµ·çˆ†ç‚¹é€‰åˆ°éé›· = å¤±è´¥</b></div>

                    <div class="tutorial-label">å¼€å±€</div>
                    <div class="tutorial-item">ç¬¬ä¸€ä¸‹å¿…å®‰å…¨</div>
                    <div class="tutorial-item"><b>ç¬¬ä¸€ä¸‹å¿…æ˜¯é›·</b>ï¼ˆç›´æ¥ä»ä»»æ„ç‚¹æ‹–åŠ¨å¼€å§‹ï¼‰</div>

                    <div class="tutorial-label">æ“ä½œ</div>
                    <div class="tutorial-item">ç‚¹å‡»æ­å¼€ / æ’æ——</div>
                    <div class="tutorial-item"><b>æŒ‰ä½å¹¶æœå…«æ–¹å‘æ‹–åŠ¨</b>å‘å°„å°„çº¿ï¼›å³é”®/æ ‡è®°æ¨¡å¼å¯æ ‡è®°</div>

                    <div class="tutorial-label">å¼•çˆ†è§„åˆ™</div>
                    <div class="tutorial-item">çˆ†ç‚¸åæ¸¸æˆç»“æŸ</div>
                    <div class="tutorial-item">
                        <b>å¼•çˆ†â†’å†²å‡»æ³¢â†’å°„çº¿</b><br>
                        â‘  æ­ç¤ºå‘¨å›´8æ ¼<br>
                        â‘¡ å°„çº¿æ²¿æ‹–åŠ¨æ–¹å‘ç©¿é€<b>è‡³å¤š4æ ¼æœªæ­ç¤ºæ ¼</b>ï¼ˆåŠ ä¸Šâ‘ åˆ™è·¯å¾„è‡³å°‘5æ ¼ï¼‰<br>
                        â‘¢ å°„çº¿å‘½ä¸­æœªæ­ç¤ºåœ°é›·ä¼šæœåŒæ–¹å‘å¼•çˆ†ï¼Œé€ æˆè¿é”ååº”</b><br>
                    </div>

                    <div class="tutorial-label">æ•°å­—</div>
                    <div class="tutorial-item">å‘¨å›´8æ ¼é›·æ•°</div>
                    <div class="tutorial-item">å‘¨å›´8æ ¼é›·æ•°</div>
                </div>

                <p class="flavor-text" style="margin-top:14px;">
                    çœæµï¼š<b>æ‹–åŠ¨å‘å°„å°„çº¿ï¼›å°„çº¿èµ·ç‚¹å¿…é¡»æ˜¯éšè—åœ°é›·ï¼›æŠŠæ‰€æœ‰é›·éƒ½æ­ç¤ºå°±èµ¢ã€‚</b>
                </p>
            </div>

            <div class="card-actions">
                <button class="menu-btn" id="btn-tutorial-back">è¿”å›</button>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            gridW: 10,
            gridH: 15,
            density: 0.3,
            cellSize: 35,
            rayLength: 2,
            penetrationLimit: 4, // æœ€å¤§ç©¿é€æœªæ­å¼€æ ¼å­çš„æ•°é‡
            colors: {
                blue: '#00f3ff',
                green: '#00ff66',
                red: '#ff003c',
                yellow: '#fcee0a',
                white: '#ffffff',
                purple: '#bc13fe'
            }
        };

        const AUDIO_CTX = new (window.AudioContext || window.webkitAudioContext)();

        let gridData = [];
        let totalMines = 0;
        let revealedMines = 0;
        let isFirstMove = true;
        let isGameOver = false;

        let gameStartTime = 0;
        let timerInterval = null;
        let elapsedTime = 0;

        const rayCanvas = document.getElementById('ray-canvas');
        const rayCtx = rayCanvas.getContext('2d');
        let animationFrameId;
        let activeEffects = [];
        let comboCounter = 0;

        const gridEl = document.getElementById('grid');
        const hudMines = document.getElementById('mines-left');
        const hudStatus = document.getElementById('status-text');

        let startCell = null;
        let isDragging = false;
        let dragLine = { x: 0, y: 0 };

        let isMuted = localStorage.getItem('mineseeker_mute') === 'true';

        function playSound(type) {
            if (isMuted) return;
            if (AUDIO_CTX.state === 'suspended') AUDIO_CTX.resume();
            const osc = AUDIO_CTX.createOscillator();
            const gainNode = AUDIO_CTX.createGain();
            osc.connect(gainNode);
            gainNode.connect(AUDIO_CTX.destination);

            const t = AUDIO_CTX.currentTime;

            if (type === 'hover') {
                osc.frequency.setValueAtTime(800, t);
                gainNode.gain.setValueAtTime(0.01, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.05);
            } else if (type === 'mark') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, t);
                gainNode.gain.setValueAtTime(0.05, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
            } else if (type === 'ray') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(500, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                gainNode.gain.setValueAtTime(0.15, t);
                gainNode.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t);
                osc.stop(t + 0.2);
            } else if (type === 'explode') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.start(t);
                osc.stop(t + 0.4);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.5);
                gainNode.gain.setValueAtTime(0.3, t);
                gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.start(t);
                osc.stop(t + 0.5);
            } else if (type === 'ui-click') {
                const dur = 0.02; // 20ms
                const sampleRate = AUDIO_CTX.sampleRate;
                const frameCount = Math.floor(sampleRate * dur);
                const buffer = AUDIO_CTX.createBuffer(1, frameCount, sampleRate);
                const data = buffer.getChannelData(0);

                // ç”ŸæˆçŸ­å™ªå£° + å¿«é€Ÿè¡°å‡ï¼ˆå‰é¢æ›´å¼ºï¼Œåé¢å¿«é€Ÿæ”¶ï¼‰
                for (let i = 0; i < frameCount; i++) {
                    const x = i / frameCount;
                    const env = Math.pow(1 - x, 6); // è¡°å‡æ›²çº¿ï¼ŒæŒ‡æ•°è¶Šå¤§è¶Šâ€œå’”â€
                    data[i] = (Math.random() * 2 - 1) * env;
                }

                const src = AUDIO_CTX.createBufferSource();
                src.buffer = buffer;

                const hp = AUDIO_CTX.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.setValueAtTime(800, t); // å»æ‰ä½é¢‘å—¡å—¡

                const bp = AUDIO_CTX.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.setValueAtTime(2500, t); // ç‚¹å‡»çš„â€œå¡‘æ–™æ„Ÿâ€
                bp.Q.setValueAtTime(0.9, t);

                const gain = AUDIO_CTX.createGain();
                gain.gain.setValueAtTime(0.0, t);
                gain.gain.linearRampToValueAtTime(0.18, t + 0.001); // 1ms attack
                gain.gain.exponentialRampToValueAtTime(0.001, t + dur); // å¿«é€Ÿæ”¶å°¾

                src.connect(hp);
                hp.connect(bp);
                bp.connect(gain);
                gain.connect(AUDIO_CTX.destination);

                src.start(t);
                src.stop(t + dur);
            }
            else if (type === 'ui-tick') {
                // æ–°å¢ï¼šæ»‘å—æ‹–åŠ¨æ—¶çš„çŸ­ä¿ƒéŸ³
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, t);
                gainNode.gain.setValueAtTime(0.05, t);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
                osc.start(t);
                osc.stop(t + 0.03);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.04 + 0.02;
                this.color = color;
                this.size = Math.random() * 4 + 2;
                this.gravity = 0.2;
            }

            update(dt) {
                const f = dt * 60;

                this.x += this.vx * f;
                this.y += this.vy * f;
                this.vy += this.gravity * f;

                this.life -= this.decay * f;
                this.size *= Math.pow(0.95, f);
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class FloatingText {
            constructor(x, y, count) {
                const cs = CONFIG.cellSize;
                this.baseX = (x + 0.5) * cs;
                this.baseY = (y + 0.5) * cs;

                // â€”â€” 2~10 æ¯ä¸ªéƒ½ä¸åŒï¼šæ–‡å­—ã€è‰²ç›¸ã€æè¾¹ã€æŠ–åŠ¨ã€æ—‹è½¬ã€å…‰æ™•å¼ºåº¦ â€”â€”
                const PRESET = {
                    2: { text: 'DOUBLE', color: '#00f3ff', glow: 18, stroke: 7, size: 34, jitter: 0.8, rot: -0.10 },
                    3: { text: 'TRIPLE', color: '#00ff66', glow: 20, stroke: 7, size: 36, jitter: 1.0, rot: 0.10 },
                    4: { text: 'QUAD', color: '#bc13fe', glow: 22, stroke: 8, size: 40, jitter: 1.2, rot: -0.08 },
                    5: { text: 'PENTA', color: '#fcee0a', glow: 26, stroke: 9, size: 44, jitter: 1.5, rot: 0.06 },
                    6: { text: 'HEX', color: '#ff7a00', glow: 28, stroke: 10, size: 48, jitter: 1.8, rot: -0.05 },
                    7: { text: 'SEPT', color: '#ff003c', glow: 30, stroke: 11, size: 52, jitter: 2.2, rot: 0.04 },
                    8: { text: 'OCTA', color: '#ff00ff', glow: 34, stroke: 12, size: 58, jitter: 2.6, rot: -0.03 },
                    9: { text: 'NOVA', color: '#00ffff', glow: 38, stroke: 12, size: 64, jitter: 3.0, rot: 0.02 },
                    10: { text: 'DECA+', color: '#ffffff', glow: 44, stroke: 14, size: 72, jitter: 3.4, rot: 0.00 },
                };

                this.count = count;
                this.p = PRESET[count] || PRESET[10];
                if (count === 10) this.p.color = PRESET[Math.floor(Math.random() * 9) + 2].color;

                // è®©æ–‡å­—æ›´â€œæœ‰åŠ›â€ï¼šåˆé€Ÿåº¦æ›´é›†ä¸­ï¼ˆä¸Šå†² + è½»å¾®å·¦å³æ•£å°„ï¼‰
                this.vx = (Math.random() - 0.5) * 2.2;
                this.vy = -5.2 - Math.random() * 1.4;
                this.gravity = 0.16;

                // ç”¨â€œæ—¶é—´è¿›åº¦â€é©±åŠ¨åŠ¨ç”»ï¼ˆæ›´ç¨³å®šï¼‰
                this.t = 0;          // 0 -> 1
                this.duration = 0.75; // ç§’
                this.life = 1.0;     // å…¼å®¹ä½ ç°æœ‰çš„é”€æ¯é€»è¾‘

                // æ—‹è½¬ & æŠ–åŠ¨
                this.rot = this.p.rot + (Math.random() - 0.5) * 0.06;
                this.rotVel = (Math.random() - 0.5) * 0.012;

                // æ¯ä¸ªè¿å‡»çº§åˆ«ä¸åŒçš„â€œå±å¹•å åŠ æ„Ÿâ€
                this.additive = count >= 7;

                // åˆå§‹ä½ç½®
                this.x = this.baseX;
                this.y = this.baseY;

                // å°æŠ€å·§ï¼šé«˜è¿å‡»æ›´â€œå¼¹â€
                this.pop = 1.15 + (count - 2) * 0.03;
            }

            // easingï¼šå¼¹æ€§è¿›å…¥ + å¹³æ»‘æ¶ˆå¤±
            easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }
            easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

            update(dt) {
                // æ—¶é—´æ¨è¿›ï¼ˆ0 â†’ 1ï¼‰
                this.t += dt / this.duration;
                if (this.t > 1) this.t = 1;

                const s = window.__gridRenderScale || 1;
                const inv = 1 / s;

                // ä½ç§»ï¼ˆåƒç´ /ç§’ï¼‰
                this.x += this.vx * dt * 60 * inv;
                this.y += this.vy * dt * 60 * inv;

                // é‡åŠ›ï¼ˆåƒç´ /ç§’Â²ï¼‰
                this.vy += this.gravity * dt * 60;

                // ç©ºæ°”é˜»åŠ›ï¼ˆæŒ‡æ•°è¡°å‡ï¼‰
                const drag = Math.pow(0.96, dt * 60);
                this.vx *= drag;

                // æ—‹è½¬
                this.rot += this.rotVel * dt * 60;

                // é€æ˜åº¦
                if (this.t < 0.55) {
                    this.life = 1;
                } else {
                    this.life = Math.max(0, 1 - (this.t - 0.55) / 0.45);
                }

                // æŠ–åŠ¨å¼ºåº¦
                const jStrength = (1 - this.easeOutCubic(Math.min(this.t / 0.3, 1))) * this.p.jitter;
                this.jx = (Math.random() - 0.5) * jStrength * 2;
                this.jy = (Math.random() - 0.5) * jStrength * 2;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                // scaleï¼šå‰æ®µå¼¹å‡ºã€åæ®µå¾®ç¼©
                const popT = Math.min(this.t / 0.25, 1);
                const popScale = this.easeOutBack(popT) * this.pop;
                const settle = this.t > 0.35 ? (1 - (this.t - 0.35) * 0.12) : 1;
                const scale = popScale * settle;

                ctx.save();

                if (this.additive) ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = this.life;

                const s = window.__gridRenderScale || 1;
                const inv = 1 / s;

                ctx.translate(this.x, this.y);

                // å…ˆæŠŠå…¨å±€ç½‘æ ¼ç¼©æ”¾æŠµæ¶ˆæ‰ï¼ˆåªå½±å“å¤§å°ï¼Œä¸å½±å“è½ç‚¹ï¼‰
                ctx.scale(inv, inv);

                // æŠ–åŠ¨ä¹Ÿæ”¾åˆ°â€œåç¼©æ”¾åâ€çš„åæ ‡ç³»é‡Œï¼Œé¿å…ç¼©æ”¾åæŠ–åŠ¨è¿‡å¤§
                ctx.translate(this.jx, this.jy);

                ctx.rotate(this.rot);
                ctx.scale(scale, scale);

                // å­—ä½“ï¼šæ›´â€œæ¸¸æˆå‡»æ€æç¤ºâ€çš„æ„Ÿè§‰
                ctx.font = `italic 900 ${this.p.size}px "Arial Black", "Impact", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // 1) é»‘è‰²åšæè¾¹ï¼ˆæ¸…æ™°åº¦ï¼‰
                ctx.lineJoin = 'round';
                ctx.strokeStyle = 'rgba(0,0,0,0.95)';
                ctx.lineWidth = this.p.stroke;
                ctx.strokeText(this.p.text, 0, 0);

                // 2) å½©è‰²å¤–è¾‰å…‰ï¼ˆéœ“è™¹æ„Ÿï¼‰
                ctx.shadowBlur = 0;
                ctx.shadowColor = this.p.color;
                ctx.fillStyle = this.p.color;
                ctx.fillText(this.p.text, 0, 0);

                // 3) ç™½è‰²é«˜å…‰ï¼ˆç«‹ä½“ï¼‰
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.fillText(this.p.text, -2, -2);

                // 4) è¶…é«˜è¿å‡»ï¼šåŠ ä¸€é“â€œåˆ‡å‰²é«˜å…‰çº¿â€ï¼ˆæ›´åƒçˆ†å‘ï¼‰
                if (this.count >= 8) {
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-this.p.size * 1.2, -this.p.size * 0.2);
                    ctx.lineTo(this.p.size * 1.2, -this.p.size * 0.55);
                    ctx.stroke();
                }

                ctx.restore();
                ctx.globalCompositeOperation = 'source-over';
            }
        }


        class Shockwave {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = CONFIG.cellSize * 1.5;
                this.color = color;
                this.life = 1.0;
                this.decay = 0.08;
            }

            update(dt) {
                const f = dt * 60;
                this.radius += 3 * f;
                this.life -= this.decay * f;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class RayEffect {
            constructor(startX, startY, dirX, dirY, lengthCells, isFailure = false) {
                const cs = CONFIG.cellSize;
                this.sx = (startX + 0.5) * cs;
                this.sy = (startY + 0.5) * cs;
                this.ex = this.sx + (dirX * lengthCells * cs);
                this.ey = this.sy + (dirY * lengthCells * cs);
                this.life = 1.0;

                this.isFailure = isFailure;

                // ç”Ÿæˆä¸€ä¸ªåŸºäºä½ç½®çš„éšæœºåç§»é‡ï¼Œç”¨äºè„‰å†²åŠ¨ç”»ï¼Œ
                // ç¡®ä¿æ¯æ¡å°„çº¿çš„è„‰å†²æ­¥è°ƒä¸ä¸€è‡´ã€‚
                this.pulseOffset = (this.sx + this.sy) * 0.1 + Math.random() * 10;

                if (this.isFailure) {
                    // === å¤±è´¥å°„çº¿å‚æ•° ===
                    this.width = 2;       // ä¾ç„¶ä¿æŒæç»†
                    // è¿™é‡Œä¸å†å®šä¹‰å•ä¸€ colorï¼Œè€Œæ˜¯åœ¨ draw é‡Œå®šä¹‰è¡€è‰²å±‚æ¬¡
                    this.maxJitter = 0;   //ç¨å¾®å¢åŠ ä¸€ç‚¹æŠ–åŠ¨ï¼Œé…åˆè„‰å†²
                } else {
                    // === æ™®é€šå°„çº¿å‚æ•° ===
                    this.width = 15;
                    this.color = CONFIG.colors.blue;
                    this.maxJitter = 10;
                }

                this.jitter = 0;
            }

            update(dt) {
                const f = dt * 60;

                this.life -= (this.isFailure ? 0.03 : 0.08) * f;

                if (!this.isFailure) {
                    this.width *= Math.pow(0.9, f);
                }

                this.jitter = (Math.random() - 0.5) * this.maxJitter;
            }

            draw(ctx) {
                // å¤±è´¥æ¨¡å¼ä¾ç„¶ä½¿ç”¨ lighterï¼Œè®©äº¤å‰ç‚¹æå…¶æ˜äº®
                ctx.globalCompositeOperation = this.isFailure ? 'lighter' : 'screen';
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(this.sx, this.sy);
                ctx.lineTo(this.ex + this.jitter, this.ey + this.jitter);

                if (this.isFailure) {
                    // === ä¿®æ”¹ç‚¹ï¼šè¡€è‰²è„‰å†²æ¿€å…‰é£æ ¼ ===

                    // è®¡ç®—è„‰å†²å› å­ï¼šåˆ©ç”¨å½“å‰æ—¶é—´ + è‡ªèº«åç§»é‡è®¡ç®—æ­£å¼¦æ³¢
                    // é€Ÿåº¦è¾ƒå¿« ( * 0.02 )
                    const time = performance.now();
                    const pulseWave = Math.sin(time * 0.02 + this.pulseOffset);
                    // å°†æ­£å¼¦æ³¢(-1åˆ°1)æ˜ å°„åˆ°ä¸€ä¸ªäº®åº¦æ³¢åŠ¨èŒƒå›´ï¼Œä¾‹å¦‚ 0.6 åˆ° 1.0 ä¹‹é—´
                    const pulseFactor = (pulseWave * 0.2) + 0.8;

                    // å±‚1: æ·±è¡€è‰²å¤–æ™• (æä¾›æ·±é‚ƒçš„èƒŒæ™¯ï¼Œä¸è„‰å†²ï¼Œç¨³å®šå­˜åœ¨)
                    ctx.lineWidth = 5; // ç¨å¾®å®½ä¸€ç‚¹ç‚¹ä½œä¸ºåº•è‰²
                    ctx.strokeStyle = '#660000'; // æ·±æ²‰çš„å¹²æ¶¸è¡€è‰²
                    ctx.globalAlpha = this.life * 0.5; // åŠé€æ˜
                    ctx.stroke();

                    // å±‚2: é²œè¡€æ ¸å¿ƒ (æç»†ï¼Œé«˜é¥±å’Œï¼Œå¸¦æœ‰è„‰å†²æ•ˆæœ)
                    ctx.lineWidth = 1.5; // æç»†æ ¸å¿ƒ
                    // ä½¿ç”¨é²œè‰³çš„åŠ¨è„‰è¡€çº¢ï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„ç²‰ç™½
                    ctx.strokeStyle = '#ff0000';
                    // Alpha ç”±ç”Ÿå‘½å€¼å’Œè„‰å†²å› å­å…±åŒå†³å®š
                    ctx.globalAlpha = this.life * pulseFactor * 0.9;
                    ctx.stroke();

                } else {
                    // === æ™®é€šè“è‰²æ‰«æçº¿ (ä¿æŒåŸæ ·) ===
                    ctx.lineWidth = this.width * 3;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.2;
                    ctx.stroke();

                    ctx.lineWidth = this.width;
                    ctx.strokeStyle = this.color;
                    ctx.globalAlpha = this.life * 0.6;
                    ctx.stroke();

                    ctx.lineWidth = this.width * 0.3;
                    ctx.strokeStyle = '#ffffff';
                    ctx.globalAlpha = this.life;
                    ctx.stroke();
                }

                ctx.globalCompositeOperation = 'source-over';
            }
        }
        function startRenderLoop() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            let lastTime = performance.now();

            function loop(now) {
                const deltaTime = Math.min((now - lastTime) / 1000, 0.05);
                lastTime = now;

                // 1. è·å–ç½‘æ ¼å½“å‰åœ¨å±å¹•ä¸Šçš„å®é™…ä½ç½®
                // è¿™è§£å†³äº†ä¸åŒå±å¹•å¸ƒå±€ã€æ¨ªç«–å±åˆ‡æ¢åä½ç½®ä¸å¯¹çš„é—®é¢˜
                const rect = gridEl.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // 2. æ¸…ç©ºå…¨å±ç”»å¸ƒ
                // æ³¨æ„ï¼šå› ä¸º resizeCanvasToDisplaySize ä¼šæ”¹å˜ canvas.width/heightï¼Œ
                // æˆ‘ä»¬éœ€è¦ç”¨ canvas çš„å®é™…ç‰©ç†åƒç´ å°ºå¯¸æ¥æ¸…ç©º
                rayCtx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®çŸ©é˜µä»¥ç¡®ä¿æ¸…ç©ºå…¨å±
                rayCtx.clearRect(0, 0, rayCanvas.width, rayCanvas.height);

                // gridEl å½“å‰å±å¹•å®½åº¦ / ç†è®ºæœªç¼©æ”¾å®½åº¦ = å½“å‰ scale
                const logicalW = CONFIG.gridW * CONFIG.cellSize;
                const logicalH = CONFIG.gridH * CONFIG.cellSize;

                const scaleX = rect.width / logicalW;
                const scaleY = rect.height / logicalH;
                // é€šå¸¸ scaleXâ‰ˆscaleYï¼›å–ä¸€ä¸ªæ›´ç¨³çš„
                const s = Math.min(scaleX, scaleY) || 1;

                window.__gridRenderScale = s;

                rayCtx.setTransform(dpr * s, 0, 0, dpr * s, rect.left * dpr, rect.top * dpr);

                // --- ä¸‹é¢çš„ç»˜åˆ¶é€»è¾‘å®Œå…¨ä¸ç”¨åŠ¨ ---
                for (let i = activeEffects.length - 1; i >= 0; i--) {
                    const effect = activeEffects[i];
                    effect.update(deltaTime);
                    effect.draw(rayCtx);
                    if (effect.life <= 0) {
                        activeEffects.splice(i, 1);
                    }
                }

                animationFrameId = requestAnimationFrame(loop);
            }

            animationFrameId = requestAnimationFrame(loop);
        }

        //const MAX_PARTICLES = 150;
        function spawnExplosion(cx, cy, color = CONFIG.colors.red) {
            //if (activeEffects.length > MAX_PARTICLES) {
            //    return;
            // }

            const particleCount = 20;
            const pixelX = (cx + 0.5) * CONFIG.cellSize;
            const pixelY = (cy + 0.5) * CONFIG.cellSize;
            for (let i = 0; i < particleCount; i++) {
                activeEffects.push(new Particle(pixelX, pixelY, color));
            }
            activeEffects.push(new Shockwave(pixelX, pixelY, color));
        }

        // ä¿®æ”¹ï¼šå¢åŠ äº† length å‚æ•°ï¼Œé»˜è®¤ä¸º null
        function spawnRay(x, y, dx, dy, length = null, isFailure = false) {
            activeEffects.push(new RayEffect(x, y, dx, dy, Math.max(CONFIG.rayLength, length), isFailure));
        }

        function explodeNeighbors(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                        const neighbor = gridData[ny][nx];
                        if (!neighbor.isRevealed) {
                            neighbor.reveal();
                        }
                    }
                }
            }
        }

        function floodFill(x, y) {
            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            for (let dir of dirs) {
                const nx = x + dir.x;
                const ny = y + dir.y;

                if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                    const neighbor = gridData[ny][nx];
                    if (!neighbor.isRevealed && !neighbor.isMine && neighbor.neighborCount === 0) {
                        neighbor.reveal();
                    }
                }
            }
        }

        function animatedFloodFill(startX, startY) {
            // 1. å®šä¹‰ BFS ç»“æ„
            const queue = [{ x: startX, y: startY, dist: 0 }];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            // è¿™ä¸ªæ•°ç»„ç”¨æ¥å­˜ { cell, dist }ï¼Œç”¨äºç¨åç”ŸæˆåŠ¨ç”»
            const animationQueue = [];

            const dirs = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
            ];

            // 2. === é˜¶æ®µä¸€ï¼šåŒæ­¥é€»è¾‘å¤„ç†ï¼ˆç¬é—´å®Œæˆï¼‰ ===
            // åœ¨è¿™ä¸ªå¾ªç¯é‡Œï¼Œæˆ‘ä»¬åªä¿®æ”¹æ•°æ®çŠ¶æ€ (isRevealed)ï¼Œä¸æ“ä½œ DOM
            let head = 0;
            while (head < queue.length) {
                const { x, y, dist } = queue[head++];
                const currentCell = gridData[y][x];

                // å¦‚æœä¸æ˜¯èµ·ç‚¹ï¼ˆèµ·ç‚¹åœ¨ cell.reveal é‡Œå·²ç»å¤„ç†äº†ï¼‰ï¼Œè®°å½•ä¸‹æ¥åšåŠ¨ç”»
                if (dist > 0) {
                    animationQueue.push({ cell: currentCell, dist: dist });
                }

                // å¦‚æœå½“å‰æ ¼å­æ˜¯ç©ºåœ° (0)ï¼Œåˆ™ç»§ç»­æ‰©æ•£
                // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸éœ€è¦åˆ¤æ–­ neighborCount === 0ï¼Œ
                // å› ä¸ºåªæœ‰ 0 æ‰èƒ½è¿›é˜Ÿåˆ—ç»§ç»­æœå¯»é‚»å±…ï¼ˆè¾¹ç•Œæ•°å­—ä¸æ‰©æ•£ï¼‰
                if (currentCell.neighborCount === 0) {
                    for (let dir of dirs) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        const key = `${nx},${ny}`;

                        // è¶Šç•Œæ£€æŸ¥
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (!visited.has(key)) {
                                const neighbor = gridData[ny][nx];

                                // å…³é”®ï¼šåªè¦æ²¡æ­å¼€ï¼Œå°±ç«‹å³åœ¨é€»è¾‘ä¸Šæ­å¼€
                                if (!neighbor.isRevealed && neighbor.neighborCount === 0) {
                                    // --- çŠ¶æ€é”å®š ---
                                    neighbor.isRevealed = true; // é”æ­»çŠ¶æ€ï¼Œé˜²æ­¢å†æ¬¡ç‚¹å‡»
                                    neighbor.isMarked = false;  // é€»è¾‘ä¸Šå»é™¤æ ‡è®°

                                    visited.add(key);

                                    // åªæœ‰ 0 ç»§ç»­å…¥é˜Ÿæ‰©æ•£ï¼Œæ•°å­—åªæ­å¼€ä¸æ‰©æ•£
                                    if (neighbor.neighborCount === 0) {
                                        queue.push({ x: nx, y: ny, dist: dist + 1 });
                                    } else {
                                        // è¿™æ˜¯ä¸€ä¸ªè¾¹ç•Œæ•°å­—ï¼Œè®°å½•åŠ¨ç”»ï¼Œä½†ä¸å†å…¥é˜Ÿ
                                        animationQueue.push({ cell: neighbor, dist: dist + 1 });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 3. === é˜¶æ®µäºŒï¼šå¼‚æ­¥è§†è§‰åŠ¨ç”» ===
            // æ­¤æ—¶æ‰€æœ‰ç›¸å…³æ ¼å­çš„ isRevealed å·²ç»æ˜¯ true äº†ï¼Œç©å®¶ç‚¹ä¸åŠ¨äº†
            // æˆ‘ä»¬åªéœ€è¦å®‰å®‰é™é™åœ°æŠŠæ ·å¼åˆ·ä¸Šå»

            if (animationQueue.length === 0) return;

            if (isGameOver) {
                animationQueue.forEach(item => {
                    item.cell.updateVisuals();
                });
                // å¤±è´¥æ—¶ä¸éœ€è¦æ’­æ”¾æ‰©æ•£éŸ³æ•ˆï¼Œä¹Ÿä¸éœ€è¦æ›´æ–°HUDï¼ˆåæ­£éƒ½è¦è¾“äº†ï¼‰
                return;
            }

            // å…ˆæ‰¾åˆ°æœ€å¤§å±‚çº§ (æœ€è¿œçš„é‚£ä¸ªæ ¼å­ç¦»èµ·ç‚¹çš„è·ç¦»)
            let maxDist = 0;
            animationQueue.forEach(item => { if (item.dist > maxDist) maxDist = item.dist; });

            // === æ ¸å¿ƒä¿®æ”¹ï¼šåŠ¨æ€æ—¶é—´æ­¥é•¿ ===
            let stepDelay = 30;           // é»˜è®¤çš„åŸºç¡€é€Ÿåº¦ (ms/æ­¥)
            const maxTotalDuration = 500; // æœ€å¤§æ€»è€—æ—¶é™åˆ¶ (ms)

            // è®¡ç®—ï¼šå¦‚æœæŒ‰é»˜è®¤é€Ÿåº¦è·‘å®Œä¼šè¶…è¿‡ 500ms
            if (maxDist * stepDelay > maxTotalDuration) {
                // å¼ºåˆ¶å‹ç¼©ï¼šç”¨æ€»æ—¶é—´é™¤ä»¥æ€»æ­¥æ•°
                stepDelay = maxTotalDuration / maxDist;
            }

            for (let d = 1; d <= maxDist; d++) {
                setTimeout(() => {
                    if (isGameOver) return;

                    animationQueue.forEach(item => {
                        if (item.dist === d) {
                            // è°ƒç”¨æˆ‘ä»¬åˆšæ‰å†™çš„çº¯è§†è§‰æ›´æ–°å‡½æ•°
                            item.cell.updateVisuals();
                        }
                    });
                }, d * stepDelay);
            }

            updateHUD();
        }

        function revealRayPath(startX, startY, dirX, dirY) {
            for (let i = 1; i <= CONFIG.rayLength; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);
                if (tx < 0 || tx >= CONFIG.gridW || ty < 0 || ty >= CONFIG.gridH) break;

                const targetCell = gridData[ty][tx];
                if (!targetCell.isMine && !targetCell.isRevealed) {
                    targetCell.reveal();
                }
            }
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.isMine = false;
                this.isRevealed = false;
                this.isMarked = false;
                this.neighborCount = 0;
                this.element = document.createElement('div');
                this.element.className = 'cell';
                this.element.dataset.x = x;
                this.element.dataset.y = y;
            }

            toggleMark() {
                if (this.isRevealed) return;
                this.isMarked = !this.isMarked;
                this.element.classList.toggle('marked', this.isMarked);
                playSound('mark');
            }

            reveal() {
                if (this.isRevealed) return;

                this.isRevealed = true;
                this.isMarked = false;

                this.updateVisuals();

                if (this.isMine) {
                    this.element.classList.add('mine');
                    this.element.textContent = 'â˜¢';
                    this.element.dataset.num = 'mine';

                    this.element.classList.add('mine-flash');
                    setTimeout(() => this.element.classList.remove('mine-flash'), 150);

                    revealedMines++;
                    playSound('explode');
                    spawnExplosion(this.x, this.y, CONFIG.colors.red);

                    const container = document.getElementById('game-container');
                    container.classList.remove('shake');
                    void container.offsetWidth;
                    container.classList.add('shake');

                } else {
                    if (this.neighborCount === 0) {
                        animatedFloodFill(this.x, this.y);
                    } else {
                        spawnExplosion(this.x, this.y, 'rgba(0, 243, 255, 0.4)');
                    }
                }
                updateHUD();
            }

            updateVisuals() {
                // ç§»é™¤æ ‡è®°æ ·å¼
                this.element.classList.remove('marked');
                // æ·»åŠ æ­ç¤ºæ ·å¼
                this.element.classList.add('revealed');

                if (!this.isMine) {
                    // æ˜¾ç¤ºæ•°å­—
                    this.element.textContent = this.neighborCount === 0 ? '' : this.neighborCount;
                    this.element.dataset.num = this.neighborCount;
                }
            }
        }

        function startTimer() {
            if (timerInterval) return;
            gameStartTime = Date.now();
            const display = document.getElementById('timer-display');

            timerInterval = setInterval(() => {
                const now = Date.now();
                elapsedTime = Math.floor((now - gameStartTime) / 1000);
                display.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function resizeCanvasToDisplaySize(canvas, cssWidth, cssHeight) {
            const dpr = window.devicePixelRatio || 1;

            // 1) è®¾å®š CSS å°ºå¯¸ï¼ˆé¡µé¢ä¸Šçœ‹åˆ°çš„å°ºå¯¸ï¼‰
            canvas.style.width = cssWidth + 'px';
            canvas.style.height = cssHeight + 'px';

            // 2) è®¾å®šå®é™…åƒç´ å°ºå¯¸ï¼ˆä¹˜ DPRï¼Œä¿è¯æ¸…æ™°ï¼‰
            const displayWidth = Math.round(cssWidth * dpr);
            const displayHeight = Math.round(cssHeight * dpr);

            // é¿å…é‡å¤ set é€ æˆæŠ–åŠ¨/é‡ç½®çŠ¶æ€
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            return dpr;
        }

        function initGame() {
            // æ¸…ç†å¯èƒ½çš„æ—§å»¶æ—¶æ“ä½œ
            if (window.failTimeout) clearTimeout(window.failTimeout);
            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);
            window.failIntervals = window.failIntervals || [];
            window.failIntervals.forEach(id => clearTimeout(id));
            window.failIntervals = [];

            resetZoom();

            stopTimer();
            elapsedTime = 0;
            document.getElementById('timer-display').textContent = "00:00";

            gridEl.innerHTML = '';
            gridData = [];
            revealedMines = 0;
            isFirstMove = true;
            isGameOver = false;
            activeEffects = [];
            hudStatus.textContent = "å¾…å‘½";
            hudStatus.style.color = "var(--neon-green)";

            // === PATCH: initGame() å†…éƒ¨æ›¿æ¢â€œæ™ºèƒ½è®¡ç®—å¸ƒå±€â€é‚£ä¸€æ®µ ===
            const isLandscape = window.innerWidth > window.innerHeight;
            const margin = 12;

            // çœŸå®æµ‹é‡ HUD/Guide/Toolbar çš„å ç”¨ç©ºé—´ï¼ˆé¿å…å­—ä½“/è®¾å¤‡å·®å¼‚ï¼‰
            const hudRect = document.getElementById('hud').getBoundingClientRect();
            const guideRect = document.getElementById('guide-text').getBoundingClientRect();

            // é¡¶éƒ¨ HUD é«˜åº¦
            const hudHeight = Math.ceil(hudRect.height);

            // åº•éƒ¨ guide é«˜åº¦
            const guideHeight = Math.ceil(guideRect.height);

            // å·¥å…·æ å ç”¨ï¼šæ¨ªå±å å®½ï¼Œç«–å±å é«˜
            const toolbarW = 0;
            const toolbarH = 0;

            // å¯ç”¨ç©ºé—´ï¼ˆæ³¨æ„ï¼šHUDã€Guideã€Toolbar éƒ½æ˜¯ fixed å åœ¨è§†å£ä¸Šï¼Œæ‰€ä»¥è¦æ‰£æ‰å®ƒä»¬ï¼‰
            const availableWidth = window.innerWidth - toolbarW - margin * 2;
            const availableHeight = window.innerHeight - hudHeight - guideHeight - toolbarH - margin * 2;

            // è®¡ç®— cellSizeï¼šä¸è¦ç¡¬å¡åˆ° 20ï¼Œå¦åˆ™å°å±ä¼šæº¢å‡º
            const sizeW = Math.floor(availableWidth / CONFIG.gridW);
            const sizeH = Math.floor(availableHeight / CONFIG.gridH);

            // ä¸Šé™ 50 ä¿æŒè§‚æ„Ÿï¼Œä¸‹é™ç»™åˆ° 6~8ï¼Œå®æ„¿å˜å°ä¹Ÿåˆ«æº¢å‡º
            let size = Math.min(sizeW, sizeH, 50);
            size = Math.max(size, 6);

            CONFIG.cellSize = size;
            gridEl.style.setProperty('--cs', size + 'px');

            const totalWidth = size * CONFIG.gridW;
            const totalHeight = size * CONFIG.gridH;

            gridEl.style.gridTemplateColumns = `repeat(${CONFIG.gridW}, ${size}px)`;
            gridEl.style.gridTemplateRows = `repeat(${CONFIG.gridH}, ${size}px)`;

            const dpr = resizeCanvasToDisplaySize(rayCanvas, window.innerWidth, window.innerHeight);

            // å…³é”®ï¼šæŠŠåæ ‡ç³»ç¼©å›â€œCSS åƒç´ â€ï¼Œè¿™æ ·ä½ åé¢ç”¨çš„ cellSize/åƒç´ è®¡ç®—éƒ½ä¸ç”¨æ”¹
            rayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

            for (let y = 0; y < CONFIG.gridH; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.gridW; x++) {
                    const cell = new Cell(x, y);
                    gridEl.appendChild(cell.element);
                    row.push(cell);
                }
                gridData.push(row);
            }

            totalMines = Math.floor(CONFIG.gridW * CONFIG.gridH * CONFIG.density);
            updateHUD();
            startRenderLoop();
        }

        function generateMines(startX, startY, dirX, dirY) {
            // å…ˆç¡®ä¿èµ·ç‚¹æ˜¯é›·
            gridData[startY][startX].isMine = true;
            let placed = 1;

            // æ­¤æ—¶æˆ‘ä»¬ä¸å¹²é¢„åˆ†å¸ƒï¼Œçº¯ç²¹éšæœº
            while (placed < totalMines) {
                const rx = Math.floor(Math.random() * CONFIG.gridW);
                const ry = Math.floor(Math.random() * CONFIG.gridH);

                if (!gridData[ry][rx].isMine) {
                    gridData[ry][rx].isMine = true;
                    placed++;
                }
            }

            // æ”¶é›†è¯¥æ–¹å‘ä¸Šè·ç¦» 2 åˆ° 5 çš„åˆæ³•æ ¼å­
            const candidates = [];
            let hasMineInPath = false;

            // è·ç¦»0æ˜¯èµ·ç‚¹ï¼Œè·ç¦»1æ˜¯ä¹å®«æ ¼è¾¹ç¼˜ï¼ˆä¼šè¢«ç›´æ¥ç‚¸å¼€ï¼‰ï¼Œ
            // å°„çº¿ç©¿é€4ä¸ªæœªæ­ç¤ºæ ¼ï¼Œæ‰€ä»¥è¦†ç›–çš„æ˜¯è·ç¦» 2, 3, 4, 5
            for (let i = 2; i <= 5; i++) {
                const tx = startX + (dirX * i);
                const ty = startY + (dirY * i);

                // è¶Šç•Œæ£€æŸ¥
                if (tx >= 0 && tx < CONFIG.gridW && ty >= 0 && ty < CONFIG.gridH) {
                    const cell = gridData[ty][tx];
                    candidates.push(cell);
                    if (cell.isMine) {
                        hasMineInPath = true; // è¿æ°”ä¸é”™ï¼Œè‡ªç„¶ç”Ÿæˆäº†
                    }
                }
            }

            if (!hasMineInPath && candidates.length > 0) {

                // A. ä»è·¯å¾„å€™é€‰æ ¼ä¸­é€‰ä¸€ä¸ªå¹¸è¿å„¿å˜æˆé›·
                const luckyCell = candidates[Math.floor(Math.random() * candidates.length)];
                luckyCell.isMine = true;

                // B. ä¸ºäº†ä¿æŒæ€»é›·æ•°ä¸å˜ï¼Œå¿…é¡»æ“¦é™¤æ‰åœ°å›¾ä¸Šå¦ä¸€ä¸ªç°æœ‰çš„é›·
                //    è¿™ä¸ªé›·ä¸èƒ½æ˜¯èµ·ç‚¹ï¼Œä¹Ÿä¸èƒ½æ˜¯æˆ‘ä»¬åˆšæ‰é€‰ä¸­çš„å¹¸è¿å„¿
                let removed = false;
                while (!removed) {
                    const rx = Math.floor(Math.random() * CONFIG.gridW);
                    const ry = Math.floor(Math.random() * CONFIG.gridH);
                    const target = gridData[ry][rx];

                    // å¿…é¡»æ˜¯é›·ï¼Œä¸”ä¸æ˜¯èµ·ç‚¹ï¼Œä¸”ä¸æ˜¯åˆšæ‰æ–°è®¾çš„é‚£ä¸ªä½ç½®
                    if (target.isMine &&
                        !(rx === startX && ry === startY) &&
                        !(rx === luckyCell.x && ry === luckyCell.y)) {

                        target.isMine = false; // ç§»é™¤è¿™é¢—é›·
                        removed = true;
                    }
                }
            }

            // ç»Ÿä¸€è®¡ç®—æ•°å­—
            calculateNumbers();
        }

        function calculateNumbers() {
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
            ];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    let count = 0;
                    for (let dir of directions) {
                        const nx = x + dir.x;
                        const ny = y + dir.y;
                        if (nx >= 0 && nx < CONFIG.gridW && ny >= 0 && ny < CONFIG.gridH) {
                            if (gridData[ny][nx].isMine) count++;
                        }
                    }
                    gridData[y][x].neighborCount = count;
                }
            }
        }

        function calculateRayPath(startX, startY, dirX, dirY) {
            let currentX = startX;
            let currentY = startY;
            let distance = 0;
            let unrevealedHitCount = 0;
            const path = [];

            while (true) {
                currentX += dirX;
                currentY += dirY;
                distance++;

                // 1. è¾¹ç•Œæ£€æŸ¥
                if (currentX < 0 || currentX >= CONFIG.gridW ||
                    currentY < 0 || currentY >= CONFIG.gridH) {
                    break;
                }

                const cell = gridData[currentY][currentX];
                path.push(cell);

                // å‘½ä¸­æœªæ­ç¤ºçš„åœ°é›·ï¼Œç«‹å³åœæ­¢ ===
                // å°„çº¿èƒ½é‡è¢«è¿™é¢—é›·å¸æ”¶å¹¶å¼•çˆ†ï¼Œå®ƒä¸èƒ½å†å¾€å‰èµ°äº†ã€‚
                // åç»­çš„è·¯å¾„å°†ç”±è¿™é¢—é›·çˆ†ç‚¸äº§ç”Ÿçš„â€œæ–°å°„çº¿â€æ¥åŠ›å®Œæˆã€‚
                if (cell.isMine && !cell.isRevealed) {
                    break;
                }

                // 3. ç©¿é€æ£€æµ‹ (é’ˆå¯¹æ™®é€šæœªçŸ¥æ ¼å­)
                if (!cell.isRevealed) {
                    unrevealedHitCount++;
                }

                // 4. è€—å°½åœæ­¢
                if (unrevealedHitCount >= CONFIG.penetrationLimit) {
                    break;
                }
            }

            return { distance, path };
        }

        function fireRay(startX, startY, dirX, dirY, delay = 0) {
            setTimeout(() => {
                if (isGameOver) return;

                // 1. å…ˆè®¡ç®—è·¯å¾„ï¼ˆé€»è¾‘æ ¸å¿ƒï¼‰
                const { distance, path } = calculateRayPath(startX, startY, dirX, dirY);

                playSound('ray');

                // 2. è§†è§‰ç”Ÿæˆï¼šä¼ å…¥è®¡ç®—å‡ºçš„å®é™…è·ç¦» (distance)
                // è¿™æ ·å°„çº¿å°±èƒ½åœ¨å¢™è¾¹æˆ–è€…ç¬¬4ä¸ªæ ¼å­å¤„ç²¾å‡†åœä¸‹
                spawnRay(startX, startY, dirX, dirY, distance);

                // 3. æ¸¸æˆé€»è¾‘ï¼šéå†è·¯å¾„ä¸Šçš„æ ¼å­
                for (const targetCell of path) {

                    if (targetCell.isMine) {
                        if (!targetCell.isRevealed) {
                            targetCell.reveal(); // æ­ç¤ºé›·
                            explodeNeighbors(targetCell.x, targetCell.y); // ç‚¸å¼€å‘¨å›´
                            fireRay(targetCell.x, targetCell.y, dirX, dirY, 120);

                            comboCounter++;
                            const showCount = Math.min(comboCounter, 10);

                            if (showCount >= 2) {
                                activeEffects.push(new FloatingText(targetCell.x, targetCell.y, showCount));
                            }

                            hitMine = true;
                        }
                    } else {
                        targetCell.reveal();
                    }
                }
                checkWinCondition();
            }, delay);
        }


        let isPaused = false;
        let pausedTimerWasRunning = false;

        function openTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.remove('hidden');

            // æš‚åœè¾“å…¥
            isPaused = true;

            // æš‚åœè®¡æ—¶ï¼ˆå¦‚æœæ­£åœ¨è®¡æ—¶ï¼‰
            pausedTimerWasRunning = !!timerInterval;
            stopTimer();

            playSound('hover');
        }

        function closeTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.add('hidden');

            // æ¢å¤è¾“å…¥
            isPaused = false;

            // æ¢å¤è®¡æ—¶ï¼ˆä»…å½“æ¸¸æˆæœªç»“æŸã€ä¸”ä¹‹å‰åœ¨è®¡æ—¶ï¼‰
            if (!isGameOver && !isFirstMove && pausedTimerWasRunning) {
                startTimer(); // startTimer ä¸‹é¢ä¼šåšâ€œæŒ‰ elapsedTime ç»­è®¡â€
            }

            pausedTimerWasRunning = false;
            playSound('hover');
        }

        function startTimer() {
            if (timerInterval) return;

            // âœ… å…³é”®ï¼šæ”¯æŒæš‚åœæ¢å¤
            gameStartTime = Date.now() - (elapsedTime * 1000);

            const display = document.getElementById('timer-display');
            timerInterval = setInterval(() => {
                const now = Date.now();
                elapsedTime = Math.floor((now - gameStartTime) / 1000);
                display.textContent = formatTime(elapsedTime);
            }, 1000);
        }

        document.getElementById('btn-tutorial').addEventListener('click', () => {
            openTutorial();
        });

        document.getElementById('btn-ingame-tutorial').addEventListener('click', () => {
            openTutorial();
        });

        document.getElementById('btn-tutorial-back').addEventListener('click', () => {
            closeTutorial();
        });

        document.getElementById('tutorial-overlay').addEventListener('click', (e) => {
            if (e.target.id === 'tutorial-overlay') closeTutorial();
        });

        let isZoomed = false;
        function resetZoom() {
            const wrapper = document.getElementById('grid-wrapper');
            wrapper.style.transform = '';
            isZoomed = false;
        }

        function setupInput() {
            // ç¦æ­¢ç½‘æ ¼åŒºåŸŸé»˜è®¤å³é”®èœå•
            gridEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });

            const getCellCoords = (e) => {
                const rect = gridEl.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const cs = rect.width / CONFIG.gridW;
                const x = Math.floor((clientX - rect.left) / cs);
                const y = Math.floor((clientY - rect.top) / cs);
                return { x, y, clientX, clientY };
            };

            // è°ƒå¤§é˜ˆå€¼ï¼ˆè‡³å°‘ 38pxï¼›å¹¶éšæ ¼å­å¤§å°ç•¥ç¼©æ”¾ï¼‰
            const getDragThreshold = () => Math.max(38, Math.round(CONFIG.cellSize * 0.45));
            let dragButton = 0;
            const startDrag = (e) => {
                if (isGameOver || isPaused) return;

                // touch éœ€è¦ preventDefault é˜²æ­¢é¡µé¢æ»šåŠ¨
                if (e.type === 'touchstart') e.preventDefault();

                const coords = getCellCoords(e);
                if (coords.x < 0 || coords.x >= CONFIG.gridW || coords.y < 0 || coords.y >= CONFIG.gridH) return;

                const cell = gridData[coords.y][coords.x];
                if (cell.isRevealed) return; // å·²æ­ç¤ºä¸å¤„ç†

                dragButton = (e.type === 'mousedown') ? e.button : 0;

                // è®°å½•èµ·ç‚¹ï¼Œç­‰å¾… end æ—¶åˆ¤æ–­æ˜¯â€œç‚¹â€è¿˜æ˜¯â€œæ‹–â€
                startCell = { x: coords.x, y: coords.y };
                isDragging = true;
                dragLine = { x: coords.clientX, y: coords.clientY };

                cell.element.classList.add('active');
                playSound('hover');
            };

            const moveDrag = (e) => {
                if (!isDragging) return;
                // è§¦æ‘¸æ‹–åŠ¨æ—¶é˜²æ»šåŠ¨
                if (e.type === 'touchmove') e.preventDefault();
            };

            const endDrag = (e) => {
                if (!isDragging || !startCell) return;

                const end = e.changedTouches
                    ? { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY }
                    : { clientX: e.clientX, clientY: e.clientY };

                const dx = end.clientX - dragLine.x;
                const dy = end.clientY - dragLine.y;
                const dist = Math.hypot(dx, dy);

                const cell = gridData[startCell.y][startCell.x];
                cell.element.classList.remove('active');

                const threshold = getDragThreshold();

                if (dragButton === 2) {
                    if (dist < threshold) cell.toggleMark();
                    // else: ä»€ä¹ˆéƒ½ä¸åš
                    isDragging = false;
                    startCell = null;
                    return;
                }

                if (dist < threshold) {
                    // è§†ä¸ºç‚¹å‡»ï¼šåˆ‡æ¢æ ‡è®°
                    cell.toggleMark();
                } else {
                    if (cell.isMarked) {
                        // æ ‡è®°æ ¼å­è¢«è®¤ä¸ºâ€œå®‰å…¨â€ï¼Œé¿å…è¯¯æ“ä½œ
                        isDragging = false;
                        startCell = null;
                        return;
                    }

                    const angle = Math.atan2(dy, dx);
                    const degree = angle * (180 / Math.PI);
                    const octant = Math.round(degree / 45);

                    const dirs = [
                        { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 },
                        { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }
                    ];

                    let dirIndex = octant;
                    if (dirIndex < 0) dirIndex += 8;
                    dirIndex = dirIndex % 8;

                    const dir = dirs[dirIndex];
                    handleAction(startCell.x, startCell.y, dir.x, dir.y);
                }

                isDragging = false;
                startCell = null;
            };

            gridEl.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', moveDrag);
            window.addEventListener('mouseup', endDrag);

            // ===== åŒæŒ‡è½»ç‚¹ç¼©æ”¾ï¼ˆä¸å•æŒ‡æ‹–åŠ¨/ç‚¹æŒ‰åˆå¹¶ï¼‰=====
            let gridTouchSession = false;
            let currentZoomScale = 1;

            let pinchTap = null;          // åŒæŒ‡è½»ç‚¹å€™é€‰
            let singleStartTimer = null;  // â€œç­‰ç¬¬äºŒæŒ‡â€çš„å»¶è¿Ÿè®¡æ—¶å™¨
            let pendingSingleEvent = null;

            function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

            function getDynamicZoomScale() {
                const wrapper = document.getElementById('grid-wrapper');
                const rect = wrapper.getBoundingClientRect();

                const vw = window.innerWidth;
                const vh = window.innerHeight;

                // ç½‘æ ¼å®Œå…¨å¡è¿›å±å¹•æ‰€éœ€çš„æœ€å¤§å€æ•°ï¼ˆé€šå¸¸â‰ˆ1ï¼‰
                const fitScale = Math.min(vw / rect.width, vh / rect.height) * 0.98;

                // ç›®æ ‡ï¼šæ”¾å¤§åæ ¼å­æ¥è¿‘ä¸€ä¸ªå¥½ç‚¹æŒ‰çš„åƒç´ å¤§å°
                const targetCellPx = 48; // ä½ å¯ä»¥è°ƒï¼š44~56
                const cellBasedScale = targetCellPx / CONFIG.cellSize;

                // âœ… å…³é”®ï¼šå…è®¸â€œè¶…å‡ºå±å¹•â€çš„ç¨‹åº¦ï¼ˆå¯†ç½‘æ ¼ç»™æ›´å¤§æº¢å‡ºç©ºé—´ï¼‰
                // cellBasedScale è¶Šå¤§ï¼ˆè¯´æ˜æ ¼å­è¶Šå°è¶Šå¯†ï¼‰ï¼Œå…è®¸çš„æº¢å‡ºè¶Šå¤š
                const overflowFactor = clamp(1.3 + (cellBasedScale - 1) * 0.55, 1.3, 2.6);

                // ä¸å†ç”¨ fitScale ç¡¬å¡æ­»ï¼Œè€Œæ˜¯å…è®¸ fitScale * overflowFactor
                const maxAllowed = fitScale * overflowFactor;

                const desired = Math.min(cellBasedScale, maxAllowed);

                // æœ€ç»ˆå…œåº•
                return clamp(desired, 1.5, 4);
            }

            function cancelSingleStart() {
                if (singleStartTimer) {
                    clearTimeout(singleStartTimer);
                    singleStartTimer = null;
                }
                pendingSingleEvent = null;
            }

            // å¦‚æœå•æŒ‡æ‹–åŠ¨å·²ç»å¼€å§‹ï¼Œä½†ç¬¬äºŒæŒ‡è½ä¸‹ï¼šå–æ¶ˆæ‹–åŠ¨è§†è§‰&çŠ¶æ€
            function cancelDraggingNow() {
                if (isDragging && startCell) {
                    const c = gridData[startCell.y]?.[startCell.x];
                    if (c) c.element.classList.remove('active');
                }
                isDragging = false;
                startCell = null;
            }

            function applyZoomAt(clientX, clientY, scale) {
                const wrapper = document.getElementById('grid-wrapper');
                const rect = wrapper.getBoundingClientRect();

                const px = clientX - rect.left;
                const py = clientY - rect.top;

                const tx = clientX - rect.left - px * scale;
                const ty = clientY - rect.top - py * scale;

                wrapper.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
            }

            // ===== é¼ æ ‡æ»šè½®ï¼šæŒ‰é¼ æ ‡æ‰€åœ¨ä½ç½®ç¼©æ”¾ç½‘æ ¼ï¼ˆæœ€å°æ”¹åŠ¨ï¼‰=====
            function getWrapperMatrix(wrapper) {
                const t = getComputedStyle(wrapper).transform;
                if (!t || t === 'none') return { s: 1, tx: 0, ty: 0 };

                // DOMMatrix å¤§éƒ¨åˆ†ç°ä»£æµè§ˆå™¨æ”¯æŒï¼›Safari ä¹ŸOKï¼ˆæ—§ç‰ˆå¯ç”¨ WebKitCSSMatrixï¼‰
                const M = (window.DOMMatrix || window.WebKitCSSMatrix) ? new (window.DOMMatrix || window.WebKitCSSMatrix)(t) : null;
                if (!M) return { s: 1, tx: 0, ty: 0 };

                // ä½ çš„ transform æ˜¯ `translate(...) scale(...)`ï¼ˆCSS ä»å³åˆ°å·¦åº”ç”¨ => å…ˆ scale å translateï¼‰
                // æ‰€ä»¥çŸ©é˜µé‡Œ a=d=scale, e/f=translate
                return { s: M.a || 1, tx: M.e || 0, ty: M.f || 0 };
            }

            // åœ¨â€œå½“å‰ transform åŸºç¡€ä¸Šâ€ï¼Œä»¥ clientX/Y ä¸ºé”šç‚¹ç¼©æ”¾åˆ° newScale
            function applyZoomAtKeepingPoint(clientX, clientY, newScale) {
                const wrapper = document.getElementById('grid-wrapper');

                const rect = wrapper.getBoundingClientRect();
                const { s: curS, tx: curTx, ty: curTy } = getWrapperMatrix(wrapper);

                // base = æœª transform æ—¶ wrapper çš„å¸ƒå±€ä½ç½®ï¼ˆè§†å£åæ ‡ï¼‰
                const baseLeft = rect.left - curTx;
                const baseTop = rect.top - curTy;

                // é¼ æ ‡ç‚¹åœ¨â€œå†…å®¹åæ ‡ç³»(æœªç¼©æ”¾)â€ä¸‹çš„ä½ç½®
                const localX = (clientX - rect.left) / curS;
                const localY = (clientY - rect.top) / curS;

                // æ±‚æ–°çš„ translateï¼Œè®©è¯¥ local ç‚¹åœ¨ newScale ä¸‹ä»å¯¹é½åˆ° clientX/Y
                const newLeft = clientX - localX * newScale;
                const newTop = clientY - localY * newScale;

                const newTx = newLeft - baseLeft;
                const newTy = newTop - baseTop;

                wrapper.style.transform = `translate(${newTx}px, ${newTy}px) scale(${newScale})`;
            }

            // ç›‘å¬æ»šè½®
            gridEl.addEventListener('wheel', (e) => {
                if (isGameOver || isPaused) return;

                e.preventDefault();

                const wrapper = document.getElementById('grid-wrapper');
                const { s: curS } = getWrapperMatrix(wrapper);

                const factor = Math.exp(-e.deltaY * 0.003);

                const maxS = getDynamicZoomScale() * 2;
                let nextS = curS * factor;

                nextS = clamp(nextS, 0.5, maxS);

                // scale å›åˆ° 1 å°±ç›´æ¥ resetï¼ˆé¿å…æ®‹ç•™ translate å¯¼è‡´è½»å¾®åç§»ï¼‰
                if (0.9 <= nextS && nextS <= 1.1) {
                    resetZoom();
                    currentZoomScale = 1;
                    return;
                }

                isZoomed = true;
                currentZoomScale = nextS;

                applyZoomAtKeepingPoint(e.clientX, e.clientY, nextS);
            }, { passive: false });


            // touchstartï¼šæ ¹æ® touches æ•°é‡å†³å®šèµ°å“ªæ¡è·¯
            gridEl.addEventListener('touchstart', (e) => {
                if (isGameOver || isPaused) return;

                // å¿…é¡»é˜»æ­¢é»˜è®¤ï¼Œå¦åˆ™ä¼šè§¦å‘é¡µé¢æ»šåŠ¨/åŒæŒ‡ç¼©æ”¾ç­‰
                e.preventDefault();
                gridTouchSession = true;

                // 1) åŒæŒ‡å‡ºç°ï¼šè¿›å…¥â€œåŒæŒ‡è½»ç‚¹å€™é€‰â€ï¼Œå¹¶å–æ¶ˆä»»ä½•å•æŒ‡é€»è¾‘
                if (e.touches.length === 2) {
                    cancelSingleStart();
                    cancelDraggingNow();

                    const t0 = e.touches[0], t1 = e.touches[1];
                    pinchTap = {
                        time: performance.now(),
                        x0: t0.clientX, y0: t0.clientY,
                        x1: t1.clientX, y1: t1.clientY
                    };
                    return;
                }

                // 2) å•æŒ‡ï¼šä¸è¦ç«‹åˆ» startDrag â€”â€” ç»™ä¸€ä¸ªå¾ˆçŸ­çª—å£ç­‰ç¬¬äºŒæŒ‡
                //    è¿™æ ·é¿å…â€œåŒæŒ‡ä¸åŒæ—¶è½ä¸‹â€å¯¼è‡´è¯¯è§¦å‘å•æŒ‡ç‚¹/æ‹–
                if (e.touches.length === 1) {
                    pinchTap = null; // æ¸…æ‰ä»»ä½•æ—§çŠ¶æ€
                    cancelSingleStart();

                    pendingSingleEvent = e;

                    singleStartTimer = setTimeout(() => {
                        // è¶…æ—¶ä»ç„¶æ˜¯å•æŒ‡ï¼šæŒ‰åŸé€»è¾‘å¼€å§‹
                        if (!pendingSingleEvent) return;
                        startDrag(pendingSingleEvent);
                        pendingSingleEvent = null;
                        singleStartTimer = null;
                    }, 90); // 80~120ms éƒ½è¡Œï¼šè¶Šå°è¶Šçµæ•ï¼Œè¶Šå¤§è¶Šä¸æ˜“è¯¯åˆ¤
                }
            }, { passive: false });

            window.addEventListener('touchmove', (e) => {
                if (!gridTouchSession) return;
                if (isGameOver || isPaused) return;
                e.preventDefault();

                // å¦‚æœç¬¬äºŒæŒ‡åœ¨â€œç­‰å¾…çª—å£â€å†…å‡ºç°äº†ï¼Œtouchmove ä¹Ÿåº”é˜»æ­¢å•æŒ‡é€»è¾‘
                if (e.touches.length === 2) {
                    // åªè¦åŒæŒ‡ç§»åŠ¨ï¼Œå°±ä¸æ˜¯â€œè½»ç‚¹â€äº†
                    if (pinchTap) {
                        const t0 = e.touches[0], t1 = e.touches[1];
                        const move =
                            Math.hypot(t0.clientX - pinchTap.x0, t0.clientY - pinchTap.y0) +
                            Math.hypot(t1.clientX - pinchTap.x1, t1.clientY - pinchTap.y1);
                        if (move > 18) {
                            pinchTap = null;
                        }
                    }
                    return;
                }

                // å•æŒ‡ moveï¼šå¦‚æœè¿˜åœ¨ç­‰ç¬¬äºŒæŒ‡ï¼Œä¸åšä»»ä½•äº‹ï¼ˆé¿å…è¯¯è§¦æ‹–åŠ¨ï¼‰
                if (singleStartTimer) return;

                // æ­£å¸¸å•æŒ‡æ‹–åŠ¨
                moveDrag(e);
            }, { passive: false });

            window.addEventListener('touchend', (e) => {
                if (!gridTouchSession) return;
                const shouldEndSession = (e.touches.length === 0);

                if (isGameOver || isPaused) {
                    if (shouldEndSession) {
                        gridTouchSession = false;
                        pinchTap = null;
                        cancelSingleStart();
                        cancelDraggingNow();
                    }
                    return;
                }
                e.preventDefault();

                // åŒæŒ‡è½»ç‚¹åˆ¤å®šï¼šä¸¤æŒ‡éƒ½æŠ¬èµ·ï¼ˆæœ€ç»ˆ touches=0ï¼‰æ‰è§¦å‘ä¸€æ¬¡
                if (pinchTap && e.touches.length === 0) {
                    const dt = performance.now() - pinchTap.time;
                    if (dt <= 260) {
                        const cx = (pinchTap.x0 + pinchTap.x1) / 2;
                        const cy = (pinchTap.y0 + pinchTap.y1) / 2;

                        if (!isZoomed) {
                            isZoomed = true;
                            currentZoomScale = getDynamicZoomScale();
                            applyZoomAt(cx, cy, currentZoomScale);
                        } else {
                            resetZoom();
                        }
                    }
                    pinchTap = null;
                    cancelSingleStart();
                    gridTouchSession = false;
                    return;
                }

                // è§¦å‘å•æŒ‡ endï¼šå¦‚æœè¿˜æ²¡åˆ° startDrag çš„å»¶è¿Ÿæ—¶é—´ï¼Œè¯´æ˜æ˜¯å•å‡»/çŸ­æŒ‰
                // è¿™é‡Œç›´æ¥â€œç«‹åˆ»æ‰§è¡Œä¸€æ¬¡ startDrag + endDragâ€ä¼šå¾ˆå±é™©ï¼ˆä¼šè§¦å‘ä½ çš„æ‹–åˆ¤å®šé˜ˆå€¼ï¼‰
                // æœ€å°åšæ³•ï¼šå¦‚æœå»¶è¿Ÿæœªè§¦å‘ï¼Œç›´æ¥å–æ¶ˆè®¡æ—¶å™¨å¹¶æŒ‰â€œç‚¹å‡»â€èµ° endDrag çš„ç°æœ‰é€»è¾‘æ˜¯ä¸æˆç«‹çš„
                // æ‰€ä»¥ï¼šè®©åŸæ¥ endDrag å¤„ç†å³å¯ï¼Œä½†è¦ç¡®ä¿ startDrag çœŸæ­£å‘ç”Ÿè¿‡æ‰è°ƒç”¨
                if (singleStartTimer) {
                    // è¿™æ˜¯â€œå¿«é€Ÿç‚¹ä¸€ä¸‹â€ä½†åœ¨90mså†…ç»“æŸï¼š
                    // ç›´æ¥æŠŠ pendingSingleEvent ç«‹åˆ» startDrag å† endDragï¼Œä¿è¯ä½ ç°æœ‰â€œç‚¹/æ‹–åˆ¤å®šâ€ä¸æ”¹
                    clearTimeout(singleStartTimer);
                    singleStartTimer = null;

                    if (pendingSingleEvent) {
                        startDrag(pendingSingleEvent);
                        pendingSingleEvent = null;
                        endDrag(e);
                    }
                    return;
                }

                // æ­£å¸¸ï¼šå•æŒ‡æ‹–åŠ¨ç»“æŸ
                endDrag(e);

                if (shouldEndSession) gridTouchSession = false;
            }, { passive: false });

            window.addEventListener('touchcancel', (e) => {
                gridTouchSession = false;
                pinchTap = null;
                cancelSingleStart();
                cancelDraggingNow();
            }, { passive: false });
        }

        function handleAction(x, y, dirX, dirY) {
            const cell = gridData[y][x];
            if (cell.isRevealed || cell.isMarked) return;

            comboCounter = 1;

            if (isFirstMove) {
                generateMines(x, y, dirX, dirY);
                isFirstMove = false;
                hudStatus.textContent = "é“¾æ¥å»ºç«‹";
                startTimer();
            }

            if (cell.isMine) {
                cell.reveal();
                // ç°åœ¨é‡‡å–çš„æ˜¯é‚»å±…ä¼˜å…ˆä¸é“¾å¼ååº”çš„è§„åˆ™ï¼Œå¯ä»¥è§£é‡Šä¸ºå‘¨å›´è¢«ç‚¸åäº†
                explodeNeighbors(x, y);
                fireRay(x, y, dirX, dirY);
            } else {
                cell.element.style.backgroundColor = "var(--neon-red)";
                spawnExplosion(x, y, CONFIG.colors.red);
                gameOver(false);
            }
        }

        let endDuration = 0.0;

        function triggerChainFailure() {
            hudStatus.textContent = "ç³»ç»Ÿå´©æºƒ";
            hudStatus.style.color = "var(--neon-red)";
            playSound('error');

            const hiddenMines = [];
            for (let y = 0; y < CONFIG.gridH; y++) {
                for (let x = 0; x < CONFIG.gridW; x++) {
                    if (gridData[y][x].isMine && !gridData[y][x].isRevealed) {
                        hiddenMines.push(gridData[y][x]);
                    }
                }
            }

            hiddenMines.sort(() => Math.random() - 0.5);

            // åŠ¨æ€é—´éš”è®¡ç®—
            let interval = 300;
            if (hiddenMines.length > 10) {
                // å¦‚æœé›·å¤šäº10ä¸ªï¼Œç¡®ä¿åœ¨3000mså†…ç‚¸å®Œ
                interval = 3000 / hiddenMines.length;
            }

            // æ¸…ç†æ—§çš„å®šæ—¶å™¨æ•°ç»„
            window.failIntervals = [];
            endDuration = interval * hiddenMines.length;

            hiddenMines.forEach((cell, index) => {
                const id = setTimeout(() => {
                    cell.element.classList.add('mine');
                    cell.element.textContent = 'â˜¢';
                    cell.element.classList.add('mine-flash');
                    setTimeout(() => cell.element.classList.remove('mine-flash'), 150);

                    playSound('explode');
                    spawnExplosion(cell.x, cell.y, CONFIG.colors.red);

                    const dirs = [
                        { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 },
                        { x: 0, y: 1 }, { x: -1, y: 1 }, { x: -1, y: 0 }, { x: -1, y: -1 }
                    ];
                    dirs.forEach(d => {
                        const { distance, path } = calculateRayPath(cell.x, cell.y, d.x, d.y);
                        spawnRay(cell.x, cell.y, d.x, d.y, distance, true);
                        revealRayPath(cell.x, cell.y, d.x, d.y);
                    });

                }, index * interval);
                window.failIntervals.push(id);
            });

            const finalRevealId = setTimeout(() => {
                for (let y = 0; y < CONFIG.gridH; y++) {
                    for (let x = 0; x < CONFIG.gridW; x++) {
                        const cell = gridData[y][x];
                        if (!cell.isRevealed && !cell.isMine) {
                            cell.isRevealed = true;
                            cell.isMarked = false;
                            // é™é»˜æ›´æ–°è§†è§‰ï¼Œä¸æ’­æ”¾å£°éŸ³ï¼Œä¸å¸¦åŠ¨ç”»ï¼Œä»¿ä½›ç³»ç»Ÿå½»åº•æ­»æœºæ˜¾ç¤ºæ•°æ®
                            cell.updateVisuals();
                        }
                    }
                }
            }, endDuration);

            window.failIntervals.push(finalRevealId);
        }

        function checkWinCondition() {
            if (revealedMines >= totalMines) {
                gameOver(true);
            }
        }

        function gameOver(win, reason) {
            if (isGameOver) return;

            stopTimer();
            resetZoom();

            isGameOver = true;
            if (!win) {
                triggerChainFailure();
                // æ³¨æ„ï¼šå¤±è´¥æ—¶æˆ‘ä»¬ç¨åå¼¹å‡ºç•Œé¢ï¼Œä½†æ•°æ®ç°åœ¨å°±è¦å‡†å¤‡å¥½
            } else {
                // èƒœåˆ©ç›´æ¥å¤„ç†
                hudStatus.textContent = "èƒœåˆ©";
                hudStatus.style.color = "var(--neon-green)";
                playSound('hover');
            }

            // å‡†å¤‡ç•Œé¢æ•°æ®
            const card = document.querySelector('.result-card');
            const title = document.getElementById('end-title');
            const timeDisplay = document.getElementById('end-time');
            const diffDisplay = document.getElementById('end-difficulty');
            const pctDisplay = document.getElementById('end-percentage');
            const reasonText = document.getElementById('end-reason');
            const overlay = document.getElementById('game-over-overlay');

            // è®¾ç½®åŸºæœ¬æ•°æ®
            timeDisplay.textContent = formatTime(elapsedTime);
            diffDisplay.textContent = `${CONFIG.gridW}x${CONFIG.gridH} (${Math.round(CONFIG.density * 100)}%)`;

            // ç§»é™¤æ—§ä¸»é¢˜
            card.classList.remove('win-theme', 'lose-theme');

            // å»¶è¿Ÿæ˜¾ç¤ºé€»è¾‘ (ä¸ºäº†é…åˆçˆ†ç‚¸åŠ¨ç”»)
            const showDelay = win ? 1500 : (endDuration + 1500);

            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            window.gameResultTimeout = setTimeout(() => {
                if (win) {
                    title.textContent = "SYSTEM PURGED";
                    title.className = "win"; // ä¿æŒæ–‡å­—é¢œè‰²é€»è¾‘
                    card.classList.add('win-theme');
                    pctDisplay.textContent = "100%";
                    reasonText.textContent = "æ‰€æœ‰å¨èƒå·²æ¶ˆé™¤ï¼Œç³»ç»Ÿæ¢å¤æ­£å¸¸ã€‚";
                } else {
                    title.textContent = "CONNECTION LOST";
                    title.className = "lose";
                    card.classList.add('lose-theme');
                    // è®¡ç®—å®Œæˆåº¦
                    const pct = Math.floor((revealedMines / totalMines) * 100);
                    pctDisplay.textContent = `${pct}% THREATS NEUTRALIZED`;
                    reasonText.textContent = "é€»è¾‘é“¾è·¯å´©æºƒï¼Œåè®®æ‰§è¡Œå¤±è´¥ã€‚";
                }
                overlay.classList.remove('hidden');
            }, showDelay);
        }

        function updateHUD() {
            hudMines.textContent = `${totalMines - revealedMines}`;
        }

        const menuOverlay = document.getElementById('menu-overlay');
        const inpW = document.getElementById('inp-w');
        const inpH = document.getElementById('inp-h');
        const inpD = document.getElementById('inp-d');
        const diffSelect = document.getElementById('difficulty-select');
        const customSettings = document.getElementById('custom-settings');

        // === 1. å®šä¹‰åè®®å‚æ•° ===
        const PRESETS = {
            // 10x10, 70% å¯†åº¦
            'normal': { w: 10, h: 10, d: 70, adaptive: false },

            // 15x20, 50% å¯†åº¦ (å¼€å¯è‡ªé€‚åº”ï¼šæ¨ªå±å®½20ï¼Œç«–å±å®½15)
            'enhanced': { w: 15, h: 20, d: 50, adaptive: true },

            // 30x30, 30% å¯†åº¦
            'ultimate': { w: 30, h: 30, d: 30, adaptive: false }
        };

        function getAdaptiveDimensions(baseW, baseH) {
            const isLandscape = window.innerWidth > window.innerHeight;
            const short = Math.min(baseW, baseH);
            const long = Math.max(baseW, baseH);

            // å¦‚æœæ˜¯æ¨ªå±ï¼Œå®½æ˜¯é•¿è¾¹ï¼›å¦‚æœæ˜¯ç«–å±ï¼Œå®½æ˜¯çŸ­è¾¹
            return isLandscape
                ? { w: long, h: short }
                : { w: short, h: long };
        }

        function updateSliderLabels() {
            document.getElementById('val-w').textContent = inpW.value;
            document.getElementById('val-h').textContent = inpH.value;
            document.getElementById('val-d').textContent = inpD.value + '%';
        }

        [inpW, inpH, inpD].forEach(el => {
            el.addEventListener('input', () => {
                updateSliderLabels();
                // å¦‚æœç”¨æˆ·åŠ¨äº†æ»‘å—ï¼Œè‡ªåŠ¨åˆ‡åˆ°è‡ªå®šä¹‰æ¨¡å¼ï¼ˆä½†ä¸ºäº†é€»è¾‘ç®€å•ï¼Œè¿™é‡Œåªæ›´æ–°æ•°å€¼ï¼Œæ¨¡å¼åˆ‡æ¢ç”±ä¸‹æ‹‰æ¡†å†³å®šï¼‰
            });
        });

        diffSelect.addEventListener('change', () => {
            applyMode(diffSelect.value);
        });

        const protocolDesc = document.getElementById('protocol-desc');

        // æè¿°æ–‡æœ¬ï¼ˆå®Œå…¨æ±‰åŒ–ï¼Œä¿®æ­£éš¾åº¦é€»è¾‘ï¼‰
        const DESCRIPTIONS = {
            'normal': "ã€ä½é£é™©ã€‘é›·åŒºä¿¡å·æå¼ºã€‚ç›®æ ‡é«˜åº¦é¥±å’Œï¼Œè¿é”ååº”ææ˜“è§¦å‘ã€‚é€‚åˆå¿«é€Ÿä¸Šæ‰‹ä¸å‹åŠ›é‡Šæ”¾ã€‚",

            'enhanced': "ã€ä¸­é£é™©ã€‘æ ‡å‡†æˆ˜æœ¯ç¯å¢ƒã€‚å¨èƒåˆ†å¸ƒå‡è¡¡ï¼Œéœ€åœ¨æ‰«æä¸è§„é¿é—´å¯»æ‰¾å¹³è¡¡ã€‚ç³»ç»Ÿå°†è‡ªåŠ¨é€‚é…å±å¹•è§†é‡ã€‚",

            'ultimate': "ã€æé«˜é£é™©ã€‘é™é»˜æ½œè¡Œä»»åŠ¡ã€‚ç›®æ ‡æåº¦ç¨€ç–ï¼Œå¤§é‡å®‰å…¨åŒºå¹²æ‰°åˆ¤å®šã€‚ä»»ä½•ç›²ç›®è¯•æ¢éƒ½å°†å¯¼è‡´ä»»åŠ¡å¤±è´¥ã€‚",

            'custom': "æ‰‹åŠ¨è¦†å†™ç³»ç»Ÿå‚æ•°ã€‚å…è®¸æ“ä½œå‘˜è‡ªå®šä¹‰ç½‘æ ¼å°ºå¯¸ä¸å¨èƒå¯†åº¦ã€‚è¯·æ³¨æ„ï¼šå¯†åº¦è¶Šä½ï¼Œå®¹é”™ç‡è¶Šä½ã€‚"
        };

        function applyMode(mode) {
            if (protocolDesc && DESCRIPTIONS[mode]) {
                protocolDesc.textContent = DESCRIPTIONS[mode];
            }

            if (mode === 'custom') {
                // è‡ªå®šä¹‰æ¨¡å¼ï¼šæ˜¾ç¤ºæ»‘å—ï¼Œä¸å¼ºåˆ¶ä¿®æ”¹æ•°å€¼
                customSettings.classList.remove('hidden');
            } else if (PRESETS[mode]) {
                // é¢„è®¾æ¨¡å¼ï¼šéšè—æ»‘å—
                customSettings.classList.add('hidden');

                const p = PRESETS[mode];
                let targetW = p.w;
                let targetH = p.h;

                // ã€å…³é”®ã€‘å¦‚æœæ˜¯å¢å¼ºåè®®ï¼ˆadaptive=trueï¼‰ï¼Œæ£€æŸ¥å½“å‰å±å¹•æ–¹å‘
                if (p.adaptive) {
                    const dims = getAdaptiveDimensions(p.w, p.h);
                    targetW = dims.w;
                    targetH = dims.h;
                }

                inpW.value = targetW;
                inpH.value = targetH;
                inpD.value = p.d;
                updateSliderLabels();
            }
        }

        document.getElementById('btn-start').addEventListener('click', () => {
            const mode = syncConfigFromUI();

            updateURLSettings(mode, CONFIG.gridW, CONFIG.gridH, Math.round(CONFIG.density * 100));

            // 3. å¼€å§‹æ¸¸æˆ
            menuOverlay.classList.add('hidden');
            initGame();
        });

        document.getElementById('btn-restart').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            syncConfigFromUI();
            initGame();
        });

        document.getElementById('btn-menu').addEventListener('click', () => {
            document.getElementById('game-over-overlay').classList.add('hidden');
            clearURLSettings();
            menuOverlay.classList.remove('hidden');
        });

        // æ¸¸æˆå†…èœå•æŒ‰é’®äº‹ä»¶
        document.getElementById('btn-ingame-restart').addEventListener('click', () => {
            syncConfigFromUI();
            initGame();
        });

        // === ä¿®æ”¹åçš„èœå•æŒ‰é’®é€»è¾‘ ===
        document.getElementById('btn-ingame-menu').addEventListener('click', () => {
            // 1. ç«‹å³åœæ­¢è®¡æ—¶å™¨ (æ ¸å¿ƒä¿®å¤ï¼šé˜²æ­¢èƒŒæ™¯æ—¶é—´ç»§ç»­èµ°)
            stopTimer();

            // 2. æ ‡è®°æ¸¸æˆç»“æŸï¼Œé˜»æ–­åç»­äº¤äº’
            isGameOver = true;

            // 3. æ¸…ç†æ‰€æœ‰å¯èƒ½çš„å¤±è´¥åŠ¨ç”»/å»¶æ—¶
            if (window.failIntervals) {
                window.failIntervals.forEach(id => clearTimeout(id));
                window.failIntervals = [];
            }
            if (window.failTimeout) clearTimeout(window.failTimeout);
            if (window.gameResultTimeout) clearTimeout(window.gameResultTimeout);

            // 4. æ›´æ–° HUD çŠ¶æ€
            hudStatus.textContent = "å·²æŒ‚èµ·";
            hudStatus.style.color = "#888";

            clearURLSettings();

            // 5. ç¡®ä¿ç»“ç®—å¼¹çª—å…³é—­ï¼Œå¹¶æ˜¾ç¤ºä¸»èœå•
            document.getElementById('game-over-overlay').classList.add('hidden');
            menuOverlay.classList.remove('hidden');

            applyMode(diffSelect.value);
        });

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–ä»¥é‡æ–°è®¡ç®—å¸ƒå±€ï¼ˆå¯é€‰ï¼Œç®€å•èµ·è§ç›´æ¥é‡ç½®å¯èƒ½æ›´å¥½ï¼Œæˆ–è€…åŠ¨æ€è°ƒæ•´ grid-wrapperï¼‰
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // åªæœ‰åœ¨éæ¸¸æˆè¿›è¡Œä¸­æˆ–è€…ä½ æƒ³æ”¯æŒåŠ¨æ€è°ƒæ•´æ—¶æ‰è°ƒç”¨
                // è¿™é‡Œä¸ºäº†ä½“éªŒæµç•…ï¼Œå»ºè®®ç”¨æˆ·æ‰‹åŠ¨é‡å¼€ï¼Œæˆ–è€…åªé‡æ–°è®¡ç®— grid å°ºå¯¸è€Œä¸æ¸…ç©ºæ•°æ®
                // ç®€å•å¤„ç†ï¼šé‡æ–°åˆå§‹åŒ–
                if (!isGameOver && revealedMines === 0) {
                    initGame();
                }
            }, 500);
        });

        setupInput();

        function syncConfigFromUI() {
            const mode = diffSelect.value;

            // å…³é”®ï¼šè®© enhanced åœ¨â€œæ­¤åˆ»çš„æ¨ªç«–å±â€ä¸‹é‡æ–°è®¡ç®— inpW/inpH
            applyMode(mode);

            // å†æŠŠ UI çš„æœ€ç»ˆå€¼å†™å› CONFIG
            CONFIG.gridW = parseInt(inpW.value, 10);
            CONFIG.gridH = parseInt(inpH.value, 10);
            CONFIG.density = parseInt(inpD.value, 10) / 100;

            return mode;
        }

        function loadSettingsFromURL() {
            const params = new URLSearchParams(window.location.search);

            // 1. ä¼˜å…ˆæ£€æŸ¥ mode å‚æ•°
            if (params.has('mode')) {
                const mode = params.get('mode');

                // å¦‚æœæ˜¯æœ‰æ•ˆé¢„è®¾
                if (PRESETS[mode]) {
                    diffSelect.value = mode;
                    applyMode(mode);
                    // è¿™é‡Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨æ›´æ–° CONFIGï¼Œå› ä¸º applyMode åªæ›´æ–°äº† DOM
                    CONFIG.gridW = parseInt(inpW.value, 10);
                    CONFIG.gridH = parseInt(inpH.value, 10);
                    CONFIG.density = parseInt(inpD.value, 10) / 100;
                    return true; // è‡ªåŠ¨å¼€å§‹
                }

                // å¦‚æœæ˜¯è‡ªå®šä¹‰æ¨¡å¼
                if (mode === 'custom') {
                    diffSelect.value = 'custom';
                    applyMode('custom');

                    // å°è¯•è¯»å– w, h, d å‚æ•°
                    if (params.has('w') && params.has('h') && params.has('d')) {
                        const w = parseInt(params.get('w')) || 10;
                        const h = parseInt(params.get('h')) || 15;
                        const d = parseInt(params.get('d')) || 30;

                        inpW.value = w;
                        inpH.value = h;
                        inpD.value = d;
                        updateSliderLabels();

                        CONFIG.gridW = w;
                        CONFIG.gridH = h;
                        CONFIG.density = d / 100;
                        return true; // è‡ªåŠ¨å¼€å§‹
                    }
                }
            }

            // é»˜è®¤æƒ…å†µï¼šå¦‚æœæ²¡æœ‰ modeï¼Œæˆ–è€…å‚æ•°ä¸å…¨ï¼Œä¸åšè‡ªåŠ¨å¼€å§‹ï¼Œ
            // ä½†æˆ‘ä»¬å¯ä»¥åˆå§‹åŒ–ä¸€ä¸‹ç•Œé¢æ˜¾ç¤º
            applyMode('normal'); // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
            return false;
        }

        function updateURLSettings(mode, w, h, d) {
            const url = new URL(window.location);

            // æ€»æ˜¯å†™å…¥ mode
            url.searchParams.set('mode', mode);

            if (mode === 'custom') {
                // åªæœ‰è‡ªå®šä¹‰æ¨¡å¼æ‰å†™å…¥ w, h, d
                url.searchParams.set('w', w);
                url.searchParams.set('h', h);
                url.searchParams.set('d', d);
            } else {
                // éè‡ªå®šä¹‰æ¨¡å¼ï¼Œç§»é™¤ w, h, d
                url.searchParams.delete('w');
                url.searchParams.delete('h');
                url.searchParams.delete('d');
            }

            window.history.replaceState({}, '', url);
        }

        function clearURLSettings() {
            const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
            window.history.replaceState({}, '', cleanUrl);
        }

        function setupUISounds() {
            // 1. æŒ‰é’®ã€ä¸‹æ‹‰æ¡†ã€å¤´åƒé“¾æ¥
            // åŒ…å«: .menu-btn(ä¸»èœå•æŒ‰é’®), .icon-btn(é¡¶éƒ¨å›¾æ ‡), select(ä¸‹æ‹‰æ¡†), #profile-link(å¤´åƒ)
            const interactiveElements = document.querySelectorAll('.menu-btn, .icon-btn, select, #profile-link');

            interactiveElements.forEach(el => {
                // é¼ æ ‡ç§»å…¥éŸ³æ•ˆ (åŸæœ‰çš„ hover éŸ³æ•ˆ)
                el.addEventListener('mouseenter', () => {
                    // åªæœ‰æœªè¢«ç¦ç”¨çš„å…ƒç´ æ‰å‘å£°
                    if (!el.disabled) playSound('hover');
                });

                // é¼ æ ‡ç‚¹å‡»éŸ³æ•ˆ (æ–°çš„ ui-click)
                el.addEventListener('click', () => {
                    if (!el.disabled) playSound('ui-click');
                });

                // ç‰¹æ®Šï¼šä¸‹æ‹‰æ¡†æ”¹å˜é€‰é¡¹æ—¶ä¹Ÿæ’­æ”¾ç‚¹å‡»éŸ³
                if (el.tagName === 'SELECT') {
                    el.addEventListener('change', () => playSound('ui-click'));
                }
            });

            // 2. æ»‘å— (Range Inputs)
            const rangeInputs = document.querySelectorAll('input[type="range"]');
            rangeInputs.forEach(el => {
                // ç§»å…¥æ»‘å—
                el.addEventListener('mouseenter', () => playSound('hover'));

                // æ‹–åŠ¨æ»‘å—æ—¶æ’­æ”¾è¿ç»­çš„ tick éŸ³æ•ˆ
                el.addEventListener('input', () => playSound('ui-tick'));
            });
        }

        document.getElementById('btn-ingame-mute').addEventListener('click', function (e) {
            isMuted = !isMuted;

            // ã€å…³é”®ã€‘ä¿å­˜çŠ¶æ€åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem('mineseeker_mute', isMuted);

            // æ›´æ–°ç•Œé¢
            updateMuteButtonUI();

            // å¦‚æœæ˜¯å–æ¶ˆé™éŸ³ï¼Œæ’­æ”¾ä¸€å£°åé¦ˆ
            if (!isMuted) {
                playSound('ui-click');
            }

            e.stopPropagation();
        });

        function updateMuteButtonUI() {
            const btn = document.getElementById('btn-ingame-mute');
            if (!btn) return;

            if (isMuted) {
                btn.textContent = 'ğŸ”‡';
                // é™éŸ³çŠ¶æ€æ ·å¼
                btn.style.borderColor = 'var(--neon-red)';
                btn.style.color = 'var(--neon-red)';
                btn.style.boxShadow = '0 0 10px var(--neon-red)';
                btn.style.background = 'rgba(255, 0, 60, 0.1)';
            } else {
                btn.textContent = 'ğŸ”Š';
                // æ¢å¤æ­£å¸¸æ ·å¼
                btn.style.borderColor = '';
                btn.style.color = '';
                btn.style.boxShadow = '';
                btn.style.background = '';
            }
        }
        updateMuteButtonUI();

        // å¯åŠ¨å…¥å£
        const shouldAutoStart = loadSettingsFromURL();
        setupUISounds();
        if (shouldAutoStart) {
            menuOverlay.classList.add('hidden');
            initGame();
        } else {
            menuOverlay.classList.remove('hidden');
        }
    </script>
</body>

</html>
